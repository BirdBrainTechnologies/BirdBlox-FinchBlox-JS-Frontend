/**
 * When BirdBlox was created, we initially were going to have tabs on the main canvas for different sprites.
 * All messages to blocks are passed from TabManager > Tab > BlockStack > Block > Slot > etc.
 * We decided not to have tabs, so there's just one tab, which is generated by the TabManager when it is created.
 * Tabs pass messages to Blocks and manage the canvas.  They control scrolling/zooming of the canvas and the arrows
 * that indicate off-screen Blocks.
 * @constructor
 */
function Tab() {
	// group for the canvas
	this.mainG = GuiElements.create.group(0, 0);
	// The amount the canvas has been scrolled in each direction
	this.scrollX = 0;
	this.scrollY = 0;
	// The amount the canvas is zoomed
	this.zoomFactor = 1;
	// Whether the tab is visible (always true for the current tab)
	this.visible = false;
	TabManager.addTab(this);
	// List of stacks to pass messages to
	this.stackList = [];
	this.isRunning = false;
	this.scrolling = false;
	this.zooming = false;
	// Used while dragging.  Stores difference between the touch coords and scrollX/scrollY
	this.scrollXOffset = 0;
	this.scrollYOffset = 0;
	// Used while pinch zooming.  Stores the distance between the two fingers initially
	this.zoomStartDist = null;
	// Stores the initial zoomFactor while pinch zooming
	this.startZoom = null;
	// Updates the transformation on the group to reflect the zoom factor and scroll position
	this.updateTransform();
	// Arrows to show off-screen blocks
	this.overFlowArr = new OverflowArrows();
	// Dimension information
	this.dim = {};
	this.dim.x1 = 0;
	this.dim.y1 = 0;
	this.dim.x2 = 0;
	this.dim.y2 = 0;
}

/**
 * Brings the tab to the foreground.  Called by TabManager.
 */
Tab.prototype.activate = function() {
	GuiElements.layers.activeTab.appendChild(this.mainG);
	this.overFlowArr.show();
};

/**
 * Adds a stack to the list.  Called by stack constructor.
 * @param {BlockStack} stack
 */
Tab.prototype.addStack = function(stack) {
	this.stackList.push(stack);
};

/**
 * Removes a stack from the list. Called from BlockSTack.prototype.remove
 * @param {BlockStack} stack
 */
Tab.prototype.removeStack = function(stack) {
	const index = this.stackList.indexOf(stack);
	this.stackList.splice(index, 1);
};

/* Convert between screen coords and coords within the Tab */
/**
 * @param {number} x
 * @return {number}
 */
Tab.prototype.relToAbsX = function(x) {
	return x * this.zoomFactor + this.scrollX;
};
/**
 * @param {number} y
 * @return {number}
 */
Tab.prototype.relToAbsY = function(y) {
	return y * this.zoomFactor + this.scrollY;
};
/**
 * @param {number} x
 * @return {number}
 */
Tab.prototype.absToRelX = function(x) {
	return (x - this.scrollX) / this.zoomFactor;
};
/**
 * @param {number} y
 * @return {number}
 */
Tab.prototype.absToRelY = function(y) {
	return (y - this.scrollY) / this.zoomFactor;
};
/**
 * @return {number}
 */
Tab.prototype.getAbsX = function() {
	return this.relToAbsX(0);
};
/**
 * @return {number}
 */
Tab.prototype.getAbsY = function() {
	return this.relToAbsY(0);
};

/* Recursively passed messages.  Each of these function simply calls the function on the Tab's stacks */
Tab.prototype.findBestFit = function() {
	this.passRecursively("findBestFit");
};
Tab.prototype.eventFlagClicked = function() {
	this.passRecursively("eventFlagClicked");
};
Tab.prototype.eventBroadcast = function(message) {
	this.passRecursively("eventBroadcast", message);
};
Tab.prototype.updateAvailableMessages = function() {
	this.passRecursively("updateAvailableMessages");
};
Tab.prototype.renameVariable = function(variable) {
	this.passRecursively("renameVariable", variable);
};
Tab.prototype.deleteVariable = function(variable) {
	this.passRecursively("deleteVariable", variable);
};
Tab.prototype.renameList = function(list) {
	this.passRecursively("renameList", list);
};
Tab.prototype.deleteList = function(list) {
	this.passRecursively("deleteList", list);
};

/* Recursive functions that return booleans.  These functions call a function on each stack and return true if any
 * stack returns true. */
/**
 * @param {string} message
 * @return {boolean}
 */
Tab.prototype.checkBroadcastRunning = function(message) {
	if (this.isRunning) {
		const stacks = this.stackList;
		for (let i = 0; i < stacks.length; i++) {
			if (stacks[i].checkBroadcastRunning(message)) {
				return true;
			}
		}
	}
	return false;
};
/**
 * @param {Variable} variable
 * @return {boolean}
 */
Tab.prototype.checkVariableUsed = function(variable) {
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		if (stacks[i].checkVariableUsed(variable)) {
			return true;
		}
	}
	return false;
};
/**
 * @param {List} list
 * @return {boolean}
 */
Tab.prototype.checkListUsed = function(list) {
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		if (stacks[i].checkListUsed(list)) {
			return true;
		}
	}
	return false;
};

/**
 * Updates execution of Blocks.  This function performs one execution step on every stack.
 * @returns {ExecutionStatus} - Whether the tab is still running
 */
Tab.prototype.updateRun = function() {
	if (!this.isRunning) {
		return new ExecutionStatusDone();
	}
	const stacks = this.stackList;
	let rVal = false;
	for (let i = 0; i < stacks.length; i++) {
		rVal = stacks[i].updateRun().isRunning() || rVal;
	}
	this.isRunning = rVal;
	if (this.isRunning) {
		return new ExecutionStatusRunning();
	} else {
		return new ExecutionStatusDone();
	}
};

/**
 * Stops execution of all stacks
 */
Tab.prototype.stop = function() {
	this.passRecursively("stop");
	this.isRunning = false;
};

/**
 * Stops execution of all stacks except the specified stack
 * @param stack
 */
Tab.prototype.stopAllButStack = function(stack) {
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		if (stacks[i] !== stack) {
			stacks[i].stop();
		}
	}
};

/**
 * Passes up the message to start running to the TabManager.  Called by a stack when it is tapped.
 */
Tab.prototype.startRun = function() {
	this.isRunning = true;
	TabManager.startRun();
};

/**
 * Stores information necessary to begin scrolling when the user drags their finger on the canvas
 * @param {number} x - The x coord of the touch
 * @param {number} y - The y coord of the touch
 */
Tab.prototype.startScroll = function(x, y) {
	if (!this.scrolling) {
		this.scrolling = true;
		this.scrollXOffset = this.scrollX - x;
		this.scrollYOffset = this.scrollY - y;
		this.updateTabDim();
	}
};

/**
 * Moves the canvas to the correct location, given that the user dragged to the provided coordinate
 * @param {number} x - The x coord of the touch
 * @param {number} y - The y coord of the touch
 */
Tab.prototype.updateScroll = function(x, y) {
	if (this.scrolling) {
		this.scrollX = this.scrollXOffset + x;
		this.scrollY = this.scrollYOffset + y;
		GuiElements.move.group(this.mainG, this.scrollX, this.scrollY, this.zoomFactor);
		this.updateArrowsShift();
	}
};

/**
 * Notes that the canvas is done scrolling
 */
Tab.prototype.endScroll = function() {
	this.scrolling = false;
};

/**
 * Stores data necessary to start zooming when the user has two fingers on the screen
 * @param {number} x1 - The x coord of the first touch
 * @param {number} y1 - The y coord of the first touch
 * @param {number} x2 - The x coord of the second touch
 * @param {number} y2 - The y coord of the second touch
 */
Tab.prototype.startZooming = function(x1, y1, x2, y2) {
	if (!this.zooming) {
		this.zooming = true;
		const x = (x1 + x2) / 2;
		const y = (y1 + y2) / 2;
		this.scrollXOffset = this.scrollX - x;
		this.scrollYOffset = this.scrollY - y;
		const deltaX = x2 - x1;
		const deltaY = y2 - y1;
		this.zoomStartDist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
		this.startZoom = this.zoomFactor;
		this.updateTabDim();
	}
};

/**
 * Moves and zooms the canvas given the positions of the two touches
 * @param {number} x1 - The x coord of the first touch
 * @param {number} y1 - The y coord of the first touch
 * @param {number} x2 - The x coord of the second touch
 * @param {number} y2 - The y coord of the second touch
 */
Tab.prototype.updateZooming = function(x1, y1, x2, y2) {
	if (this.zooming) {
		const x = (x1 + x2) / 2;
		const y = (y1 + y2) / 2;
		const deltaX = x2 - x1;
		const deltaY = y2 - y1;
		const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
		this.zoomFactor = this.startZoom * dist / this.zoomStartDist;
		this.zoomFactor = Math.max(TabManager.minZoom, Math.min(TabManager.maxZoom, this.zoomFactor));
		const zoomRatio = this.zoomFactor / this.startZoom;
		this.scrollX = this.scrollXOffset * zoomRatio + x;
		this.scrollY = this.scrollYOffset * zoomRatio + y;
		this.updateTransform();
		this.updateArrowsShift();
	}
};

/**
 * Notes that the canvas is done zooming
 */
Tab.prototype.endZooming = function() {
	this.zooming = false;
};

/**
 * Updates the transformation on the group according to the scroll position and zoom.
 */
Tab.prototype.updateTransform = function() {
	GuiElements.move.group(this.mainG, this.scrollX, this.scrollY, this.zoomFactor);
	GuiElements.update.zoom(GuiElements.layers.drag, this.zoomFactor);
	GuiElements.update.zoom(GuiElements.layers.highlight, this.zoomFactor);
};

/**
 * Recursively computes the dimensions of the Tab by allowing all stacks to update the bounding box
 */
Tab.prototype.updateTabDim = function() {
	const dim = this.dim;
	dim.width = 0;
	dim.height = 0;
	dim.x1 = null;
	dim.y1 = null;
	dim.x2 = null;
	dim.y2 = null;
	this.passRecursively("updateTabDim");
	if (dim.x1 == null) {
		dim.x1 = 0;
		dim.y1 = 0;
		dim.x2 = 0;
		dim.y2 = 0;
	}
};

/**
 * Writes the contents of the Tab to xml
 * @param {Document} xmlDoc - The XML document to write to
 * @return {Node} - The XML Node for this Tab
 */
Tab.prototype.createXml = function(xmlDoc) {
	const tab = XmlWriter.createElement(xmlDoc, "tab");
	//XmlWriter.setAttribute(tab,"name",this.name);
	XmlWriter.setAttribute(tab, "x", this.scrollX);
	XmlWriter.setAttribute(tab, "y", this.scrollY);
	XmlWriter.setAttribute(tab, "zoom", this.zoomFactor);
	const stacks = XmlWriter.createElement(xmlDoc, "stacks");
	for (let i = 0; i < this.stackList.length; i++) {
		stacks.appendChild(this.stackList[i].createXml(xmlDoc));
	}
	tab.appendChild(stacks);
	return tab;
};

/**
 * Imports the stacks from the provided node into this tab
 * @param {Node} tabNode - The tab node to import from
 * @return {Tab}
 */
Tab.importXml = function(tabNode) {
	const x = XmlWriter.getAttribute(tabNode, "x", 0, true);
	const y = XmlWriter.getAttribute(tabNode, "y", 0, true);
	const zoom = XmlWriter.getAttribute(tabNode, "zoom", 1, true);
	const tab = new Tab();
	tab.scrollX = x;
	tab.scrollY = y;
	tab.zoomFactor = zoom;
	tab.updateTransform();
	const stacksNode = XmlWriter.findSubElement(tabNode, "stacks");
	if (stacksNode != null) {
		const stackNodes = XmlWriter.findSubElements(stacksNode, "stack");
		for (let i = 0; i < stackNodes.length; i++) {
			BlockStack.importXml(stackNodes[i], tab);
		}
	}
	tab.updateArrows();
	return tab;
};

/**
 * Removes the tab
 */
Tab.prototype.delete = function() {
	this.passRecursively("remove");
	this.mainG.remove();
};

/**
 * Creates a stack based on the stackNode provided by the UndoManager in the top left corner
 * @param {Node} stackNode - The XML node for the stack
 * @return {boolean} - Whether the stack was created (false if the XML is invalid)
 */
Tab.prototype.undoDelete = function(stackNode) {
	// The position is randomized slightly to make multiple undos look like a "pile" of blocks, so all are visible
	const xMargin = TabManager.undoDeleteMarginRand * Math.random() + TabManager.undoDeleteMarginBase;
	const yMargin = TabManager.undoDeleteMarginRand * Math.random() + TabManager.undoDeleteMarginBase;

	const x = this.absToRelX(xMargin + BlockPalette.width);
	const y = this.absToRelY(yMargin + TitleBar.height);
	const stack = BlockStack.importXml(stackNode, this);
	if (stack == null) {
		return false;
	}
	stack.move(x, y);
	this.updateArrows();
	return true;
};

/**
 * Returns the maximum selected value of all the DeviceDropSlots for a certain type of device
 * @param deviceClass - Subclass of device
 * @return {number}
 */
Tab.prototype.countDevicesInUse = function(deviceClass) {
	let largest = 0;
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		largest = Math.max(largest, stacks[i].countDevicesInUse(deviceClass));
	}
	return largest;
};

/**
 * Passes a message down to the Blocks/Slots in the tab
 * @param {string} message - The message to send.  Probably a function in the target object
 */
Tab.prototype.passRecursivelyDown = function(message) {
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);
};

/**
 * Calls the function on all Stacks in this tab
 * @param {function} functionName - The name of the function to call
 */
Tab.prototype.passRecursively = function(functionName) {
	const args = Array.prototype.slice.call(arguments, 1);
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		const currentStack = stacks[i];
		const currentL = stacks.length;
		currentStack[functionName].apply(currentStack, args);
		if (currentL !== stacks.length) {
			i--;
		}
	}
};

/**
 * Retrieves the zoom from the tab
 * @return {number}
 */
Tab.prototype.getZoom = function() {
	return this.zoomFactor;
};

/**
 * Updates the UI for the new zoom level
 */
Tab.prototype.updateZoom = function() {
	this.overFlowArr.updateZoom();
	this.updateArrows();
};

/**
 * Makes the arrows appear/disappear depending on the size/position of the canvas
 */
Tab.prototype.updateArrows = function() {
	this.updateTabDim();
	const x1 = this.relToAbsX(this.dim.x1);
	const y1 = this.relToAbsY(this.dim.y1);
	const x2 = this.relToAbsX(this.dim.x2);
	const y2 = this.relToAbsY(this.dim.y2);
	this.overFlowArr.setArrows(x1, x2, y1, y2);
};

/**
 * Like updateArrows but avoids recomputing the size of the Tab, since it assumes that the canvas has only been zoomed
 * and the Blocks have not changed
 */
Tab.prototype.updateArrowsShift = function() {
	const x1 = this.relToAbsX(this.dim.x1);
	const y1 = this.relToAbsY(this.dim.y1);
	const x2 = this.relToAbsX(this.dim.x2);
	const y2 = this.relToAbsY(this.dim.y2);
	this.overFlowArr.setArrows(x1, x2, y1, y2);
};