"use strict";
const FrontendVersion = 393;


/**
 * This static class provides functions for debugging.  It had contracts and a safeFunc higher order function which
 * wraps a function in a try/catch and shows an alert if there is an error.  When enabled is set to false, all these
 * features turn off, except error logging, which happens silently in the background
 */
function DebugOptions() {
	const DO = DebugOptions;
	DO.enabled = true;

	/* Whether errors should be checked for and sent to the backend.  This is the only option that persists if
	 * DO is not enabled */
	DO.logErrors = true;
	// Whether a dialog should be presented with the content of the error
	DO.notifyErrors = true;

	DO.mouse = false;
	// On launch, virtual devices can be added
	DO.addVirtualHB = true;
	DO.addVirtualFlutter = false;
	// When scanning, virtual devices can be added to the lists
	DO.allowVirtualDevices = false;
	DO.showVersion = false;
	DO.showDebugMenu = true;
	// When there's an error, should the entire UI freeze to ensure it isn't missed?
	DO.lockErrors = false;
	DO.errorLocked = false;
	DO.logHttp = true;
	DO.skipInitSettings = false;
	DO.allowLogging = true;
	DO.skipHtmlRequests = false;
	if (DO.enabled) {
		DO.applyConstants();
	}
}

/**
 * Runs before other classes setConstants functions.  Provides an opportunity to do some setup
 */
DebugOptions.applyConstants = function() {
	const DO = DebugOptions;
	if (!DO.enabled) return;
	// Currently nothing happens here.
};

/**
 * Runs after the UI is loaded
 */
DebugOptions.applyActions = function() {
	const DO = DebugOptions;
	if (!DO.enabled) return;
	if (DO.addVirtualHB) {
		let virHB = DO.createVirtualDevice(DeviceHummingbird, "");
		DeviceHummingbird.getManager().appendDevice(virHB);
	}
	if (DO.addVirtualFlutter) {
		let virHB = DO.createVirtualDevice(DeviceFlutter, "");
		DeviceFlutter.getManager().appendDevice(virHB);
	}
	if (DO.showVersion) {
		GuiElements.alert("Version: " + GuiElements.appVersion);
	}
	if (DO.showDebugMenu) {
		TitleBar.enableDebug();
	}
};

/**
 * Creates a virtual device with the specified type and id
 * @param deviceClass - Subclass of Device
 * @param {string} id - Used for name and id of device, with "Virtual" prepended to it
 * @return {Device}
 */
DebugOptions.createVirtualDevice = function(deviceClass, id) {
	const typeName = deviceClass.getDeviceTypeName(true);
	const name = "Virtual" + typeName + id;
	return new deviceClass(name, name);
};

/* These functions all check if a certain type of debugging should be enabled and are called from other classes. */
/** @return {boolean} */
DebugOptions.shouldLogErrors = function() {
	return DebugOptions.logErrors;   // This is the one setting that still works if DO is not enabled.
};
/** @return {boolean} */
DebugOptions.shouldNotifyErrors = function() {
	return DebugOptions.notifyErrors && DebugOptions.enabled;
};
/** @return {boolean} */
DebugOptions.shouldUseMouseMode = function() {
	return DebugOptions.mouse && DebugOptions.enabled;
};
/** @return {boolean} */
DebugOptions.shouldSkipInitSettings = function() {
	const DO = DebugOptions;
	return DO.enabled && DO.mouse && DO.skipInitSettings;
};
/** @return {boolean} */
DebugOptions.shouldSkipHtmlRequests = function() {
	const DO = DebugOptions;
	return DO.enabled && (DO.skipHtmlRequests || DO.mouse);
};
/** @return {boolean} */
DebugOptions.shouldUseJSDialogs = function() {
	const DO = DebugOptions;
	return DO.enabled && (DO.mouse);
};
/** @return {boolean} */
DebugOptions.shouldLogHttp = function() {
	const DO = DebugOptions;
	return DO.enabled && DO.logHttp;
};
/** @return {boolean} */
DebugOptions.shouldAllowVirtualDevices = function() {
	const DO = DebugOptions;
	return DO.allowVirtualDevices && DO.enabled;
};
/** @return {boolean} */
DebugOptions.shouldAllowLogging = function() {
	const DO = DebugOptions;
	return DO.allowLogging && DO.enabled;
};

/* These functions configure DO */
DebugOptions.enableVirtualDevices = function() {
	const DO = DebugOptions;
	DO.allowVirtualDevices = true;
};
DebugOptions.stopErrorLocking = function() {
	DebugOptions.lockErrors = false;
};
DebugOptions.enableLogging = function() {
	DebugOptions.allowLogging = true;
};

/**
 * This function takes in a function and returns a function wrapped in a try/catch that shows a dialog with a stack
 * trace on error.  If DO isn't enabled, it just returns the original function.
 * @param {function} func
 * @return {function}
 */
DebugOptions.safeFunc = function(func) {
	if (func == null) return null;
	if (DebugOptions.shouldLogErrors() || DebugOptions.shouldNotifyErrors()) {
		return function() {
			try {
				if (!DebugOptions.errorLocked || !DebugOptions.lockErrors) {
					func.apply(this, arguments);
				}
			} catch (err) {
				DebugOptions.errorLocked = true;
				const request = new HttpRequestBuilder("debug/log");
				const errorTrace = err.message + "\n" + err.stack;
				HtmlServer.sendRequestWithCallback(request.toString(), null, null, true, errorTrace);
				if (DebugOptions.shouldNotifyErrors()) {
					GuiElements.alert("ERROR: " + err.message);
					DialogManager.showAlertDialog("ERROR", errorTrace, "OK");
				}
			}
		}
	} else {
		return func;
	}
};

/* Contracts test a certain condition and throw an error if it isn't met */

/**
 * Verifies that all parameters are numbers that are finite and not NaN
 */
DebugOptions.validateNumbers = function() {
	if (!DebugOptions.shouldLogErrors()) return;
	for (let i = 0; i < arguments.length; i++) {
		if (isNaN(arguments[i]) || !isFinite(arguments[i])) {
			throw new UserException("Invalid Number");
		}
	}
};
/**
 * Verifies that all parameters are not null or undefined
 */
DebugOptions.validateNonNull = function() {
	if (!DebugOptions.shouldLogErrors()) return;
	for (let i = 0; i < arguments.length; i++) {
		if (arguments[i] == null) {
			throw new UserException("Null parameter");
		}
	}
};
/**
 * Verifies that all parameters are either numbers or null
 */
DebugOptions.validateOptionalNums = function() {
	if (!DebugOptions.shouldLogErrors()) return;
	for (let i = 0; i < arguments.length; i++) {
		if (arguments[i] != null && (isNaN(arguments[i]) || !isFinite(arguments[i]))) {
			throw new UserException("Invalid optional number");
		}
	}
};
/**
 * Verifies that the boolean is true
 * @param {boolean} bool
 */
DebugOptions.assert = function(bool) {
	if (!bool && DebugOptions.shouldLogErrors()) {
		throw new UserException("Assertion Failure");
	}
};
/**
 * Throws a custom message
 * @param {string} message
 */
DebugOptions.throw = function(message) {
	if (!DebugOptions.shouldLogErrors()) return;
	throw new UserException(message);
};
/**
 * Marks that a function is abstract and must be overrided before it is run. If run it throws an error.
 */
DebugOptions.markAbstract = function() {
	DebugOptions.throw("Abstract function may not be called");
};

/**
 * A class for custom exceptions
 * @param {string} message
 * @constructor
 */
function UserException(message) {
	this.message = message;
	this.name = 'UserException';
	this.stack = (new Error()).stack;   // Get the call stack
}
/**
 * Data is used hold type information about values passed between executing Blocks.  It creates a sort of type system
 * for the values obtained during Block execution.  For example, when an addition Block is run, it accepts two
 * receives two NumData instances and returns a new NumData instance.  Since Blocks of the wrong type can often be
 * snapped together (for example, the joinStrings Block can be put into a multiplication Block), all types of Data
 * can be converted into any other type of Data (using asNum(), asString(), etc.).  However, whether the data is "valid"
 * is also tracked, with nonsensical conversions always flagging the data as invalid.  Blocks can choose how to respond
 * when the data they receive is invalid.  Data can also be saved to XML, which is used to save the contents of
 * EditableSlots and values of variables to file.
 *
 * The types of data are invisible to the user, and those Data is always automatically converted to the most reasonable
 * type automatically without the user's knowledge.
 *
 * All Data is treated as immutable
 *
 * Note that the Data class is abstract
 *
 * @param {number} type - [num, bool, string, list, selection]
 * @param {*} value - The value being stored in the Data, should correspond to the type of Data
 * @param {boolean} [isValid=true] - Whether the Data has not gone through any illegal conversions (equivalent of NaN)
 * @constructor
 */
function Data(type, value, isValid) {
	this.type = type;
	this.value = value;
	this.isValid = isValid;
	if (isValid == null) {
		this.isValid = true;
	}
}

Data.setConstants = function() {
	Data.types = {};
	Data.types.num = 0;
	Data.types.bool = 1;
	Data.types.string = 2;
	Data.types.list = 3;
	Data.types.selection = 4; //A selection from a block's drop down.  Could be a sound, variable, string, etc.
};

/* These functions manage the conversion of one type of data into another.  By default, they produce invalid Data
 * initialized to default values.  Subclasses provide better conversion functions where applicable
 */

Data.prototype.asNum = function() {
	return new NumData(0, false);
};
Data.prototype.asBool = function() {
	return new BoolData(false, false);
};
Data.prototype.asString = function() {
	return new StringData("", false);
};
Data.prototype.asList = function() {
	return new ListData(null, false);
};
Data.prototype.asSelection = function() {
	return SelectionData.empty(false);
};

/**
 * Extracts the value from the data
 * @return {*}
 */
Data.prototype.getValue = function() {
	return this.value;
};

/**
 * Determines whether the Data is SelectionData
 * @return {boolean}
 */
Data.prototype.isSelection = function() {
	return this.type === Data.types.selection;
};

/**
 * Determines whether the Data will produce a valid number when asNum() is called.  For example,
 * StringData("3").asNum() is valid with value 3.
 * @return {boolean}
 */
Data.prototype.isNumber = function() {
	return false;
};

/**
 * Determines if two Data should be considered equal by the equality Block.
 * @param {Data} data1
 * @param {Data} data2
 * @return {boolean}
 */
Data.checkEquality = function(data1, data2) {
	const val1 = data1.getValue();
	const val2 = data2.getValue();
	const string1 = data1.asString().getValue();
	const string2 = data2.asString().getValue();
	const numD1 = data1.asNum();
	const numD2 = data2.asNum();
	const types = Data.types;
	const isValid = data1.isValid && data2.isValid;
	if (data1.type === data2.type) { //If the types match, just compare directly.
		return isValid && val1 === val2; //Invalid data is never equal.
	} else if (data1.type === types.string || data2.type === types.string) { //If one is a string...
		if (string1 === string2) { //If both strings match, result is true.
			return true;
		} else if (data1.type === types.num || data2.type === types.num) { //Still the numbers could match like "3.0"=3.
			if (numD1.isValid && numD2.isValid) { //If both are valid numbers...
				return numD1.getValue() === numD2.getValue(); //Compare numerical values.
			} else {
				return false; //A string and unequal/invalid number are not equal.
			}
		} else {
			return false; //Two unequal, nonnumerical strings are unequal.
		}
	} else {
		return false; //If the types don't match and neither is a string, they are unequal.
	}
};

/**
 * Converts the Data to XML
 * @param {Document} xmlDoc - The document to write to
 * @return {Node}
 */
Data.prototype.createXml = function(xmlDoc) {
	// We store the type of Data, whether it is valid, and what its value is

	const data = XmlWriter.createElement(xmlDoc, "data");
	XmlWriter.setAttribute(data, "type", this.getDataTypeName());
	XmlWriter.setAttribute(data, "isValid", this.isValid);

	// The value is converted to a string by appending "".  For Variables and Lists, the name is used.
	const value = XmlWriter.createElement(xmlDoc, "value");
	let valueString = this.getValue() + "";
	if (this.getValue().constructor.name === "Variable") {
		valueString = this.getValue().name;
	} else if (this.getValue().constructor.name === "List") {
		valueString = this.getValue().name;
	}
	const valueText = XmlWriter.createTextNode(xmlDoc, valueString);
	value.appendChild(valueText);
	data.appendChild(value);
	return data;
};

/**
 * Reads data from XML.  Returns null if Data is corrupt
 * @param {Node} dataNode
 * @return {Data|null}
 */
Data.importXml = function(dataNode) {
	const typeName = XmlWriter.getAttribute(dataNode, "type");
	const type = Data.getDataTypeFromName(typeName);
	if (type == null) {
		return null;
	}
	return type.importXml(dataNode);
};

/**
 * Gets the string representation of this Data's type
 * @return {string}
 */
Data.prototype.getDataTypeName = function() {
	if (this.type === Data.types.num) {
		return "num";
	} else if (this.type === Data.types.bool) {
		return "bool";
	} else if (this.type === Data.types.string) {
		return "string";
	} else if (this.type === Data.types.list) {
		return "list";
	} else if (this.type === Data.types.selection) {
		return "selection";
	} else {
		DebugOptions.throw("Data is not a valid type");
	}
};

/**
 * Gets the class of Data from a string representing its type or null of the type is invalid
 * @param {string} typeName
 * @return {*|null} - A subclass of Data corresponding to the type, or null if no such subclass exists
 */
Data.getDataTypeFromName = function(typeName) {
	if (typeName === "num") {
		return NumData;
	} else if (typeName === "bool") {
		return BoolData;
	} else if (typeName === "string") {
		return StringData;
	} else if (typeName === "list") {
		return ListData;
	} else if (typeName === "selection") {
		return SelectionData;
	} else {
		return null;
	}
};
/**
 * Data that contains a number value
 * @param value
 * @param isValid
 * @constructor
 */
function NumData(value, isValid) {
	if (isNaN(value) || !isFinite(value)) {
		value = 0;
		isValid = false;
	}
	Data.call(this, Data.types.num, value, isValid);
}
NumData.prototype = Object.create(Data.prototype);
NumData.prototype.constructor = NumData;

/**
 * @return {NumData}
 */
NumData.prototype.asNum = function() {
	return this;
};

/**
 * 0 becomes false and 1 becomes true.  Anything else is invalid
 * @return {BoolData}
 */
NumData.prototype.asBool = function() {
	if (this.getValue() === 1) {
		return new BoolData(true, this.isValid);
	} else if (this.getValue() === 0) {
		return new BoolData(false, this.isValid);
	} else {
		return new BoolData(false, false);
	}
};

/**
 * Rounds number and displays it
 * @return {StringData}
 */
NumData.prototype.asString = function() {
	if (this.isValid) {
		let num = this.getValue();
		num = +num.toFixed(10);
		return new StringData(num + "", true);
	} else {
		return new StringData("not a valid number");
	}
};

/**
 * Converts to a string but avoids scientific notation
 * @return {StringData}
 */
NumData.prototype.asPositiveString = function() {
	let num = Math.abs(this.getValue());
	num = +num.toFixed(10);
	return new StringData(num + "", true);
};

/**
 * Gets the NumData's value within a range.
 * @param {number} [min] - The lower bound
 * @param {number} [max] - The upper bound
 * @param {boolean} positive - Whether the number should be non-negative
 * @param {boolean} integer - Whether the number should be rounded to the nearest integer
 * @return {number}
 */
NumData.prototype.getValueInR = function(min, max, positive, integer) {
	let val = this.getValue();
	if (positive === true && val < 0) {
		val = 0;
	}
	if (integer === true) {
		val = Math.round(val);
	}
	if (min != null && val < min) {
		val = min;
	}
	if (max != null && val > max) {
		val = max;
	}
	return val;
};

/**
 * Returns the value of the NumData, possibly non-negative or rounded to the nearest integer
 * @param {boolean} [positive=false] - Whether the number should be non-negative
 * @param {boolean} [integer=false] - Whether the number should be rounded to the nearest integer
 * @return {number}
 */
NumData.prototype.getValueWithC = function(positive, integer) {
	let val = this.getValue();
	if (positive === true && val < 0) {
		val = 0;
	}
	if (integer === true) {
		val = Math.round(val);
	}
	return val;
};

/**
 * Imports the NumData from XML
 * @param {Node} dataNode
 * @return {NumData|null}
 */
NumData.importXml = function(dataNode) {
	const value = XmlWriter.getTextNode(dataNode, "value", null, true);
	if (value == null) return null;
	// We use StringData to help with the conversion
	const stringData = new StringData(value);
	const numData = stringData.asNum();
	if (numData.isValid) {
		return numData;
	} else {
		// It's not a number.  Treat it as corrupt.
		return null;
	}
};
/**
 * Data that contains a boolean value
 * @param {boolean} value
 * @param {boolean} [isValid=true]
 * @constructor
 */
function BoolData(value, isValid) {
	Data.call(this, Data.types.bool, value, isValid);
}
BoolData.prototype = Object.create(Data.prototype);
BoolData.prototype.constructor = BoolData;

/**
 * Converts true to 1 and false to 0
 * @return {NumData}
 */
BoolData.prototype.asNum = function() {
	if (this.getValue()) {
		return new NumData(1, this.isValid);
	} else {
		return new NumData(0, this.isValid);
	}
};

/**
 * @return {BoolData}
 */
BoolData.prototype.asBool = function() {
	return this;
};

/**
 * @return {StringData}
 */
BoolData.prototype.asString = function() {
	if (this.getValue()) {
		return new StringData("true", true);
	} else {
		return new StringData("false", true);
	}
};

/**
 * @param {Document} dataNode
 * @return {BoolData|null}
 */
BoolData.importXml = function(dataNode) {
	let value = XmlWriter.getTextNode(dataNode, "value");
	if (value == null) return null;
	return new BoolData(value === "true");
};
/**
 * Data that contains a string.
 * @param {string} value
 * @param {boolean} [isValid=true]
 * @constructor
 */
function StringData(value, isValid) {
	Data.call(this, Data.types.string, value, isValid);
}
StringData.prototype = Object.create(Data.prototype);
StringData.prototype.constructor = StringData;

/**
 * If the value could represent a number, it is converted to valid NumData.  Otherwise, invalid NumData(0) is returned
 * @return {NumData}
 */
StringData.prototype.asNum = function() {
	if (this.isNumber()) {
		return new NumData(parseFloat(this.getValue()), this.isValid);
	} else {
		return new NumData(0, false);
	}
};

/**
 * The string is a valid boolean if it is "true" or "false" (any casing)
 * @return {BoolData}
 */
StringData.prototype.asBool = function() {
	if (this.getValue().toUpperCase() === "TRUE") {
		return new BoolData(true, this.isValid);
	} else if (this.getValue().toUpperCase() === "FALSE") {
		return new BoolData(false, this.isValid);
	}
	return new BoolData(false, false);
};

/**
 * @return {StringData}
 */
StringData.prototype.asString = function() {
	return this;
};

/**
 * Checks to see if the number can be converted to a valid number
 * @return {boolean}
 */
StringData.prototype.isNumber = function() {
	//from https://en.wikipedia.org/wiki/Regular_expression
	const numberRE = /^[+-]?(\d+(\.\d+)?|\.\d+)([eE][+-]?\d+)?$/;
	return numberRE.test(this.getValue());
};

/**
 * Imports StringData from XML
 * @param {Node} dataNode
 * @return {StringData|null}
 */
StringData.importXml = function(dataNode) {
	const value = XmlWriter.getTextNode(dataNode, "value");
	if (value == null) return null;
	return new StringData(value);
};
/**
 * ListData holds an array of Data objects as its value.  So to access a string in index 2 of a ListData, you'd do:
 * myListData.getValue()[2].asString().getValue()
 * @param {Array} [value=[]]
 * @param {boolean} [isValid=true]
 * @constructor
 */
function ListData(value, isValid) {
	if (value == null) {
		value = [];
	}
	Data.call(this, Data.types.list, value, isValid);
}
ListData.prototype = Object.create(Data.prototype);
ListData.prototype.constructor = ListData;

/**
 * Creates a copy of the ListData
 * @return {ListData}
 */
ListData.prototype.duplicate = function() {
	const arrayCopy = [];
	for (let i = 0; i < this.value.length; i++) {
		arrayCopy.push(this.value[i]);
	}
	return new ListData(arrayCopy, this.isValid);
};

/**
 * Is a num if it only has one item and that item is a num
 * @return {NumData}
 */
ListData.prototype.asNum = function() {
	if (this.value.length === 1) {
		return this.value[0].asNum();
	} else {
		return new NumData(0, false);
	}
};

/**
 * Prints all elements, comma separated, to a string
 * @return {StringData}
 */
ListData.prototype.asString = function() {
	let resultStr = "";
	for (let i = 0; i < this.value.length; i++) {
		resultStr += this.value[i].asString().getValue();
		if (i < this.value.length - 1) {
			resultStr += ", ";
		}
	}
	return new StringData(resultStr, true);
};

/**
 * Is a Bool if it only has one value and that value is a bool
 * @return {BoolData}
 */
ListData.prototype.asBool = function() {
	if (this.value.length === 1) {
		return this.value[0].asBool();
	} else {
		return new BoolData(false, false);
	}
};

/**
 * @return {ListData}
 */
ListData.prototype.asList = function() {
	return this;
};

/**
 * Converts NumData/SelectionData referring to an index into a number that refers to an index in the ListData, or null
 * @param {Data|null} indexData
 * @return {number|null}
 */
ListData.prototype.getIndex = function(indexData) {
	const array = this.getValue();
	if (array.length === 0) {
		return null; // There are no valid indices to return
	}
	if (indexData == null) {
		return null; // The index data is already invalid
	}
	const indexV = indexData.getValue();
	const min = 1;
	const max = array.length;
	if (indexData.type === Data.types.selection) {
		if (indexV === "last") {
			// Return the index of the last item
			return array.length - 1;
		} else if (indexV === "random") {
			// Return an index of a random item
			return Math.floor(Math.random() * array.length);
		} else {
			// The data is not valid.  Return null.
			return null;
		}
	} else {
		// If it isn't selectionData, the index should be NumData
		indexData = indexData.asNum();
		if (!indexData.isValid) {
			// The data is not valid.  Return null.
			return null;
		}
		// Clamps the index to the bounds of the array
		return indexData.getValueInR(min, max, true, true) - 1;
	}
};

/**
 * @inheritDoc
 * @param {Document} xmlDoc
 * @return {Node}
 */
ListData.prototype.createXml = function(xmlDoc) {
	const data = XmlWriter.createElement(xmlDoc, "data");
	XmlWriter.setAttribute(data, "type", this.getDataTypeName());
	XmlWriter.setAttribute(data, "isValid", this.isValid);

	// The value is a list of Data objects
	const value = xmlDoc.createElement("value");
	for (let i = 0; i < this.value.length; i++) {
		value.appendChild(this.value[i].createXml(xmlDoc));
	}
	data.appendChild(value);
	return data;
};

/**
 * Creates a ListData from XML
 * @param {Node} dataNode
 * @return {ListData}
 */
ListData.importXml = function(dataNode) {
	const valueNode = XmlWriter.findSubElement(dataNode, "value");
	const dataNodes = XmlWriter.findSubElements(valueNode, "data");
	const valueArray = [];
	for (let i = 0; i < dataNodes.length; i++) {
		// Add every valid data node
		const dataEntry = Data.importXml(dataNodes[i]);
		if (dataEntry != null) {
			valueArray.push(dataEntry);
		}
	}
	return new ListData(valueArray);
};
/**
 * Effectively the "enum" datatype.  Used for selections from DropSlots.  Has both displayText (what the user sees
 * the option listed as) and a value (used internally) that could be anything (number, string).  Selecting a Variable
 * or List from a DropSlot results in SelectionData with a value that's a reference to a Variable or List.  However,
 * when SelectionData is written to XML, the value is first turned into a string.  The Block using the SelectionData
 * reconstructs the correct value from the string.
 *
 * SelectionData uses "" as the value for "Empty SelectionData" (essentially null) when nothing it selected.
 *
 * @param {string} displayText - The text shown to the user on the DropSlot with this data
 * @param {*} value - Used internally, type depends on context
 * @param {boolean} [isValid=true]
 * @constructor
 */
function SelectionData(displayText, value, isValid) {
	// Only the empty SelectionData can have "" as the value.  So value === "" implies displayText === ""
	DebugOptions.assert(value !== "" || displayText === "");

	DebugOptions.validateNonNull(displayText, value);
	Data.call(this, Data.types.selection, value, isValid);
	this.displayText = displayText;
}
SelectionData.prototype = Object.create(Data.prototype);
SelectionData.prototype.constructor = SelectionData;

/**
 * When converted to a string, the display text is used
 * @return {StringData}
 */
SelectionData.prototype.asString = function() {
	return new StringData(this.displayText, true);
};

/**
 * @return {SelectionData}
 */
SelectionData.prototype.asSelection = function() {
	return this;
};

/**
 * Returns whether this SelectionData is the empty (null) SelectionData.
 * @return {boolean}
 */
SelectionData.prototype.isEmpty = function() {
	return this.value === "";
};

/**
 * Generates SelectionData from XML.  When imported, displayText = "" and value is a string.  All DropSlots/RoundSlots
 * sanitize the data and reconstruct the original displayText and value.  This prevents the user from editing their
 * save file to put arbitrary, invalid displayText in the SelectionData.  It also allows us to change the displayed
 * text of an option without breaking save files
 * @param {Node} dataNode
 * @return {SelectionData|null}
 */
SelectionData.importXml = function(dataNode) {
	const value = XmlWriter.getTextNode(dataNode, "value");
	if (value == null) return null;
	return new SelectionData("", value);
};

/**
 * Returns new empty SelectionData
 * TODO: perhaps remove isValid parameter
 * @param {boolean} [isValid=true]
 * @return {SelectionData}
 */
SelectionData.empty = function(isValid) {
	return new SelectionData("", "", isValid);
};
/**
 * An abstract class for executing Blocks/Stacks/Slots/BlockSlots to convey their execution status.
 * @constructor
 */
function ExecutionStatus() {
	DebugOptions.markAbstract();
}

/**
 * Is the block/stack/slot currently running?
 * @return {boolean}
 */
ExecutionStatus.prototype.isRunning = function() {
	return false;
};

/**
 * Has the block/stack/slot encountered an error?
 * @return {boolean}
 */

ExecutionStatus.prototype.hasError = function() {
	return false;
};

/**
 * What is the result of execution.
 * @return {Data}
 */
ExecutionStatus.prototype.getResult = function() {
	return null;
};
/**
 * Execution status of a completed block that returns a value
 * @param {Data} result - The data from execution
 * @constructor
 */
function ExecutionStatusResult(result) {
	this.result = result;
}
ExecutionStatusResult.prototype = Object.create(ExecutionStatus.prototype);
ExecutionStatusResult.constructor = ExecutionStatusResult;

/**
 * @inheritDoc
 * @return {Data}
 */
ExecutionStatusResult.prototype.getResult = function() {
	return this.result;
};
/**
 * Execution status of a block with an error
 * @constructor
 */
function ExecutionStatusError() {

}
ExecutionStatusError.prototype = Object.create(ExecutionStatus.prototype);
ExecutionStatusError.constructor = ExecutionStatusError;

/**
 * @inheritDoc
 * @return {boolean}
 */
ExecutionStatusError.prototype.hasError = function() {
	return true;
};
/**
 * Execution status of a block that is done but does not return a value
 * @constructor
 */
function ExecutionStatusDone() {

}
ExecutionStatusDone.prototype = Object.create(ExecutionStatus.prototype);
ExecutionStatusDone.constructor = ExecutionStatusDone;
/**
 * Execution status of a running block
 * @constructor
 */
function ExecutionStatusRunning() {

}
ExecutionStatusRunning.prototype = Object.create(ExecutionStatus.prototype);
ExecutionStatusRunning.constructor = ExecutionStatus;

/**
 * @inheritDoc
 * @return {boolean}
 */
ExecutionStatusRunning.prototype.isRunning = function() {
	return true;
};
/**
 * Represents a timer that fires a function regularly.  The timer doesn't start until start() is called.
 * @param {number} interval - Time between tics in milliseconds
 * @param {function} callbackFn - The function to call each tick
 * @constructor
 */
function Timer(interval, callbackFn){
	this.interval = interval;
	this.callbackFn = callbackFn;
	this.updateTimer = null;
}

/**
 * Starts the timer
 */
Timer.prototype.start = function(){
	if(this.updateTimer == null) {
		this.updateTimer = self.setInterval(this.tick.bind(this), this.interval);
	}
};

/**
 * Stops the timer
 */
Timer.prototype.stop = function(){
	if(this.updateTimer != null){
		this.updateTimer = window.clearInterval(this.updateTimer);
		this.updateTimer = null;
	}
};

/**
 * Called each tick
 */
Timer.prototype.tick = function(){
	if(this.callbackFn != null) this.callbackFn();
};

/**
 * Returns whether the timer is running
 * @return {boolean}
 */
Timer.prototype.isRunning = function(){
	return this.updateTimer != null;
};
/**
 * Represents a user-created Variable that is part of the current project.  A variable can hold NumData, StringData,
 * and BoolData, but not ListData or SelectionData.
 * @param {string} name - The name of the variable
 * @param {Data} [data] - The initial data in the variable
 * @constructor
 */
function Variable(name, data) {
	this.name = name;
	this.data = data;
	if (this.data == null) {
		this.data = new NumData(0);
	}
	CodeManager.addVariable(this);
}

/**
 * Gets the name of the Variable
 * @return {string}
 */
Variable.prototype.getName = function() {
	return this.name;
};

/**
 * Returns SelectionData for the Variable to be selected from a DropSlot
 * @return {SelectionData}
 */
Variable.prototype.getSelectionData = function() {
	return new SelectionData(this.name, this);
};

/**
 * Gets the data stored in the Variable
 * @return {Data}
 */
Variable.prototype.getData = function() {
	return this.data;
};

/**
 * Sets the data in the Variable
 * @param data
 */
Variable.prototype.setData = function(data) {
	this.data = data;
};

/**
 * Removes the Variable from the CodeManager
 */
Variable.prototype.remove = function() {
	this.data = null;
	CodeManager.removeVariable(this);
};

/**
 * Exports information about the Variable to XML
 * @param {Document} xmlDoc - The document to write to
 * @return {Node} - The node for the Variable
 */
Variable.prototype.createXml = function(xmlDoc) {
	const variable = XmlWriter.createElement(xmlDoc, "variable");
	XmlWriter.setAttribute(variable, "name", this.name);
	variable.appendChild(this.data.createXml(xmlDoc));
	return variable;
};

/**
 * Creates a Variable from XML
 * @param {Node} variableNode
 * @return {Variable|null}
 */
Variable.importXml = function(variableNode) {
	const name = XmlWriter.getAttribute(variableNode, "name");
	if (name != null) {
		const dataNode = XmlWriter.findSubElement(variableNode, "data");
		let data = new NumData(0);
		if (dataNode != null) {
			const newData = Data.importXml(dataNode);
			if (newData != null) {
				data = newData;
			}
		}
		return new Variable(name, data);
	}
	return null
};

/**
 * Prompts the user to rename the variable
 */
Variable.prototype.rename = function() {
	const callbackFn = function(cancelled, response) {
		if (!cancelled && CodeManager.checkVarName(response)) {
			callbackFn.variable.name = response;
			CodeManager.renameVariable(callbackFn.variable);
		}
	};
	callbackFn.variable = this;
	DialogManager.showPromptDialog("Rename variable", "Enter variable name", this.name, true, callbackFn);
};

/**
 * Prompts the user to delete the Variable
 */
Variable.prototype.delete = function() {
	if (CodeManager.checkVariableUsed(this)) {
		const callbackFn = function(response) {
			if (response === "2") {
				callbackFn.variable.remove();
				CodeManager.deleteVariable(callbackFn.variable);
			}
		};
		callbackFn.variable = this;
		let question = "Are you sure you would like to delete the variable \"" + this.name + "\"? ";
		question += "This will delete all copies of this block.";
		DialogManager.showChoiceDialog("Delete variable", question, "Don't delete", "Delete", true, callbackFn);
	} else {
		this.remove();
		CodeManager.deleteVariable(this);
	}
};
/**
 * Represents a user-created List that is part of the current project.  A list holds ListData, which in turn contains
 * an array.  Lists can be edited, while the ListData they pass should not be butated while another object is using it.
 * Two Lists can't point to the same ListData, so there should never be aliasing.
 * @param {string} name - The name of the list.  Must be unique among Lists
 * @param {ListData} data - The data to initialize this list with
 * @constructor
 */
function List(name, data) {
	this.name = name;
	if (data != null) {
		this.data = data;
	} else {
		this.data = new ListData();
	}
	CodeManager.addList(this);
}

/**
 * Retrieves the name of the list
 * @return {string}
 */
List.prototype.getName = function() {
	return this.name;
};

/**
 * Creates SelectionData for choosing the List from a DropSlot
 * @return {SelectionData}
 */
List.prototype.getSelectionData = function() {
	return new SelectionData(this.name, this);
};

/**
 * Retrieves the ListData from the List
 * @return {ListData}
 */
List.prototype.getData = function() {
	return this.data;
};

/**
 * Sets the List's ListData
 * @param {ListData} data
 */
List.prototype.setData = function(data) {
	this.data = data;
};

/**
 * Removes the list from the CodeManager, effectively deleting it
 */
List.prototype.remove = function() {
	this.data = null;
	CodeManager.removeList(this);
};

/**
 * Saves information about the List to XML
 * @param {Document} xmlDoc - The document to write to
 * @return {Node} - The XML Node for the List
 */
List.prototype.createXml = function(xmlDoc) {
	const list = XmlWriter.createElement(xmlDoc, "list");
	XmlWriter.setAttribute(list, "name", this.name);
	list.appendChild(this.data.createXml(xmlDoc));
	return list;
};

/**
 * Creates a List from XML
 * @param {Element} listNode - The XML Node with information about the List
 * @return {List}
 */
List.importXml = function(listNode) {
	const name = XmlWriter.getAttribute(listNode, "name");
	if (name != null) {
		const dataNode = XmlWriter.findSubElement(listNode, "data");
		let data = new ListData();
		if (dataNode != null) {
			const newData = Data.importXml(dataNode);
			if (newData != null) {
				data = newData;
			}
		}
		return new List(name, data);
	}
};

/**
 * Prompts the user to rename the list
 */
List.prototype.rename = function() {
	const callbackFn = function(cancelled, response) {
		if (!cancelled && CodeManager.checkListName(response)) {
			this.name = response;
			CodeManager.renameList(this);
		}
	}.bind(this);
	DialogManager.showPromptDialog("Rename list", "Enter list name", this.name, true, callbackFn);
};

/**
 * Prompts the user to delete the list, or just deletes it if it is never used
 */
List.prototype.delete = function() {
	if (CodeManager.checkListUsed(this)) {
		const callbackFn = function(response) {
			if (response === "2") {
				this.remove();
				CodeManager.deleteList(this);
			}
		}.bind(this);
		callbackFn.list = this;
		let question = "Are you sure you would like to delete the list \"" + this.name + "\"? ";
		question += "This will delete all copies of this block.";
		DialogManager.showChoiceDialog("Delete list", question, "Don't delete", "Delete", true, callbackFn);
	} else {
		this.remove();
		CodeManager.deleteList(this);
	}
};
/**
 * Device is an abstract class.  Each subclass (DeviceHummingbird, DeviceFlutter) represents a specific type of
 * robot.  Instances of the Device class have functions to to issue Bluetooth commands for connecting, disconnecting,
 * and reading/writing inputs/outputs.  The name field is what is shown to the user while the id field is used when
 * communicating with the backend.  Frequently, functions/constructors accept subclasses rather than instances of the
 * device class when they need information about a specific type of robot.  Each device subclass has its own
 * DeviceManager instance which manages connections to that type of robot
 *
 * @param {string} name - The display name of the device
 * @param {string} id - The string used to refer to the device when communicating with the backend
 * @param {string} RSSI - The strength of the bluetooth signal
 * @param {string} device - The type of device (Finch, Duo, etc.)
 * @constructor
 */
function Device(name, id, RSSI, device) {
	this.name = name;
	this.id = id;
	// Added this line
	this.RSSI = RSSI;
	this.device = device;

	/* Fields keep track of whether the device currently has a good connection with the backend and has up to date
	 * firmware.  In this context, a device might have "connected = false" but still be on the list of devices
	 * the user is trying to connect to, but with a red status light. */
	this.connected = false;
	/** @type {Device.firmwareStatuses} */
	this.firmwareStatus = Device.firmwareStatuses.upToDate;

	/* Field hold functions that are called each time the device's status or firmwareStatus changes.  DeviceStatusLights
	 * configure these fields so they can update when the status changes */
	this.statusListener = null;
	this.firmwareStatusListener = null;
}

Device.setStatics = function() {
	/** @enum {string} */
	Device.firmwareStatuses = {
		upToDate: "upToDate",
		old: "old",
		incompatible: "incompatible"
	};
};
Device.setStatics();

/**
 * Each concrete subclass of the Device class must call this function on itself to add a set of static methods to
 * that class (since in JS they aren't inherited).  This function also creates a DeviceManager for the subclass,
 * which can be accessed through the getManager() function
 * @param deviceClass - Concrete subclass of Device
 * @param {string} typeId - The lowercase string used internally to refer to the type. Ex: "hummingbird"
 * @param {string} typeName - The capitalized string the user sees. Ex: "Hummingbird"
 * @param {string} shortTypeName - The abbreviated name for the type. Ex: "HB". USed where the typeName doesn't fit.
 */
Device.setDeviceTypeName = function(deviceClass, typeId, typeName, shortTypeName) {

	/**
	 * Retrieves the typeName from the deviceClass
	 * @param {boolean} shorten - Whether the shortTypeName should be returned
	 * @param {number} [maxChars] - The maximum number of characters before the short name is used, even if !shorten
	 * @return {string} - The name or short name of the deviceClass.
	 */
	deviceClass.getDeviceTypeName = function(shorten, maxChars) {
		if (shorten || (maxChars != null && typeName.length > maxChars)) {
			return shortTypeName;
		} else {
			return typeName;
		}
	};

	/**
	 * Returns the id of the deviceClass
	 * @return {string}
	 */
	deviceClass.getDeviceTypeId = function() {
		return typeId;
	};

	/**
	 * Returns a string to show the user when a block is run that tries to control a robot that is not connected
	 * @param {number} [errorCode] - The status code from the request to communicate with the robot
	 * @param {string} [errorResult] - The message returned from the backend
	 * @return {string}
	 */
	deviceClass.getNotConnectedMessage = function(errorCode, errorResult) {
		if (errorResult == null || true) {
			return typeName + " not connected";
		} else {
			return errorResult;
		}
	};

	const manager = new DeviceManager(deviceClass);
	/** @return {DeviceManager} */
	deviceClass.getManager = function() {
		return manager;
	};

	/**
	 * Gets the string to show at the top of the connection dialog when no devices have been found
	 * @return {string}
	 */
	deviceClass.getConnectionInstructions = function() {
		return "Scanning for devices...";
	};
};

/**
 * Calls getDeviceTypeName on the class of this instance
 * @param {boolean} shorten
 * @param {number} maxChars
 * @return {string}
 */
Device.prototype.getDeviceTypeName = function(shorten, maxChars) {
	return this.constructor.getDeviceTypeName(shorten, maxChars);
};

/**
 * Calls getDeviceTypeId on the class of this instance
 * @return {string}
 */
Device.prototype.getDeviceTypeId = function() {
	return this.constructor.getDeviceTypeId();
};

/**
 * Issues a request to disconnect from this robot, causing the backend to instantly remove the robot from the
 * list of robots it is trying to connect to.
 */
Device.prototype.disconnect = function() {
	const request = new HttpRequestBuilder("robot/disconnect");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	HtmlServer.sendRequestWithCallback(request.toString());
};

/**
 * Issues a request to connect to this robot, causing the backend to instantly add the robot to the
 * list of robots it is trying to connect to.
 */
Device.prototype.connect = function() {
	const request = new HttpRequestBuilder("robot/connect");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	HtmlServer.sendRequestWithCallback(request.toString());
};

/**
 * Marks the robot as being in good/poor communication with the backend.  This function is called by the backend
 * through the CallbackManager whenever the communication status with a device changes.  Note it is independent of
 * whether the device is on the list of devices the backend is trying to connect to, as determined by the
 * connect and disconnect functions above.
 * @param {boolean} isConnected - Whether the robot is currently in good communication with the backend
 */
Device.prototype.setConnected = function(isConnected) {
	this.connected = isConnected;
	if (this.statusListener != null) this.statusListener(this.getStatus());
	DeviceManager.updateStatus();
};

/**
 * @return {boolean}
 */
Device.prototype.getConnected = function() {
	return this.connected;
}

/**
 * Marks the status of the robot's firmware.  Called by the backend through the CallbackManager.
 * Updates status lights and UI
 * @param {Device.firmwareStatuses} status
 */
Device.prototype.setFirmwareStatus = function(status) {
	this.firmwareStatus = status;
	if (this.statusListener != null) this.statusListener(this.getStatus());
	if (this.firmwareStatusListener != null) this.firmwareStatusListener(this.getFirmwareStatus());

	// Update the status of the total status light and DeviceManagers
	DeviceManager.updateStatus();
};

/**
 * Combines information from this.firmwareStatus and this.connected to determine the overall "status" of this robot,
 * used by the DeviceManager when computing its status
 * @return {DeviceManager.statuses}
 */
Device.prototype.getStatus = function() {
	const statuses = DeviceManager.statuses;
	const firmwareStatuses = Device.firmwareStatuses;
	if (!this.connected) {
		return statuses.disconnected;
	} else {
		if (this.firmwareStatus === firmwareStatuses.incompatible) {
			return statuses.incompatibleFirmware;
		} else if (this.firmwareStatus === firmwareStatuses.old) {
			return statuses.oldFirmware;
		} else {
			return statuses.connected;
		}
	}
};

/**
 * Retrieves the firmware status of the robot
 * @return {Device.firmwareStatuses}
 */
Device.prototype.getFirmwareStatus = function() {
	return this.firmwareStatus;
};

/**
 * @param {function} callbackFn
 */
Device.prototype.setStatusListener = function(callbackFn) {
	this.statusListener = callbackFn;
};

/**
 * @param {function} callbackFn
 */
Device.prototype.setFirmwareStatusListener = function(callbackFn) {
	this.firmwareStatusListener = callbackFn;
};

/**
 * Sends a request to show a dialog with information about the specified robot's firmware.
 * The dialog is an alert dialog if the firmware is up to date.  Otherwise it is a two choice dialog
 * with choices "Close" and "Update Firmware".
 */
Device.prototype.showFirmwareInfo = function() {
	const request = new HttpRequestBuilder("robot/showInfo");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	HtmlServer.sendRequestWithCallback(request.toString());
};

/**
 * Alerts the user that the device has incompatible firmware and provides a link to update instructions
 * @param {string} oldFirmware
 * @param {string} minFirmware
 */
Device.prototype.notifyIncompatible = function(oldFirmware, minFirmware) {
	let msg = "The device \"" + this.name + "\" has old firmware and needs to be updated.";
	msg += "\nDevice firmware version: " + oldFirmware;
	msg += "\nRequired firmware version: " + minFirmware;
	DialogManager.showChoiceDialog("Firmware incompatible", msg, "Dismiss", "Update firmware", true, function (result) {
		if (result === "2") {
			const request = new HttpRequestBuilder("robot/showUpdateInstructions");
			request.addParam("type", this.getDeviceTypeId());
			HtmlServer.sendRequestWithCallback(request.toString());
		}
	}.bind(this));
};

/**
 * Constructs a Device instance from a JSON object with fields for name and id
 * @param deviceClass - Subclass of device, the type of device to construct
 * @param {object} json
 * @return {Device}
 */
Device.fromJson = function(deviceClass, json) {
	return new deviceClass(json.name, json.id, json.RSSI, json.device);
};

/**
 * Constructs an array of Devices from an array of JSON objects, each with fields for name and id
 * @param deviceClass - Subclass of device, the type of devices to construct
 * @param {Array} json - Array of JSON objects
 * @return {Array}
 */
Device.fromJsonArray = function(deviceClass, json) {
	let res = [];
	for (let i = 0; i < json.length; i++) {
		res.push(Device.fromJson(deviceClass, json[i]));
	}
	return res;
};

/**
 * Constructs an array of Devices from a string representing a JSON array
 * @param deviceClass - Subclass of device, the type of devices to construct
 * @param {string|null} deviceList - String representation of json array
 * @return {Array}
 */
Device.fromJsonArrayString = function(deviceClass, deviceList) {
	if (deviceList == null) return [];
	let json = [];
	try {
		json = JSON.parse(deviceList);
	} catch (e) {
		json = [];
	}
	return Device.fromJsonArray(deviceClass, json);
};

/**
 * Returns an array of concrete subclasses of Device, each representing a type of robot.
 * @return {Array}
 */
Device.getTypeList = function() {
	//return [DeviceHummingbird, DeviceFlutter, DeviceFinch];
	return [DeviceHummingbird, DeviceHummingbirdBit, DeviceMicroBit];
};

/**
 * Sends a request to the backend to turn off all motors, servos, LEDs, etc. on all robots
 */
Device.stopAll = function() {
	const request = new HttpRequestBuilder("robot/stopAll");
	HtmlServer.sendRequestWithCallback(request.toString());
};

/**
 * Represents a Device that has ports for its inputs and outputs.
 * @param {string} name
 * @param {string} id
 * @constructor
 */
function DeviceWithPorts(name, id, RSSI, device) {
	Device.call(this, name, id, RSSI, device);
}
DeviceWithPorts.prototype = Object.create(Device.prototype);
DeviceWithPorts.prototype.constructor = Device;

/**
 * Issues a request to read the sensor at the specified port.  Stored the result in the status object, so the
 * executing Block can access it
 * @param {object} status - An object provided by the caller to store the result in
 * @param {string} sensorType - Added as a parameter to the request so the backend knows how to read the sensor
 * @param {number} port - Added to the request to indicate the port.
 */
DeviceWithPorts.prototype.readSensor = function(status, sensorType, port) {
	const request = new HttpRequestBuilder("robot/in");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	request.addParam("port", port);
	request.addParam("sensor", sensorType);
	HtmlServer.sendRequest(request.toString(), status, true);
};

/**
 * Issues a request to assign the value of an output at the specified port.  Uses a status object to store the result.
 * @param {object} status - An object provided by the caller to track the progress of the request
 * @param {string} outputType - Added to the request so the backend knows how to assign the value
 * @param {number} port
 * @param {number} value - The value to assign
 * @param {string} valueKey - The key to use when adding the value as a parameter to the request
 */
DeviceWithPorts.prototype.setOutput = function(status, outputType, port, value, valueKey) {
	const request = new HttpRequestBuilder("robot/out/" + outputType);
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	request.addParam("port", port);
	request.addParam(valueKey, value);
	HtmlServer.sendRequest(request.toString(), status, true);
};

/**
 * Issues a request to set the TriLed at a certain port.
 * @param {object} status
 * @param {number} port
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 */
DeviceWithPorts.prototype.setTriLed = function(status, port, red, green, blue) {
	const request = new HttpRequestBuilder("robot/out/triled");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	request.addParam("port", port);
	request.addParam("red", red);
	request.addParam("green", green);
	request.addParam("blue", blue);
	HtmlServer.sendRequest(request.toString(), status, true);
};

/**
 * Issues a request to set the buzzer.  Uses a status object to store the result.
 * @param {object} status - An object provided by the caller to track the progress of the request
 * @param {number} note - The note number to play (0-127)
 * @param {number} beats - The duration of the note
 */
DeviceWithPorts.prototype.setBuzzer = function(status, note, duration) {
	const request = new HttpRequestBuilder("robot/out/buzzer");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	request.addParam("note", note);
	request.addParam("duration", duration);
	HtmlServer.sendRequest(request.toString(), status, true);
};

/**
 * Issues a request to set the led array.  Uses a status object to store the result.
 * @param {object} status - An object provided by the caller to track the progress of the request
 * @param {String} ledStatusString - the on/off status to set for each led in the array represented as a string of 0's and 1's
 */
DeviceWithPorts.prototype.setLedArray = function(status, ledStatusString) {
	const request = new HttpRequestBuilder("robot/out/ledArray");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	request.addParam("ledArrayStatus", ledStatusString);
	HtmlServer.sendRequest(request.toString(), status, true);
};


/**
 * Each Device subclass has a DeviceManager to manage connections with robots of that type.  The DeviceManager stores
 * all the connected devices in an array, which can be accessed through the getDevice function, which is how
 * robot Blocks get an instance of Device to send their request.  The DeviceManger is also used by the
 * ConnectMultipleDialog and the CallbackManger to lookup information.  THe DeviceManager notifies CodeManger when
 * the connected devices change, so Blocks on the canvas can update their appearance.
 *
 * @param deviceClass - subclass of Device
 * @constructor
 */
function DeviceManager(deviceClass) {
	this.deviceClass = deviceClass;
	this.connectedDevices = [];
	/** @type {DeviceManager.statuses} */
	this.connectionStatus = DeviceManager.statuses.noDevices;

	/* The number of devices listed in each DeviceDropSlot to select from.  Determined when updateSelectableDevices
	 * is called. */
	this.selectableDevices = 0;

	/* Whether a scan is currently running */
	this.scanning = false;

	/** @type {function|null} - A function to call when new devices are discovered */
	this.deviceDiscoverCallback = null;
	/** @type {function|null} - A function to call to determine if a new scan should be run when the scan stops
	 * Often checks if a dialog for that device type is currently open */
	this.renewDiscoverFn = null;
	/** @type {string|null} - A cache of the scan results, updated through callbacks from the backend */
	this.discoverCache = null;
}

DeviceManager.setStatics = function() {
	const DM = DeviceManager;

	/** @enum {number} */
	const statuses = DeviceManager.statuses = {
		// Ordered such that the total status is just Math.min of the individual statuses
		disconnected: 0,
		incompatibleFirmware: 1,
		oldFirmware: 2,
		connected: 3,
		noDevices: 4
	};

	/* Stores the overall status of Devices controlled by this DeviceManager combined */
	DM.totalStatus = statuses.noDevices;

	/* Stores a function that is called every time the totalStatus changes */
	DM.statusListener = null;
	
	/* The maximum number of devices that can be connected at one time */
	DM.maxDevices = 4;
};
DeviceManager.setStatics();

/**
 * Retrieves the number of devices in this.connectedDevices
 * @return {number}
 */
DeviceManager.prototype.getDeviceCount = function() {
	return this.connectedDevices.length;
};

/**
 * Gets a device from this.connectedDevices or returns null if the index is out of bounds
 * @param {number} index
 * @return {Device|null}
 */
DeviceManager.prototype.getDevice = function(index) {
	if (index >= this.getDeviceCount()) return null;
	return this.connectedDevices[index];
};

/**
 * Attempts to find the index of the robot with the specified id. Returns -1 if the robot is not found
 * @param {string} id
 * @return {number}
 */
DeviceManager.prototype.lookupRobotIndexById = function(id) {
	for (let i = 0; i < this.connectedDevices.length; i++) {
		if (this.connectedDevices[i].id === id) {
			return i;
		}
	}
	return -1;
};

/**
 * Called to replace a device as the current index with a different device. Issues a Bluetooth connection request
 * to the new device and a disconnection request to the old device.
 * TODO: make switching places of two connected devices easier
 * @param {number} index - Index of device to replace. Must be in bounds.
 * @param {Device} newDevice
 */
DeviceManager.prototype.setDevice = function(index, newDevice) {
	DebugOptions.assert(index < this.getDeviceCount());
	this.connectedDevices[index].disconnect();
	newDevice.connect();
	this.connectedDevices[index] = newDevice;
	this.devicesChanged();
};

/**
 * Issues a disconnect request to the device at the index and removes it from the list
 * @param {number} index
 */
DeviceManager.prototype.removeDevice = function(index) {
	DebugOptions.assert(index < this.getDeviceCount());
	this.connectedDevices[index].disconnect();
	this.connectedDevices.splice(index, 1);
	this.devicesChanged();
};

/**
 * Issues a connect request to the Device and add it to the end of the list
 * @param {Device} newDevice
 */
DeviceManager.prototype.appendDevice = function(newDevice) {
	newDevice.connect();
	this.connectedDevices.push(newDevice);
	this.devicesChanged();
};

/**
 * Disconnects all devices and connects to the newDevice, making it the only Device on the list
 * @param {Device} newDevice
 */
DeviceManager.prototype.setOneDevice = function(newDevice) {
	for (let i = 0; i < this.connectedDevices.length; i++) {
		this.connectedDevices[i].disconnect();
	}
	newDevice.connect();
	this.connectedDevices = [newDevice];
	this.devicesChanged();
};

/**
 * Swaps the the devices at the specified indices of the connectedDevices list. Requires that both devices are already
 * connected.
 * @param {number} index1
 * @param {number} index2
 */
DeviceManager.prototype.swapDevices = function(index1, index2) {
	const device1 = this.connectedDevices[index1];
	const device2 = this.connectedDevices[index2];
	this.connectedDevices[index1] = device2;
	this.connectedDevices[index2] = device1;
	this.devicesChanged();
};

/**
 * If newDevice is not already connected, connects to it and replaces the device at the specified index
 * If the newDevice is already connected, swaps the positions of it and the device at the specified index
 * @param index
 * @param newDevice
 */
DeviceManager.prototype.setOrSwapDevice = function(index, newDevice) {
	const newIndex = this.lookupRobotIndexById(newDevice.id);
	if (newIndex > -1) {
		this.swapDevices(index, newIndex);
	} else {
		this.setDevice(index, newDevice);
	}
};

/**
 * Disconnects from all the devices, making the list empty
 */
DeviceManager.prototype.removeAllDevices = function() {
	this.connectedDevices.forEach(function(device) {
		device.disconnect();
	});
	this.connectedDevices = [];
	this.devicesChanged();
};

/**
 * Determines whether the device at the specified exists and is in good communication with the backend
 * @param {number} index
 * @return {boolean} - true iff the index is valid and the device has usable firmware and is connected
 */
DeviceManager.prototype.deviceIsConnected = function(index) {
	if (index >= this.getDeviceCount()) {
		return false;
	} else {
		const deviceStatus = this.connectedDevices[index].getStatus();
		const statuses = DeviceManager.statuses;
		return deviceStatus === statuses.connected || deviceStatus === statuses.oldFirmware;
	}
};

/**
 * Counts the number of devices that should be able to be selected from a DeviceDropSlot and updates the UI to reflect
 * this.  Also collapses/expands parts of the Palette accordingly.  The number of selectable devices is the Math.max
 * of the number of devices currently in use (the maximum selected robot on any existing DeviceDropSlot) and
 * the number of devices currently connected.  This ensures the user can access all the devices currently connected
 * as well as modify existing programs that may use more devices than the currently connected number.
 */
DeviceManager.prototype.updateSelectableDevices = function() {
	const oldCount = this.selectableDevices;
	const inUse = CodeManager.countDevicesInUse(this.deviceClass);
	const numConnected = this.getDeviceCount();
	const newCount = Math.max(numConnected, inUse);
	this.selectableDevices = newCount;

	if (newCount <= 1 && oldCount > 1) {
		CodeManager.hideDeviceDropDowns(this.deviceClass);
	} else if (newCount > 1 && oldCount <= 1) {
		CodeManager.showDeviceDropDowns(this.deviceClass);
	}

	// Sections of the palette are expanded if the count > 0
	const suggestedCollapse = newCount === 0;
	BlockPalette.setSuggestedCollapse(this.deviceClass.getDeviceTypeId(), suggestedCollapse);
};

/**
 * Retrieves the number of devices that should be listed in each DeviceDropSlot
 * @return {number}
 */
DeviceManager.prototype.getSelectableDeviceCount = function() {
	return this.selectableDevices;
};

/**
 * Called from other DeviceManager functions to alert the UI that the connected devices have changed
 */
DeviceManager.prototype.devicesChanged = function() {
	ConnectMultipleDialog.reloadDialog();
	this.updateSelectableDevices();
	DeviceManager.updateStatus();
	CodeManager.updateConnectionStatus();
};

/**
 * Start scanning if not scanning already
 * @param {function} [renewDiscoverFn] - type () -> boolean, called to determine if a scan should be restarted.
 */
DeviceManager.prototype.startDiscover = function(renewDiscoverFn) {
	this.renewDiscoverFn = renewDiscoverFn;
	if(!this.scanning) {
		this.scanning = true;
		this.discoverCache = null;

		let request = new HttpRequestBuilder("robot/startDiscover");
		request.addParam("type", this.deviceClass.getDeviceTypeId());
		HtmlServer.sendRequestWithCallback(request.toString());
	}
};

/**
 * Adds a function to the DeviceManager which is called with a list of devices whenever devices are discovered
 * @param {function} callbackFn - type: string -> (), function provided by UI part
 */
DeviceManager.prototype.registerDiscoverCallback = function(callbackFn) {
	this.deviceDiscoverCallback = callbackFn;
};

/**
 * Retrieves the list of devices that was discovered during the current scan, or null if no scan results are available
 * used for the ConnectMultipleDialog when the used opens a RobotConnectionList
 * @return {null|string} - A JSON Array as a string or null
 */
DeviceManager.prototype.getDiscoverCache = function() {
	return this.discoverCache;
};

/**
 * Checks if a connection dialog is open by calling the renewDiscoverFn and starts a new scan if it is.
 * Clears all data from the previous scan
 * @param {string} robotTypeId - id of the affected DeviceManager
 */
DeviceManager.prototype.possiblyRescan = function(robotTypeId) {
	if (robotTypeId === this.deviceClass.getDeviceTypeId()) {
		if (this.renewDiscoverFn != null && this.renewDiscoverFn()) {
			this.scanning = false;
			this.discoverCache = null;
			this.startDiscover(this.renewDiscoverFn);
		} else {
			this.markStoppedDiscover();
		}
	}
};

/**
 * Retrieves an array of Devices
 * @param robotListString
 * @param includeConnected
 * @param excludeIndex
 * @return {Array}
 */
DeviceManager.prototype.fromJsonArrayString = function(robotListString, includeConnected, excludeIndex) {
	// Get the devices from the request
	let robotList = Device.fromJsonArrayString(this.deviceClass, robotListString);
	// Accumulate devices that are not currently connected
	let disconnectedRobotsList = [];
	robotList.forEach(function(robot) {
		// Try to find the device
		let connectedRobotIndex = this.lookupRobotIndexById(robot.id);
		// Only include the device if we didn't find it and it isn't the excludeId robot
		if (connectedRobotIndex === -1) {
			// Include the device in the list
			disconnectedRobotsList.push(robot);
		}
	}.bind(this));

	// If we're including connected devices, add them at the top
	let newList = disconnectedRobotsList;
	if (includeConnected) {
		newList = this.connectedDevices.concat(robotList);
		if (excludeIndex != null) {
			newList.splice(excludeIndex, 1);
		}
	}
	if (DebugOptions.shouldAllowVirtualDevices()) {
		newList = newList.concat(this.createVirtualDeviceList());
	}
	return newList;
};

DeviceManager.prototype.backendDiscovered = function(robotTypeId, robotList) {
	if (robotTypeId === this.deviceClass.getDeviceTypeId()) {
		this.discoverCache = robotList;
		if (this.deviceDiscoverCallback != null) this.deviceDiscoverCallback(robotList);
	}
};

/**
 * Issues a request to tell the backend to stop scanning for devices. Called when a discover dialog is closed
 * TODO: change backend to this doesn't need to be called when switching between Flutter/Hummingbird tabs
 * @param {function} [callbackFn]
 * @param {function} [callbackErr]
 */
DeviceManager.prototype.stopDiscover = function(callbackFn, callbackErr) {
	let request = new HttpRequestBuilder("robot/stopDiscover");
	HtmlServer.sendRequestWithCallback(request.toString(), callbackFn, callbackErr);
	this.markStoppedDiscover();
};

/**
 * Clears the cache and other fields to reflect that a scan is no longer running
 */
DeviceManager.prototype.markStoppedDiscover = function() {
	this.deviceDiscoverCallback = null;
	this.discoverCache = null;
	this.renewDiscoverFn = null;
	this.scanning = false;
};

/**
 * Returns a list of 20 - 40 virtual robots.  Virtual robots are used for debugging.
 * @return {Array<Device>}
 */
DeviceManager.prototype.createVirtualDeviceList = function() {
	let list = [];
	let rand = Math.random() * 20 + 20;
	for (let i = 0; i < rand; i++) {
		list.push(DebugOptions.createVirtualDevice(this.deviceClass, i + ""));
	}
	return list;
};

/**
 * Looks for the specified device and sets whether it is connected (if found).
 * If the device has lost connection, a scan is started to find it.
 * @param {string} deviceId
 * @param {boolean} isConnected - Whether the robot is currently in good communication with the backend
 */
DeviceManager.prototype.updateConnectionStatus = function(deviceId, isConnected) {
	const index = this.lookupRobotIndexById(deviceId);
	let robot = null;
	if (index >= 0) {
		robot = this.connectedDevices[index];
	}
	if (robot != null) {
		const wasConnected = robot.getConnected();
		robot.setConnected(isConnected);
		if (wasConnected && !isConnected && !this.scanning) {
			this.startDiscover();
		}
	}
};

/**
 * Looks for the specified device and sets its firmware status (if found)
 * @param {string} deviceId
 * @param {Device.firmwareStatuses} status
 */
DeviceManager.prototype.updateFirmwareStatus = function(deviceId, status) {
	const index = this.lookupRobotIndexById(deviceId);
	let robot = null;
	if (index >= 0) {
		robot = this.connectedDevices[index];
	}
	if (robot != null) {
		robot.setFirmwareStatus(status);
	}
};

DeviceManager.prototype.disconnectIncompatible = function(robotId, oldFirmware, minFirmware) {
	const index = this.lookupRobotIndexById(robotId);
	if (index >= 0) {
		const robot = this.connectedDevices[index];
		this.connectedDevices.splice(index, 1);
		this.devicesChanged();
		robot.notifyIncompatible(oldFirmware, minFirmware);
	}
};

/**
 * Computes, stores, and returns this DeviceManager's connectionStatus
 * @return {DeviceManager.statuses}
 */
DeviceManager.prototype.getStatus = function() {
	const statuses = DeviceManager.statuses;
	let status = statuses.noDevices;
	this.connectedDevices.forEach(function(device) {
		status = Math.min(status, device.getStatus());
	});
	this.connectionStatus = status;
	return this.connectionStatus;
};

/**
 * Allows for easy iteration of DeviceManagers by calling callbackFn on every Device subclass's manager
 * @param {function} callbackFn - type DeviceManager -> (), to be called on every DeviceManager
 */
DeviceManager.forEach = function(callbackFn) {
	Device.getTypeList().forEach(function(deviceType) {
		callbackFn(deviceType.getManager());
	});
};

/**
 * Tells all managers to update their selectable devices
 */
DeviceManager.updateSelectableDevices = function() {
	DeviceManager.forEach(function(manager) {
		manager.updateSelectableDevices();
	});
};

/**
 * Finds the robot with the given deviceId and sets its connected status, then updates the UI to reflect any changes
 * @param {string} deviceId
 * @param {boolean} isConnected - Whether the robot is in good communication with the backend
 */
DeviceManager.updateConnectionStatus = function(deviceId, isConnected) {
	DeviceManager.forEach(function(manager) {
		manager.updateConnectionStatus(deviceId, isConnected);
	});
	CodeManager.updateConnectionStatus();
};

/**
 * Finds the robot with the given deviceId and sets its firmware status, then updates the UI to reflect any changes
 * @param {string} deviceId
 * @param {Device.firmwareStatuses} status
 */
DeviceManager.updateFirmwareStatus = function(deviceId, status) {
	DeviceManager.forEach(function(manager) {
		manager.updateFirmwareStatus(deviceId, status);
	});
	CodeManager.updateConnectionStatus();
};

/**
 * Computes the total status of all DeviceManagers and updates the statusListener
 */
DeviceManager.updateStatus = function() {
	const DM = DeviceManager;
	let totalStatus = DM.getStatus();
	if (DM.statusListener != null) DM.statusListener(totalStatus);
	return totalStatus;
};

/**
 * Computes the total status of all DeviceManagers and returns the result
 * @return {DeviceManager.statuses}
 */
DeviceManager.getStatus = function() {
	let DM = DeviceManager;
	let minStatus = DM.statuses.noDevices;
	DM.forEach(function(manager) {
		minStatus = DM.minStatus(manager.getStatus(), minStatus);
	});
	DM.totalStatus = minStatus;
	return minStatus;
};

/**
 * Given two statuses, combines them into one status
 * @param {DeviceManager.statuses} status1
 * @param {DeviceManager.statuses} status2
 * @return {DeviceManager.statuses}
 */
DeviceManager.minStatus = function(status1, status2) {
	/* The values in DeviceManager.statuses have been ordered such that they can be combined with Math.min */
	return Math.min(status1, status2);
};

/**
 * Assigns the statusListener that listens for changes in total status.  Used for the total status light
 * @param {function} callbackFn - Called with the new status whenever the status changes
 */
DeviceManager.setStatusListener = function(callbackFn) {
	DeviceManager.statusListener = callbackFn;
};

/**
 * Notifies all DeviceManagers that robots have been discovered
 * @param {string} robotTypeId - The ID of the type of robot being scanned for
 * @param {string} robotList - A JSON Array as a string representing the discovered devices
 */
DeviceManager.backendDiscovered = function(robotTypeId, robotList) {
	DeviceManager.forEach(function(manager) {
		manager.backendDiscovered(robotTypeId, robotList);
	});
};

/**
 * Notifies all DeviceManagers that the specified device is incompatible and should be removed.
 * @param {string} robotId - The id of the robot to disconnect
 * @param {string} oldFirmware - The firmware on the robot
 * @param {string} minFirmware - The minimum firmware required to be compatible
 */
DeviceManager.disconnectIncompatible = function(robotId, oldFirmware, minFirmware) {
	DeviceManager.forEach(function(manager) {
		manager.disconnectIncompatible(robotId, oldFirmware, minFirmware);
	});
};

/**
 * Notifies all DeviceManagers that a scan has just ended, so they can possibly start a new scan
 * @param {string} robotTypeId - The ID of the type of robot that was being scanned for
 */
DeviceManager.possiblyRescan = function(robotTypeId) {
	DeviceManager.forEach(function(manager) {
		manager.possiblyRescan(robotTypeId);
	});
};
/**
 * Manages communication with a Hummingbird
 * @param {string} name
 * @param {string} id
 * @constructor
 */
function DeviceHummingbird(name, id, RSSI, device) {
	DeviceWithPorts.call(this, name, id, RSSI, device);
}
DeviceHummingbird.prototype = Object.create(DeviceWithPorts.prototype);
DeviceHummingbird.prototype.constructor = DeviceHummingbird;
Device.setDeviceTypeName(DeviceHummingbird, "hummingbird", "Hummingbird", "HB");
/**
 * Manages communication with a Hummingbird Bit
 * @param {string} name
 * @param {string} id
 * @constructor
 */
function DeviceHummingbirdBit(name, id, RSSI, device) {
	DeviceWithPorts.call(this, name, id, RSSI, device);
}
DeviceHummingbirdBit.prototype = Object.create(DeviceWithPorts.prototype);
DeviceHummingbirdBit.prototype.constructor = DeviceHummingbirdBit;
Device.setDeviceTypeName(DeviceHummingbirdBit, "hummingbirdbit", "HummingbirdBit", "BB");

/**
 * Manages communication with a Hummingbird
 * @param {string} name
 * @param {string} id
 * @constructor
 */
function DeviceMicroBit(name, id, RSSI, device) {
	DeviceWithPorts.call(this, name, id, RSSI, device);
}
DeviceMicroBit.prototype = Object.create(DeviceWithPorts.prototype);
DeviceMicroBit.prototype.constructor = DeviceMicroBit;
Device.setDeviceTypeName(DeviceMicroBit, "microbit", "MicroBit", "MB");

/**
 * Manages communication with a Flutter
 * @param {string} name
 * @param {string} id
 * @constructor
 */
function DeviceFlutter(name, id, RSSI, device) {
	DeviceWithPorts.call(this, name, id, RSSI, device);
}
DeviceFlutter.prototype = Object.create(DeviceWithPorts.prototype);
Device.setDeviceTypeName(DeviceFlutter, "flutter", "Flutter", "F");
DeviceFlutter.prototype.constructor = DeviceFlutter;

/**
 * Sends a request to set the value of the Buzzer
 * @param {object} status - An object provided by the caller to track the progress of the request
 * @param {number} volume - How loud the buzzer is
 * @param {number} frequency - The frequency of the sound the buzzer produces
 */
DeviceFlutter.prototype.setBuzzer = function(status, volume, frequency) {
	const request = new HttpRequestBuilder("robot/out/buzzer");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	request.addParam("volume", volume);
	request.addParam("frequency", frequency);
	HtmlServer.sendRequest(request.toString(), status, true);
};

/**
 * @inheritDoc
 * @return {string}
 */
DeviceFlutter.getConnectionInstructions = function() {
	return "Press the \"find me\" button on your Flutter";
};
/**
 * Manages communication with a Finch
 * @param {string} name
 * @param {string} id
 * @constructor
 */
function DeviceFinch(name, id, RSSI, device) {
	DeviceWithPorts.call(this, name, id, RSSI, device);
}
DeviceFinch.prototype = Object.create(DeviceWithPorts.prototype);
Device.setDeviceTypeName(DeviceFinch, "finch", "Finch", "Finch");
DeviceFinch.prototype.constructor = DeviceFinch;

DeviceFinch.prototype.setAll = function(status, data) {
	const request = new HttpRequestBuilder("robot/out/setAll");
	request.addParam("type", this.getDeviceTypeId());
	request.addParam("id", this.id);
	request.addParam("data", data);
	HtmlServer.sendRequest(request.toString(), status, true);
};
/**
 * Static class keeps track of which sensors are available on the device
 */
function TabletSensors(){
	const TS = TabletSensors;
	TabletSensors.clear();
	TabletSensors.requestAvailable();
}

/**
 * Requests backend for a list of available sensors
 */
TabletSensors.requestAvailable = function(){
	const request = new HttpRequestBuilder("tablet/availableSensors");
	HtmlServer.sendRequestWithCallback(request.toString(), function(response){
		TabletSensors.updateAvailable(response);
	});
};

/**
 * Updates sensors to match those on list
 * @param {string} sensorList - A newline separated list of available sensors
 */
TabletSensors.updateAvailable = function(sensorList){
	TabletSensors.clear();
	const sensors = TabletSensors.sensors;
	let list = sensorList.split("\n");
	if(sensorList === "") {
		list = [];
	}
	list.forEach(function(sensor){
		if(sensors[sensor] === false) {
			sensors[sensor] = true;
		}
	});
	CodeManager.updateAvailableSensors();
};

/**
 * Marks a sensor as available
 * @param {string} sensor
 * @return {boolean}
 */
TabletSensors.addSensor = function(sensor){
	const TS = TabletSensors;
	if(TS.sensors[sensor] != null) {
		TS.sensors[sensor] = true;
		CodeManager.updateAvailableSensors();
		return true;
	}
	return false;
};

/**
 * Marks a sensor as unavailable
 * @param {string} sensor
 * @return {boolean}
 */
TabletSensors.removeSensor = function(sensor){
	const TS = TabletSensors;
	if(TS.sensors[sensor] != null) {
		TS.sensors[sensor] = false;
		CodeManager.updateAvailableSensors();
		return true;
	}
	return false;
};

/**
 * Marks all sensors as unavailable.
 */
TabletSensors.clear = function(){
	const sensors = TabletSensors.sensors = {};
	sensors.accelerometer = false;
	sensors.barometer = false;
	sensors.microphone = false;
	sensors.gps = false;
};


/* GuiElements is a static class that builds the UI and initializes the other classes.
 * It contains functions to create and modify elements of the main SVG.
 * GuiElements is run once the browser has loaded all the js and html files.
 * It's one of the less organized classes and has quite a lot of functions in it.
 * TODO: Refactor GuiElements moving the parts that deal with getting device properties to a different class
 */
function GuiElements() {
	// Clear the debug span
	document.getElementById("debug").innerHTML = "";
	// Find parts of the html and store them
	let svg2 = document.getElementById("frontSvg");
	let svg1 = document.getElementById("middleSvg");
	let svg0 = document.getElementById("backSvg");
	GuiElements.svgs = [svg0, svg1, svg2];
	GuiElements.defs = document.getElementById("SvgDefs");
	GuiElements.loaded = false;
	// Load settings from backend
	GuiElements.loadInitialSettings(function() {
		// Build the UI
		GuiElements.setConstants();
		GuiElements.createLayers();
		GuiElements.dialogBlock = null;
		GuiElements.buildUI();
		HtmlServer.sendFinishedLoadingRequest();
		GuiElements.loaded = true;
	});
}

/* Runs GuiElements once all resources are loaded. */
document.addEventListener('DOMContentLoaded', function() {
	GuiElements.alert("Loading");
	(DebugOptions.safeFunc(GuiElements))();
}, false);

/* Redraws UI if screen dimensions change */
window.onresize = function() {
	if (GuiElements.loaded && !GuiElements.isIos) {
		GuiElements.updateDims();
	}
};

/** Sets constants relating to screen dimensions and the Operating System */
GuiElements.setGuiConstants = function() {
	GuiElements.minZoom = 0.25;
	GuiElements.maxZoom = 4;
	GuiElements.minZoomMult = 0.5;
	GuiElements.maxZoomMult = 2;
	GuiElements.zoomAmount = 0.1;
	GuiElements.defaultZoomMm = 246.38;
	GuiElements.defaultZoomPx = 1280;
	GuiElements.defaultZoomMultiple = 1;
	GuiElements.smallModeThreshold = 620;

	GuiElements.computedZoom = GuiElements.defaultZoomMultiple; //The computed default zoom amount for the device
	GuiElements.zoomMultiple = 1; //GuiElements.zoomFactor = zoomMultiple * computedZoom
	GuiElements.zoomFactor = GuiElements.defaultZoomMultiple;

	GuiElements.width = window.innerWidth / GuiElements.zoomFactor;
	GuiElements.height = window.innerHeight / GuiElements.zoomFactor;

	GuiElements.blockerOpacity = 0.5;

	GuiElements.isKindle = false;
	GuiElements.isIos = false;
	GuiElements.isAndroid = false;

	GuiElements.paletteLayersVisible = true;
	GuiElements.smallMode = false;
};
/**
 * Many classes have static functions which set constants such as font size, etc.
 * GuiElements.setConstants runs these functions in sequence, thereby initializing them.
 * Some classes rely on constants from each other, so the order they execute in is important.
 */
GuiElements.setConstants = function() {
	/* If a class is static and does not build a part of the UI,
	then its main function is used to initialize its constants. */
	VectorPaths();
	ImageLists();
	DialogManager();
	Sound.setConstants();
	BlockList();
	Colors();
	Button.setGraphics();
	CloseButton.setGraphics();
	//If the constants are only related to the way the UI looks, the method is called setGraphics().
	DeviceStatusLight.setConstants();
	TitleBar.setGraphicsPart1();
	BlockGraphics();
	HexSlotShape.setConstants();
	EditableSlotShape.setConstants();
	RectSlotShape.setConstants();
	RoundSlotShape.setConstants();
	DropSlotShape.setConstants();

	Slot.setConstants();
	EditableSlot.setConstants();


	Block.setConstants();
	BlockPalette.setGraphics();
	CollapsibleSet.setConstants();
	CollapsibleItem.setConstants();

	TitleBar.setGraphicsPart2();
	TabManager.setGraphics();
	CategoryBN.setGraphics();
	SmoothMenuBnList.setGraphics();
	Menu.setGraphics();
	DeviceMenu.setGraphics();
	TabletSensors();

	BubbleOverlay.setGraphics();
	ResultBubble.setConstants();
	BlockContextMenu.setGraphics();
	RecordingManager();
	RowDialog.setConstants();
	OpenDialog.setConstants();
	FileContextMenu.setGraphics();

	InputPad.setConstants();
	SoundInputPad.setConstants();
	InputWidget.NumPad.setConstants();
	InputWidget.Label.setConstants();

	ConnectMultipleDialog.setConstants();
	RobotConnectionList.setConstants();
	TabRow.setConstants();
	RecordingDialog.setConstants();
	DisplayBox.setGraphics();
	OverflowArrows.setConstants();
	CodeManager();
	SaveManager.setConstants();
	UndoManager();
};
/** Once each class has its constants set, the UI can be built. UI-related classes are called. */
GuiElements.buildUI = function() {
	document.body.style.backgroundColor = Colors.black; //Sets the background color of the webpage
	Colors.createGradients(); //Adds gradient definitions to the SVG for each block category
	Overlay.setStatics(); //Creates a list of open overlays
	TouchReceiver(); //Adds touch event handlers to the SVG
	BlockPalette(); //Creates the sidebar on the left with the categories and blocks
	TitleBar(); //Creates the title bar and the buttons contained within it.
	TabManager(); //Creates the tab-switching interface below the title bar
	DisplayBoxManager(); //Builds the display box for the display block to show messages in.
	/* Builds the SVG path element for the highlighter,
	the white ring which shows which slot a Block will connect to. */
	Highlighter();
	SaveManager();

	GuiElements.blockInteraction();
	OpenDialog.showDialog();
	DebugOptions.applyActions();
};
/**
 * Makes an layer object for each layer of the interface.
 * Layers are accessible in the form GuiElements.layers.[layerName]
 */
GuiElements.createLayers = function() {
	const create = GuiElements.create; //shorthand
	GuiElements.zoomGroups = [];
	GuiElements.svgs.forEach(function(svg) {
		let zoomGroup = create.group(0, 0, svg);
		GuiElements.zoomGroups.push(zoomGroup);
		GuiElements.update.zoom(zoomGroup, GuiElements.zoomFactor);
	});

	GuiElements.layers = {};
	let i = 0;
	const layers = GuiElements.layers;
	layers.temp = create.layer(i);
	layers.aTabBg = create.layer(i);
	layers.activeTab = create.layer(i);
	layers.TabsBg = create.layer(i);
	layers.paletteBG = create.layer(i);
	layers.paletteScroll = document.getElementById("paletteScrollDiv");
	i++;
	layers.trash = create.layer(i);
	layers.catBg = create.layer(i);
	layers.categories = create.layer(i);
	layers.titleBg = create.layer(i);
	layers.titlebar = create.layer(i);
	layers.overflowArr = create.layer(i);
	layers.stage = create.layer(i);
	layers.display = create.layer(i);
	layers.drag = create.layer(i);
	layers.highlight = create.layer(i);
	layers.resultBubble = create.layer(i);
	layers.inputPad = create.layer(i);
	layers.tabMenu = create.layer(i);
	layers.dialogBlock = create.layer(i);
	layers.dialog = create.layer(i);
	layers.overlay = create.layer(i);
	layers.frontScroll = document.getElementById("frontScrollDiv");
	i++;
	layers.overlayOverlay = create.layer(i);
	layers.overlayOverlayScroll = document.getElementById("overlayOverlayScrollDiv");
};

/**
 * Debugging function which displays information on the screen
 * @param {string} message
 */
GuiElements.alert = function(message) {
	if (!DebugOptions.shouldAllowLogging()) return;
	let result = message;
	debug.innerHTML = result;
};


/* GuiElements.create contains functions for creating SVG elements.
 * The element is built with minimal attributes and returned.
 * It may also be added to a group if included. */
GuiElements.create = {};
/**
 * Makes a group, adds it to a parent group (if present), and returns it.
 * @param {number} x - The x offset of the group.
 * @param {number} y - The y offset of the group.
 * @param {Element} [parent] - The parent group to add the group to.
 * @return {Element} - The group which was created.
 */
GuiElements.create.group = function(x, y, parent) {
	DebugOptions.validateOptionalNums(x, y);
	const group = document.createElementNS("http://www.w3.org/2000/svg", 'g'); //Make the group.
	group.setAttributeNS(null, "transform", "translate(" + x + "," + y + ")"); //Move the group to (x,y).
	if (parent != null) { //If provided, add it to the parent.
		parent.appendChild(group);
	}
	return group; //Return the group.
};
/**
 * Creates a layer object that can be treated much like a group but has show and hide functions. The layer actually
 * includes two groups, with the inner group added/removed from the outer group during show/hide, ensuring the order
 * of layers never changes.
 * @param {number} depth - The index of the zoomGroup to add to
 * @return {object} - A layer object
 */
GuiElements.create.layer = function(depth) {
	DebugOptions.validateNumbers(depth);
	let layerG = GuiElements.create.group(0, 0, GuiElements.zoomGroups[depth]);
	let showHideLayer = GuiElements.create.group(0, 0, layerG);
	let layer = {};
	// We forward these group-like functions to the inner group
	layer.appendChild = showHideLayer.appendChild.bind(showHideLayer);
	layer.setAttributeNS = showHideLayer.setAttributeNS.bind(showHideLayer);
	layer.hide = showHideLayer.remove.bind(showHideLayer);
	layer.show = function() {
		layerG.appendChild(showHideLayer);
	};
	return layer;
};
/**
 * Creates a linear SVG gradient and adds it to the SVG defs.
 * @param {string} id - The id of the gradient (needed to reference it later).
 * @param {string} color1 - color in form "#fff" of the top of the gradient.
 * @param {string} color2 - color in form "#fff" of the bottom of the gradient.
 */
GuiElements.create.gradient = function(id, color1, color2) { //Creates a gradient and adds to the defs
	DebugOptions.validateNonNull(color1, color2);
	const gradient = document.createElementNS("http://www.w3.org/2000/svg", 'linearGradient');
	gradient.setAttributeNS(null, "id", id); //Set attributes.
	gradient.setAttributeNS(null, "x1", "0%");
	gradient.setAttributeNS(null, "x2", "0%");
	gradient.setAttributeNS(null, "y1", "0%");
	gradient.setAttributeNS(null, "y2", "100%");
	GuiElements.defs.appendChild(gradient); //Add it to the SVG's defs
	const stop1 = document.createElementNS("http://www.w3.org/2000/svg", 'stop'); //Create stop 1.
	stop1.setAttributeNS(null, "offset", "0%");
	stop1.setAttributeNS(null, "style", "stop-color:" + color1 + ";stop-opacity:1");
	gradient.appendChild(stop1);
	const stop2 = document.createElementNS("http://www.w3.org/2000/svg", 'stop'); //Create stop 2.
	stop2.setAttributeNS(null, "offset", "100%");
	stop2.setAttributeNS(null, "style", "stop-color:" + color2 + ";stop-opacity:1");
	gradient.appendChild(stop2);
};
/**
 * Creates an SVG path element and returns it.
 * @param {Element} [group] - The parent group to add the element to.
 * @return {Element} - The path which was created.
 */
GuiElements.create.path = function(group) {
	const path = document.createElementNS("http://www.w3.org/2000/svg", 'path'); //Create the path.
	if (group != null) { //Add it to the parent group if present.
		group.appendChild(path);
	}
	return path; //Return the path.
};
/**
 * Creates an SVG text element and returns it.
 * @return {Element} - The text which was created.
 */
GuiElements.create.text = function() {
	return document.createElementNS("http://www.w3.org/2000/svg", 'text'); //Create text.
};
/**
 * Creates an SVG image element and returns it.
 * @return {Element} - The text which was created.
 */
GuiElements.create.image = function() {
	return document.createElementNS("http://www.w3.org/2000/svg", 'image');
};
/**
 * Creates an SVG tag and adds it to the group
 * @param {Element} [group]
 * @return {Element}
 */
GuiElements.create.svg = function(group) {
	const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
	svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
	if (group != null) {
		group.appendChild(svg);
	}
	return svg;
};
/**
 * Creates a div formatted to be scrollable and ads it to the group
 * @param {Element} group
 * @return {Element}
 */
GuiElements.create.scrollDiv = function(group) {
	const div = document.createElement("div");
	div.style.position = "absolute";
	if (group != null) {
		group.appendChild(div);
	}
	return div;
};
/**
 * Creates an SVG rect element, adds it to a parent group (if present), and returns it.
 * @param {Element} group - (optional) The parent group to add the group to.
 * @return {Element} - The rect which was created.
 */
GuiElements.create.rect = function(group) {
	const rect = document.createElementNS("http://www.w3.org/2000/svg", 'rect'); //Create the rect.
	if (group != null) { //Add it to the parent group if present.
		group.appendChild(rect);
	}
	return rect; //Return the rect.
};

/* GuiElements.draw contains functions that create SVG elements and assign their attributes
 * so they are ready to be drawn on the screen. The element is then returned.
 * It may also be added to a group if included. */
GuiElements.draw = {};
/**
 * Creates a filled SVG rect element at a certain location with specified dimensions and returns it.
 * @param {number} x - The rect's x coord.
 * @param {number} y - The rect's y coord.
 * @param {number} width - The rect's width.
 * @param {number} height - The rect's height.
 * @param {string} [color] - (optional) The rect's fill color in the form "#fff".
 * @return {Element} - The rect which was created.
 */
GuiElements.draw.rect = function(x, y, width, height, color) {
	DebugOptions.validateNumbers(x, y, width, height);
	const rect = document.createElementNS("http://www.w3.org/2000/svg", 'rect'); //Create the rect.
	rect.setAttributeNS(null, "x", x); //Set its attributes.
	rect.setAttributeNS(null, "y", y);
	rect.setAttributeNS(null, "width", width);
	rect.setAttributeNS(null, "height", height);
	if (color != null) {
		rect.setAttributeNS(null, "fill", color);
	}
	return rect; //Return the rect.
};
/**
 * Creates a filled, triangular SVG path element with specified dimensions and returns it.
 * @param {number} x - The path's x coord.
 * @param {number} y - The path's y coord.
 * @param {number} width - The path's width. (it is an isosceles triangle)
 * @param {number} height - The path's height. (negative will make it point down)
 * @param {string} color - The path's fill color in the form "#fff".
 * @return {Element} - The path which was created.
 */
GuiElements.draw.triangle = function(x, y, width, height, color) {
	DebugOptions.validateNonNull(color);
	DebugOptions.validateNumbers(x, y, width, height);
	const triangle = document.createElementNS("http://www.w3.org/2000/svg", 'path'); //Create the path.
	GuiElements.update.triangle(triangle, x, y, width, height); //Set its path description (points).
	triangle.setAttributeNS(null, "fill", color); //Set the fill.
	return triangle; //Return the finished triangle.
};
/**
 * Creates a triangle with its point at the indicated coords
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {string} color
 * @return {Element}
 */
GuiElements.draw.triangleFromPoint = function(x, y, width, height, color) {
	DebugOptions.validateNonNull(color);
	DebugOptions.validateNumbers(x, y, width, height);
	const triangle = document.createElementNS("http://www.w3.org/2000/svg", 'path'); //Create the path.
	GuiElements.update.triangleFromPoint(triangle, x, y, width, height); //Set its path description (points).
	triangle.setAttributeNS(null, "fill", color); //Set the fill.
	return triangle; //Return the finished triangle.
};
/**
 * Creates a filled, trapezoid-shaped SVG path element with specified dimensions and returns it.
 * @param {number} x - The path's x coord.
 * @param {number} y - The path's y coord.
 * @param {number} width - The path's width. (it is an isosceles trapezoid)
 * @param {number} height - The path's height. (negative will make it point down)
 * @param {number} slantW - The amount the trapezoid slopes in.
 * @param {string} color - The path's fill color in the form "#fff".
 * @return {Element} - The path which was created.
 */
GuiElements.draw.trapezoid = function(x, y, width, height, slantW, color) {
	DebugOptions.validateNonNull(color);
	DebugOptions.validateNumbers(x, y, width, height, slantW);
	const trapezoid = document.createElementNS("http://www.w3.org/2000/svg", 'path'); //Create the path.
	GuiElements.update.trapezoid(trapezoid, x, y, width, height, slantW); //Set its path description.
	trapezoid.setAttributeNS(null, "fill", color); //Set the fill.
	return trapezoid; //Return the finished trapezoid.
};
/**
 * Draws a circle at the center point
 * @param {number} cx
 * @param {number} cy
 * @param {number} radius
 * @param {string} color
 * @param {Element} [group]
 * @return {Element}
 */
GuiElements.draw.circle = function(cx, cy, radius, color, group) {
	DebugOptions.validateNonNull(color);
	DebugOptions.validateNumbers(cx, cy, radius);
	const circle = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
	circle.setAttributeNS(null, "cx", cx);
	circle.setAttributeNS(null, "cy", cy);
	circle.setAttributeNS(null, "r", radius);
	circle.setAttributeNS(null, "fill", color);
	if (group != null) {
		group.appendChild(circle);
	}
	return circle;
};
/**
 * Creates an SVG image with the given dimensions and name
 * @param {string} imageName - The name of the png image file
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {Element} [parent]
 * @return {Element}
 */
GuiElements.draw.image = function(imageName, x, y, width, height, parent) {
	DebugOptions.validateNumbers(x, y, width, height);
	const imageElement = GuiElements.create.image();
	imageElement.setAttributeNS(null, "x", x);
	imageElement.setAttributeNS(null, "y", y);
	imageElement.setAttributeNS(null, "width", width);
	imageElement.setAttributeNS(null, "height", height);
	//imageElement.setAttributeNS('http://www.w3.org/2000/xlink','href', "Images/"+imageName+".png");
	imageElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "Images/" + imageName + ".png");
	imageElement.setAttributeNS(null, 'visibility', 'visible');
	if (parent != null) {
		parent.appendChild(imageElement);
	}
	return imageElement;
};
/**
 * Creates a SVG text element with text in it with specified formatting and returns it.
 * @param {number} x - The text element's x coord.
 * @param {number} y - The text element's y coord.
 * @param {string} text - The text contained within the element.
 * @param {Font} font - The font of the text.
 * @param {string} color - The text's color in the form "#fff".
 * @param {null} [test]
 */
GuiElements.draw.text = function(x, y, text, font, color, test) {
	DebugOptions.assert(test == null);
	DebugOptions.validateNonNull(color);
	DebugOptions.validateNumbers(x, y);
	const textElement = GuiElements.create.text();
	textElement.setAttributeNS(null, "x", x);
	textElement.setAttributeNS(null, "y", y);
	textElement.setAttributeNS(null, "font-family", font.fontFamily);
	textElement.setAttributeNS(null, "font-size", font.fontSize);
	textElement.setAttributeNS(null, "font-weight", font.fontWeight);
	textElement.setAttributeNS(null, "fill", color);
	textElement.setAttributeNS(null, "class", "noselect"); //Make sure it can't be selected.
	text += ""; //Make text into a string
	text = text.replace(new RegExp(" ", 'g'), String.fromCharCode(160)); //Replace space with nbsp
	const textNode = document.createTextNode(text);
	textElement.textNode = textNode;
	textElement.appendChild(textNode);
	return textElement;
};

/* GuiElements.update contains functions that modify the attributes of existing SVG elements.
 * They do not return anything. */
GuiElements.update = {};
/**
 * Changes the fill color (or text color) of any SVG element.
 * @param {Element} element - The element to be recolored.
 * @param {string} color - The element's new color in the form "#fff".
 */
GuiElements.update.color = function(element, color) {
	DebugOptions.validateNonNull(color);
	element.setAttributeNS(null, "fill", color); //Recolors the element.
};
/**
 * Changes the fill opacity of any SVG element.
 * @param {Element} element - The element to be modified.
 * @param {number} opacity - The element's new opacity (from 0 to 1).
 */
GuiElements.update.opacity = function(element, opacity) {
	element.setAttributeNS(null, "fill-opacity", opacity); //Sets the opacity.
};
/**
 * Sets an SVG element's stroke
 * @param {Element} element - The element to be modified.
 * @param {string} color - The element's new color in the form "#fff".
 * @param {number} strokeW - The width of the stroke
 */
GuiElements.update.stroke = function(element, color, strokeW) {
	DebugOptions.validateNonNull(color);
	element.setAttributeNS(null, "stroke", color);
	element.setAttributeNS(null, "stroke-width", strokeW);
};
/**
 * Changes the text of an SVG text element.
 * @param {Element} textE - The text element to be modified.
 * @param {string} newText - The element's new text.
 */
GuiElements.update.text = function(textE, newText) {
	newText += ""; //Make newText into a string
	newText = newText.replace(new RegExp(" ", 'g'), String.fromCharCode(160)); //Replace space with nbsp
	if (textE.textNode != null) {
		textE.textNode.remove(); //Remove old text.
	}
	const textNode = document.createTextNode(newText); //Create new text.
	textE.textNode = textNode; //Adds a reference for easy removal.
	textE.appendChild(textNode); //Adds text to element.
};
/**
 * Changes the text of an SVG text element and removes ending characters until the width is less that a max width.
 * Adds "..." if characters are removed.
 * @param {Element} textE - The text element to be modified.
 * @param {string} text - The element's new text.
 * @param {number} maxWidth - When finished, the width of the text element will be less that this number.
 */
GuiElements.update.textLimitWidth = function(textE, text, maxWidth) {
	GuiElements.update.text(textE, text);
	let currentWidth = GuiElements.measure.textWidth(textE);
	if (currentWidth < maxWidth || text == "") {
		return;
	}
	let chars = 1;
	const maxChars = text.length;
	let currentText;
	while (chars <= maxChars) {
		currentText = text.substring(0, chars);
		GuiElements.update.text(textE, currentText + "...");
		currentWidth = GuiElements.measure.textWidth(textE);
		if (currentWidth > maxWidth) {
			chars--;
			break;
		}
		chars++;
	}
	currentText = text.substring(0, chars);
	GuiElements.update.text(textE, currentText + "...");
};
/**
 * Changes the path description of an SVG path object to make it a triangle.
 * @param {Element} pathE - The path element to be modified.
 * @param {number} x - The path's new x coord.
 * @param {number} y - The path's new y coord.
 * @param {number} width - The path's new width. (it is an isosceles triangle)
 * @param {number} height - The path's new height. (negative will make it point down)
 */
GuiElements.update.triangle = function(pathE, x, y, width, height) {
	DebugOptions.validateNumbers(x, y, width, height);
	const xshift = width / 2;
	let path = "";
	path += "m " + x + "," + y; //Draws bottom-left point.
	path += " " + xshift + "," + (0 - height); //Draws top-middle point.
	path += " " + xshift + "," + (height); //Draws bottom-right point.
	path += " z"; //Closes path.
	pathE.setAttributeNS(null, "d", path); //Sets path description.
};
/**
 * Makes the path a triangle with point at the specified coords, possibly rotated 90 degrees
 * @param {Element} pathE
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {boolean} vertical - Whether the triangle should be vertical or horizontal
 */
GuiElements.update.triangleFromPoint = function(pathE, x, y, width, height, vertical) {
	DebugOptions.validateNumbers(x, y, width, height);
	if (vertical == null) {
		vertical = 0;
	}

	const xshift = width / 2;
	let path = "";
	path += "m " + x + "," + y; //Draws top-middle point.
	if (vertical) {
		path += " " + xshift + "," + (height);
		path += " " + (0 - width) + ",0";
	} else {
		path += " " + (height) + "," + xshift;
		path += " 0," + (0 - width);
	}
	path += " z"; //Closes path.
	pathE.setAttributeNS(null, "d", path); //Sets path description.
};
/**
 * Changes the path description of an SVG path object to make it a trapezoid.
 * @param {Element} pathE - The path element to be modified.
 * @param {number} x - The path's new x coord.
 * @param {number} y - The path's new y coord.
 * @param {number} width - The path's new width. (it is an isosceles trapezoid)
 * @param {number} height - The path's new height. (negative will make it point down)
 * @param {number} slantW - The amount the trapezoid slopes in.
 */
GuiElements.update.trapezoid = function(pathE, x, y, width, height, slantW) {
	DebugOptions.validateNumbers(x, y, width, height, slantW);
	const shortW = width - 2 * slantW; //The width of the top of the trapezoid.
	let path = "";
	path += "m " + x + "," + (y + height); //Draws the points.
	path += " " + slantW + "," + (0 - height);
	path += " " + shortW + "," + 0;
	path += " " + slantW + "," + height;
	path += " z";
	pathE.setAttributeNS(null, "d", path); //Sets path description.
};
/**
 * Moves and resizes an SVG rect element.
 * @param {Element} rect - The rect element to be modified.
 * @param {number} x - The rect's new x coord.
 * @param {number} y - The rect's new y coord.
 * @param {number} width - The rect's new width.
 * @param {number} height - The rect's new height.
 */
GuiElements.update.rect = function(rect, x, y, width, height) {
	DebugOptions.validateNumbers(x, y, width, height);
	rect.setAttributeNS(null, "x", x);
	rect.setAttributeNS(null, "y", y);
	rect.setAttributeNS(null, "width", width);
	rect.setAttributeNS(null, "height", height);
};
/**
 * Used for zooming the main zoomGroup which holds the ui
 * @param {Element} group
 * @param {number} scale - The zoom amount
 */
GuiElements.update.zoom = function(group, scale) {
	DebugOptions.validateNumbers(scale);
	group.setAttributeNS(null, "transform", "scale(" + scale + ")");
};
/**
 * Changes the image an image element points to
 * @param {Element} imageE
 * @param {string} newImageName - The name of the png image
 */
GuiElements.update.image = function(imageE, newImageName) {
	//imageE.setAttributeNS('http://www.w3.org/2000/xlink','href', "Images/"+newImageName+".png");
	imageE.setAttributeNS("http://www.w3.org/1999/xlink", "href", "Images/" + newImageName + ".png");
};
/**
 * Updates a div, svg and group in the SVG that form a smoothScrollSet according to new dimensions
 * @param {Element} div - The div scrollable div containing a larger SVG
 * @param {Element} svg - The svg in the div
 * @param {Element} zoomG - The scaled group in the svg
 * @param {number} x - Position of the set
 * @param {number} y
 * @param {number} width - Dimensions of outside of set
 * @param {number} height
 * @param {number} innerWidth - Dimensions inside the set
 * @param {number} innerHeight
 */
GuiElements.update.smoothScrollSet = function(div, svg, zoomG, x, y, width, height, innerWidth, innerHeight) {
	DebugOptions.validateNonNull(div, svg, zoomG);
	DebugOptions.validateNumbers(x, y, width, height, innerWidth, innerHeight);
	/*foreignObj.setAttributeNS(null,"x",x);
	foreignObj.setAttributeNS(null,"y",y);
	foreignObj.setAttributeNS(null,"width",width * zoom);
	foreignObj.setAttributeNS(null,"height",height * zoom);*/

	const scrollY = innerHeight > height;
	const scrollX = innerWidth > width;
	div.classList.remove("noScroll");
	div.classList.remove("smoothScrollXY");
	div.classList.remove("smoothScrollX");
	div.classList.remove("smoothScrollY");
	if (scrollX && scrollY) {
		div.classList.add("smoothScrollY");
	} else if (scrollX) {
		div.classList.add("noScroll");
	} else if (scrollY) {
		div.classList.add("smoothScrollY");
	} else {
		div.classList.add("noScroll");
	}

	const zoom = GuiElements.zoomFactor;

	div.style.top = y + "px";
	div.style.left = x + "px";
	div.style.width = (width * zoom) + "px";
	div.style.height = (height * zoom) + "px";

	svg.setAttribute('width', innerWidth * zoom);
	svg.setAttribute('height', innerHeight * zoom);

	GuiElements.update.zoom(zoomG, zoom);
};
/**
 * Makes an SVG element have touches pass through it
 * @param {Element} svgE
 */
GuiElements.update.makeClickThrough = function(svgE) {
	svgE.style.pointerEvents = "none";
};

/* GuiElements.move contains functions that move existing SVG elements.
 * They do not return anything. */
GuiElements.move = {};
/**
 * Moves a group by changing its transform value.
 * @param {Element} group - The group to move.
 * @param {number} x - The new x offset of the group.
 * @param {number} y - The new y offset of the group.
 * @param {number} [zoom] - (Optional) The amount the group should be scaled.
 */
GuiElements.move.group = function(group, x, y, zoom) {
	DebugOptions.validateNumbers(x, y);
	if (zoom == null) {
		group.setAttributeNS(null, "transform", "translate(" + x + "," + y + ")");
	} else {
		group.setAttributeNS(null, "transform", "matrix(" + zoom + ",0,0," + zoom + "," + x + "," + y + ")");
	}
};
/**
 * Moves an SVG text element.
 * @param {string} text - The text to move.
 * @param {number} x - The new x coord of the text.
 * @param {number} y - The new y coord of the text.
 */
GuiElements.move.text = function(text, x, y) {
	DebugOptions.validateNumbers(x, y);
	text.setAttributeNS(null, "x", x);
	text.setAttributeNS(null, "y", y);
};
/**
 * Moves an SVG element.
 * @param {Element} element - The element to move.
 * @param {number} x - The new x coord of the element.
 * @param {number} y - The new y coord of the element.
 */
GuiElements.move.element = function(element, x, y) {
	DebugOptions.validateNumbers(x, y);
	element.setAttributeNS(null, "x", x);
	element.setAttributeNS(null, "y", y);
};
/**
 * Creates a clipping path (crops item) of the specified size and adds to the element if provided.
 * @param {number} x - The x coord of the clipping path.
 * @param {number} y - The y coord of the clipping path.
 * @param {number} width - The width of the clipping path.
 * @param {number} height - The height of the clipping path.
 * @param {Element} [element] - (optional) The element the path should be added to.
 * @return {Element} - The finished clipping path.
 */
GuiElements.clip = function(x, y, width, height, element) {
	DebugOptions.validateNumbers(x, y, width, height);
	const id = Math.random() + "";
	const clipPath = document.createElementNS("http://www.w3.org/2000/svg", 'clipPath'); //Create the rect.
	const clipRect = GuiElements.draw.rect(x, y, width, height);
	clipPath.appendChild(clipRect);
	clipPath.setAttributeNS(null, "id", id);
	GuiElements.defs.appendChild(clipPath);
	if (element != null) {
		element.setAttributeNS(null, "clip-path", "url(#" + id + ")");
	}
	return clipPath;
};

/* GuiElements.measure contains functions that measure parts of the UI.
 * They return the measurement. */
GuiElements.measure = {};
/**
 * Measures the width of an existing SVG text element.
 * @param {Element} textE - The text element to measure.
 * @return {number} - The width of the text element.
 */
GuiElements.measure.textWidth = function(textE) { //Measures an existing text SVG element
	return GuiElements.measure.textDim(textE, false);
};
/**
 * Measures the height of the SVG text element
 * @param {Element} textE
 * @return {number}
 */
GuiElements.measure.textHeight = function(textE) { //Measures an existing text SVG element
	return GuiElements.measure.textDim(textE, true);
};
/**
 * Measures the width/height of an existing SVG text element.
 * @param {Element} textE - The text element to measure.
 * @param {bool} height - true/false for width/height, respectively.
 * @return {number} - The width/height of the text element.
 */
GuiElements.measure.textDim = function(textE, height) { //Measures an existing text SVG element
	if (textE.textContent === "") { //If it has no text, the width is 0.
		return 0;
	}
	//Gets the bounding box, but that is 0 if it isn't visible on the screen.
	let bbox = textE.getBBox();
	let textD = bbox.width; //Gets the width of the bounding box.
	if (height) {
		textD = bbox.height; //Gets the height of the bounding box.
	}
	if (textD === 0) { //The text element probably is not visible on the screen.
		const parent = textE.parentNode; //Store the text element's current (hidden) parent.
		GuiElements.layers.temp.appendChild(textE); //Change its parent to one we know is visible.
		bbox = textE.getBBox(); //Now get its bounding box.
		textD = bbox.width;
		if (height) {
			textD = bbox.height;
		}
		textE.remove(); //Remove it from the temp layer.
		if (parent != null) {
			parent.appendChild(textE); //Add it back to its old parent.
		}
	}
	return textD; //Return the width/height.
};
/**
 * Measures the width of a string if it were used to create a text element with certain formatting.
 * @param {string} text - The string to measure.
 * @param {Font} font - The font family of the text element.
 * @return {number} - The width of the text element made using the string.
 */
GuiElements.measure.stringWidth = function(text, font) {
	const textElement = GuiElements.create.text(); //Make the text element.
	textElement.setAttributeNS(null, "font-family", font.fontFamily); //Set the attributes.
	textElement.setAttributeNS(null, "font-size", font.fontSize);
	textElement.setAttributeNS(null, "font-weight", font.fontWeight);
	textElement.setAttributeNS(null, "class", "noselect"); //Make sure it can't be selected.
	const textNode = document.createTextNode(text); //Add the text to the text element.
	textElement.textNode = textNode;
	textElement.appendChild(textNode);
	return GuiElements.measure.textWidth(textElement); //Measure it.
};

/**
 * Creates a black rectangle to block interaction with the main screen.  Used for dialogs.
 */
GuiElements.blockInteraction = function() {
	if (GuiElements.dialogBlock == null) {
		const rect = GuiElements.draw.rect(0, 0, GuiElements.width, GuiElements.height);
		GuiElements.update.opacity(rect, GuiElements.blockerOpacity);
		GuiElements.layers.dialogBlock.appendChild(rect);
		TouchReceiver.touchInterrupt();
		GuiElements.dialogBlock = rect;
	}
};
/**
 * Removes the black rectangle that blocks interaction
 */
GuiElements.unblockInteraction = function() {
	if (GuiElements.dialogBlock != null) {
		GuiElements.dialogBlock.remove();
		GuiElements.dialogBlock = null;
	}
};
/**
 * Updates the dimensions of the blocker
 */
GuiElements.updateDialogBlockZoom = function() {
	if (GuiElements.dialogBlock != null) {
		GuiElements.update.rect(GuiElements.dialogBlock, 0, 0, GuiElements.width, GuiElements.height);
	}
};

/**
 * Sets the scale levels of the zoomGroups and then updates the UI
 */
GuiElements.updateZoom = function() {
	GuiElements.zoomFactor = GuiElements.zoomMultiple * GuiElements.computedZoom;
	GuiElements.zoomGroups.forEach(function(zoomGroup) {
		GuiElements.update.zoom(zoomGroup, GuiElements.zoomFactor);
	});
	GuiElements.updateDims();
};
/**
 * Sets the width and height using dimensions from the backend, then tells the UI to update
 * @param {number} newWidth
 * @param {number} newHeight
 */
GuiElements.updateDimsPreview = function(newWidth, newHeight) {
	GuiElements.width = newWidth / GuiElements.zoomFactor;
	GuiElements.height = newHeight / GuiElements.zoomFactor;
	GuiElements.passUpdateZoom();
};
/**
 * Remeasures the width and height for GuiElements and then tells the UI to update
 */
GuiElements.updateDims = function() {
	GuiElements.width = window.innerWidth / GuiElements.zoomFactor;
	GuiElements.height = window.innerHeight / GuiElements.zoomFactor;
	GuiElements.passUpdateZoom();
};
/**
 * Tells parts of the UI to update their dimensions
 */
GuiElements.passUpdateZoom = function() {
	Overlay.closeOverlaysExcept(TitleBar.viewMenu);
	GuiElements.checkSmallMode();
	DisplayBoxManager.updateZoom();
	TitleBar.updateZoomPart1();
	BlockPalette.updateZoom();
	TitleBar.updateZoomPart2();
	TabManager.updateZoom();
	GuiElements.updateDialogBlockZoom();
	RowDialog.updateZoom();
};

/* GuiElements.load loads important information from the backend before the UI even starts to be build (such as
 * screen dimensions and OS).  All load functions are launched simultaneously and each calls a callback, which
 * "checks it off the list" of things to load. */
GuiElements.load = {};
/**
 * Called to load information from backend before building UI
 * @param {function} callback - Called when all data is loaded
 */
GuiElements.loadInitialSettings = function(callback) {
	// TODO: Refactor this function
	DebugOptions();
	Data.setConstants();
	HtmlServer();
	GuiElements.setGuiConstants();
	SettingsManager();
	// The checklist of thing to load
	const loadProg = {};
	loadProg.version = false;
	loadProg.zoom = false;
	loadProg.os = false;
	loadProg.lastFileName = true;
	loadProg.lastFileNamed = true;
	const load = GuiElements.load;
	if (!DebugOptions.shouldSkipInitSettings()) {
		let count = 0;
		// Function checks if all the pieces are done loading and calls the callback when they are
		const checkIfDone = function() {
			count++;
			GuiElements.alert("" + loadProg.version + loadProg.zoom + loadProg.os +
				loadProg.lastFileName + loadProg.lastFileNamed);
			if (loadProg.version && loadProg.zoom && loadProg.os && loadProg.lastFileName && loadProg.lastFileNamed) {
				callback();
			}
		};
		// The three things to load are requested
		load.getAppVersion(function() {
			loadProg.version = true;
			checkIfDone();
		});
		load.configureZoom(function() {
			GuiElements.width = window.innerWidth / GuiElements.zoomFactor;
			GuiElements.height = window.innerHeight / GuiElements.zoomFactor;
			loadProg.zoom = true;
			GuiElements.checkSmallMode();
			checkIfDone();
		});
		load.getOsVersion(function() {
			loadProg.os = true;
			checkIfDone();
		});
	} else {
		callback();
	}
};
/**
 * Loads the version number from version.js
 * @param {function} callback
 */
GuiElements.load.getAppVersion = function(callback) {
	GuiElements.appVersion = FrontendVersion;
	callback();
};
/**
 * Loads the OS version
 * @param {function} callback
 */
GuiElements.load.getOsVersion = function(callback) {
	HtmlServer.sendRequestWithCallback("properties/os", function(resp) {
		GuiElements.osVersion = resp;
		const parts = resp.split(" ");
		GuiElements.isKindle = (parts.length >= 1 && parts[0] === "Kindle");
		GuiElements.isAndroid = (parts.length >= 1 && parts[0] === "Android") || GuiElements.isKindle;
		GuiElements.isIos = (parts.length >= 1 && parts[0] === "iOS");
		callback();
	}, function() {
		GuiElements.osVersion = "";
		GuiElements.isKindle = false;
		callback();
	});
};
/**
 * Loads dimension information and settings from the backend and uses it to compute the current zoom level
 * @param {function} callback
 */
GuiElements.load.configureZoom = function(callback) {
	const GE = GuiElements;
	SettingsManager.loadSettings(function() {
		const callbackFn = function() {
			GE.zoomMultiple = SettingsManager.zoom.getValue();
			GE.zoomFactor = GE.computedZoom * GE.zoomMultiple;
			if (GE.zoomFactor < GuiElements.minZoom || GE.zoomFactor > GuiElements.maxZoom || isNaN(GE.zoomFactor)) {
				GE.zoomMultiple = 1;
				SettingsManager.zoom.writeValue(1);
				GE.zoomFactor = GE.computedZoom * GE.zoomMultiple;
			}
			if (GE.zoomFactor < GuiElements.minZoom || GE.zoomFactor > GuiElements.maxZoom || isNaN(GE.zoomFactor)) {
				GE.zoomMultiple = 1;
				GE.computedZoom = GE.defaultZoomMultiple;
				SettingsManager.zoom.writeValue(1);
				GE.zoomFactor = GE.computedZoom * GE.zoomMultiple;
			}
			callback();
		};
		HtmlServer.sendRequestWithCallback("properties/dims", function(response) {
			GE.computedZoom = GE.computeZoomFromDims(response);
			callbackFn();
		}, function() {
			callbackFn();
		});
	});
};
/**
 * Takes a response from the properties/dims request and computes and sets the appropriate zoom level
 * @param {string} dims - The response from properties/dims
 */
GuiElements.computeZoomFromDims = function(dims) {
	//GuiElements.alert("Got dimensions from device.  Computing zoom.");
	//GuiElements.alert("received dims: " + dims);
	const parts = dims.split(",");
	if (parts.length === 2) {
		const widthMm = parseFloat(parts[0]);
		const heightMm = parseFloat(parts[1]);
		const diagMm = Math.sqrt(widthMm * widthMm + heightMm * heightMm);
		const widthPx = window.innerWidth;
		const heightPx = window.innerHeight;
		const diagPx = Math.sqrt(widthPx * widthPx + heightPx * heightPx);
		const zoom = (diagPx * GuiElements.defaultZoomMm) / (GuiElements.defaultZoomPx * diagMm);
		//GuiElements.alert("Computed zoom to: " + zoom + " diagPx:" + diagPx + " diagMm:" + diagMm);
		return zoom * GuiElements.defaultZoomMultiple;
	} else {
		return 1;
	}
};

/* Convert between coords relative to the screen and coords that incorporate the current zoom level
 * Note that most relToAbs functions in other classes actually return coords that do not depend on the
 * current zoom level.  The GuiElements relToAbs functions take these coords and convert them into true
 * screen coords. */
/**
 * @param {number} x
 * @return {number}
 */
GuiElements.relToAbsX = function(x) {
	return x * GuiElements.zoomFactor;
};
/**
 * @param {number} y
 * @return {number}
 */
GuiElements.relToAbsY = function(y) {
	return y * GuiElements.zoomFactor;
};

/**
 * Hides the BlockPalette by hiding the layers it renders on
 * @param {boolean} [skipUpdate=false] - Whether the TabManager should not be told to update arrows because the
 *                                       TabManager has not been initialized yet
 */
GuiElements.hidePaletteLayers = function(skipUpdate) {
	if (skipUpdate == null) {
		skipUpdate = false;
	}
	let GE = GuiElements;
	if (GuiElements.paletteLayersVisible) {
		GuiElements.paletteLayersVisible = false;
		SettingsManager.sideBarVisible.writeValue("false");
		GE.layers.paletteBG.hide();
		GE.layers.paletteScroll.style.visibility = "hidden";
		GE.layers.trash.hide();
		GE.layers.catBg.hide();
		GE.layers.categories.hide();
		if (!skipUpdate) {
			TabManager.updateZoom();
		}
	}
};
/**
 * Shows the BlockPalette
 * @param {boolean} [skipUpdate=false] - Whether updating the TabManager should be skipped
 */
GuiElements.showPaletteLayers = function(skipUpdate) {
	let GE = GuiElements;
	if (skipUpdate == null) {
		skipUpdate = false;
	}
	if (!GuiElements.paletteLayersVisible) {
		GuiElements.paletteLayersVisible = true;
		SettingsManager.sideBarVisible.writeValue("true");
		GE.layers.paletteBG.show();
		GE.layers.paletteScroll.style.visibility = "visible";
		GE.layers.trash.show();
		GE.layers.catBg.show();
		GE.layers.categories.show();
		if (!skipUpdate) {
			TabManager.updateZoom();
		}
	}
};

/**
 * Checks if the UI should enter/exit small mode based on the current width
 */
GuiElements.checkSmallMode = function() {
	let GE = GuiElements;
	GuiElements.smallMode = GuiElements.width < GuiElements.relToAbsX(GuiElements.smallModeThreshold);
	if (!GE.smallMode && !GE.paletteLayersVisible) {
		GE.showPaletteLayers(true);
	}
	if (!GE.smallMode && SettingsManager.sideBarVisible.getValue() !== "true") {
		SettingsManager.sideBarVisible.writeValue("true");
	}
};
/* BlockList is a static class that holds a list of blocks and categories.
 * It is in charge of populating the BlockPalette by helping to create Category objects.
 */
/**
 * Populates the list of category names. Run by GuiElements.
 */
function BlockList() {
	const cat = BlockList.categories = [];

	// List only includes categories that will appear in the BlockPalette in order.
	// Category names should be capitalized in the way they should be displayed on screen.
	cat.push("Robots");
	cat.push("Operators");
	cat.push("Sound");
	cat.push("Tablet");
	cat.push("Control");
	cat.push("Variables");
}

/**
 * Returns the id for a category given its index in the category list. Ids are lowercase.
 * @param {number} index - The category's index in the category name list.
 * @return {string} - The category's id (its name in lowercase).
 */
BlockList.getCatId = function(index) {
	return BlockList.categories[index].toLowerCase();
};

/**
 * Returns the category's name given its index in the category list.
 * @param {number} index - The category's index in the category name list.
 * @return {string} - The category's name.
 */
BlockList.getCatName = function(index) {
	return BlockList.categories[index];
};

/**
 * Returns the length of the category list.
 * @return {number} - The length of the category list.
 */
BlockList.catCount = function() {
	return BlockList.categories.length;
};

/*
 * The following functions populate a Category for the BlockPalette.
 * Each function has the same structure.
 * Blocks are added with category.addBlockByName(blockNameAsString) and spaces between groups with category.addSpace().
 * category.trimBottom() is used to remove any extra space at the bottom of the category.
 */

/**
 * @param {Category} category
 */
BlockList.populateCat_tablet = function(category) {
	category.addBlockByName("B_DeviceShaken");
	category.addBlockByName("B_DeviceLocation");
	category.addBlockByName("B_DeviceSSID");
	category.addBlockByName("B_DevicePressure");
	category.addBlockByName("B_DeviceRelativeAltitude");
	category.addBlockByName("B_DeviceAcceleration");
	category.addBlockByName("B_DeviceOrientation");
	category.addSpace();
	category.addBlockByName("B_Display");
	category.addSpace();
	category.addBlockByName("B_Ask");
	category.addBlockByName("B_Answer");
	category.addSpace();
	category.addBlockByName("B_ResetTimer");
	category.addBlockByName("B_Timer");
	category.addSpace();
	category.addBlockByName("B_CurrentTime");
	category.trimBottom();
};

/**
 * @param {Category} category
 */
BlockList.populateCat_operators = function(category) {
	category.addBlockByName("B_Add");
	category.addBlockByName("B_Subtract");
	category.addBlockByName("B_Multiply");
	category.addBlockByName("B_Divide");
	category.addSpace();
	category.addBlockByName("B_Mod");
	category.addBlockByName("B_Round");
	category.addBlockByName("B_mathOfNumber");
	category.addBlockByName("B_PickRandom");
	category.addSpace();
	category.addBlockByName("B_LessThan");
	category.addBlockByName("B_EqualTo");
	category.addBlockByName("B_GreaterThan");
	category.addSpace();
	category.addBlockByName("B_And");
	category.addBlockByName("B_Or");
	category.addBlockByName("B_Not");
	category.addSpace();
	category.addBlockByName("B_True");
	category.addBlockByName("B_False");
	category.addSpace();
	category.addBlockByName("B_LetterOf");
	category.addBlockByName("B_LengthOf");
	category.addBlockByName("B_join");
	category.addBlockByName("B_Split");
	category.addSpace();
	category.addBlockByName("B_IsAType");
	category.trimBottom();
};

/**
 * @param {Category} category
 */
BlockList.populateCat_control = function(category) {
	category.addBlockByName("B_WhenFlagTapped");
	category.addBlockByName("B_WhenIReceive");
	category.addSpace();
	category.addBlockByName("B_Broadcast");
	category.addBlockByName("B_BroadcastAndWait");
	category.addBlockByName("B_Message");
	category.addSpace();
	category.addBlockByName("B_Wait");
	category.addBlockByName("B_WaitUntil");
	category.addSpace();
	category.addBlockByName("B_Forever");
	category.addBlockByName("B_Repeat");
	category.addBlockByName("B_RepeatUntil");
	category.addSpace();
	category.addBlockByName("B_If");
	category.addBlockByName("B_IfElse");
	category.addSpace();
	category.addBlockByName("B_Stop");
	category.trimBottom();
};

/**
 * @param {Category} category
 */
BlockList.populateCat_sound = function(category) {
	const button = category.addButton("Record sounds", RecordingDialog.showDialog, true);
	button.setDisabledTabFunction(RecordingDialog.alertNotInProject);
	category.addSpace();
	category.addBlockByName("B_PlayRecording");
	category.addBlockByName("B_PlayRecordingUntilDone");
	category.addBlockByName("B_PlaySound");
	category.addBlockByName("B_PlaySoundUntilDone");
	category.addBlockByName("B_StopAllSounds");
	category.addSpace();
	category.addBlockByName("B_RestForBeats");
	category.addBlockByName("B_PlayNoteForBeats");
	category.addSpace();
	category.addBlockByName("B_ChangeTempoBy");
	category.addBlockByName("B_SetTempoTo");
	category.addBlockByName("B_Tempo");
	category.trimBottom();
};

/**
 * @param {Category} category
 */
BlockList.populateCat_variables = function(category) {
	category.addButton("Create variable", CodeManager.newVariable);
	category.addSpace();

	const variables = CodeManager.variableList;
	if (variables.length > 0) {
		// We show a variable Block for every variable
		variables.forEach(function(variable) {
			category.addVariableBlock(variable);
		});
		category.addSpace();

		// These Blocks let the variable be selected from a DropSlot, so we only need one of each of them
		category.addBlockByName("B_SetTo");
		category.addBlockByName("B_ChangeBy");
	}

	category.addSpace();
	category.addButton("Create list", CodeManager.newList);
	category.addSpace();

	const lists = CodeManager.listList;
	if (lists.length > 0) {
		lists.forEach(function(list) {
			category.addListBlock(list);
		});
		category.addSpace();
		category.addBlockByName("B_AddToList");
		category.addBlockByName("B_DeleteItemOfList");
		category.addBlockByName("B_InsertItemAtOfList");
		category.addBlockByName("B_ReplaceItemOfListWith");
		category.addBlockByName("B_CopyListToList");
	}

	// These list functions can take input from the Split block, so we show them even if there are no Lists
	category.addBlockByName("B_ItemOfList");
	category.addBlockByName("B_LengthOfList");
	category.addBlockByName("B_ListContainsItem");
	category.trimBottom();
};

/**
 * Robot Blocks are stored in collapsible sets for each type of Robot.  This function creates the groupings
 * and BlockList.populateItem_[deviceClassId] fills a given group
 * @param {Category} category
 */
BlockList.populateCat_robots = function(category) {
	// A list of names and ids to give the Collapsible Set constructor
	let nameIdList = [];
	let typeList = Device.getTypeList();
	typeList.forEach(function(deviceClass) {
		let entry = {};
		entry.name = deviceClass.getDeviceTypeName();
		entry.id = deviceClass.getDeviceTypeId();
		nameIdList.push(entry);
	});
	// Create the set and add it to the category
	const set = category.addCollapsibleSet(nameIdList);

	for (let i = 0; i < typeList.length; i++) {
		// Populate each item in the set
		const item = set.getItem(i);
		BlockList["populateItem_" + typeList[i].getDeviceTypeId()](item);
	}
	category.trimBottom();
};

/**
 * @param {CollapsibleItem} collapsibleItem
 */
BlockList.populateItem_hummingbird = function(collapsibleItem) {
	collapsibleItem.addBlockByName("B_HBServo");
	collapsibleItem.addBlockByName("B_HBMotor");
	collapsibleItem.addBlockByName("B_HBVibration");
	collapsibleItem.addSpace();
	collapsibleItem.addBlockByName("B_HBLed");
	collapsibleItem.addBlockByName("B_HBTriLed");
	collapsibleItem.addSpace();
	collapsibleItem.addBlockByName("B_HBLight");
	collapsibleItem.addBlockByName("B_HBTempC");
	collapsibleItem.addBlockByName("B_HBTempF");
	collapsibleItem.addBlockByName("B_HBDistCM");
	collapsibleItem.addBlockByName("B_HBDistInch");
	collapsibleItem.addBlockByName("B_HBKnob");
	collapsibleItem.addBlockByName("B_HBSound");
	collapsibleItem.trimBottom();
	collapsibleItem.finalize();
};

/**
 * @param {CollapsibleItem} collapsibleItem
 */
BlockList.populateItem_hummingbirdbit = function(collapsibleItem) {
	collapsibleItem.addBlockByName("B_BBTriLed");
	collapsibleItem.addBlockByName("B_BBLed")
	collapsibleItem.addBlockByName("B_BBPositionServo");
	collapsibleItem.addBlockByName("B_BBRotationServo");
	collapsibleItem.addBlockByName("B_BBBuzzer");
<<<<<<< HEAD
=======
	//collapsibleItem.addBlockByName("B_BBLedArray");
>>>>>>> 4a497dd4bb1d206bec66147198ea8b2f33fe75e1
	collapsibleItem.addSpace();
	collapsibleItem.addBlockByName("B_BBSensors");
	collapsibleItem.addBlockByName("B_BBAccelerometerMagnetometer");
	//collapsibleItem.addBlockByName("B_BBButton");
	collapsibleItem.trimBottom();
	collapsibleItem.finalize();
};

/**
 * @param {CollapsibleItem} collapsibleItem
 */
BlockList.populateItem_microbit = function(collapsibleItem) {
	collapsibleItem.addBlockByName("B_MBLedArray");
	collapsibleItem.addSpace();
<<<<<<< HEAD
	collapsibleItem.addBlockByName("B_MBPrint");
	collapsibleItem.addSpace();
	collapsibleItem.addBlockByName("B_MBAccelerometerMagnetometer");
=======
	//collapsibleItem.addBlockByName("B_MBPrint");
	collapsibleItem.addSpace();
>>>>>>> 4a497dd4bb1d206bec66147198ea8b2f33fe75e1
	//collapsibleItem.addBlockByName("B_MBButton");
	collapsibleItem.trimBottom();
	collapsibleItem.finalize();
};

/**
 * @param {CollapsibleItem} collapsibleItem
 *//*
BlockList.populateItem_finch = function(collapsibleItem) {
	collapsibleItem.addBlockByName("B_FinchSetAll");
	collapsibleItem.trimBottom();
	collapsibleItem.finalize();
};*/

/**
 * @param {CollapsibleItem} collapsibleItem
 *//*
BlockList.populateItem_flutter = function(collapsibleItem) {
	collapsibleItem.addBlockByName("B_FlutterServo");
	collapsibleItem.addBlockByName("B_FlutterTriLed");
	collapsibleItem.addBlockByName("B_FlutterBuzzer");
	collapsibleItem.addSpace();
	collapsibleItem.addBlockByName("B_FlutterLight");
	collapsibleItem.addBlockByName("B_FlutterTempC");
	collapsibleItem.addBlockByName("B_FlutterTempF");
	collapsibleItem.addBlockByName("B_FlutterDistCM");
	collapsibleItem.addBlockByName("B_FlutterDistInch");
	collapsibleItem.addBlockByName("B_FlutterKnob");
	collapsibleItem.addBlockByName("B_FlutterSound");
	collapsibleItem.addBlockByName("B_FlutterSoil");
	collapsibleItem.trimBottom();
	collapsibleItem.finalize();
};*/


/*
 * Static.  Holds constant values for colors used throughout the UI (lightGray, darkGray, black, white)
 */

function Colors() {
	Colors.setCommon();
	Colors.setCategory();
	Colors.setMultipliers();
}

Colors.setCommon = function() {
	Colors.white = "#fff";
	Colors.lightGray = "#3D3D3D";
	Colors.darkGray = "#282828";
	Colors.darkDarkGray = "#151515";
	Colors.black = "#000";
	Colors.red = "#FF0000";
};

Colors.setCategory = function() {
	Colors.categoryColors = {
		"robots": "#FF9600",
		"hummingbird": "#FF9600",
		"hummingbirdbit": "#FF9600",
		"microbit": "#FF9600",
		"flutter": "#FF9600",
		"finch": "#FF9600",
		"sound": "#EE00FF",
		"tablet": "#019EFF",
		"control": "#FFCC00",
		"operators": "#44FF00",
		"variables": "#FF5B00",
		"lists": "#FF0000",
		"inactive": "#a3a3a3"
	};
};

Colors.setMultipliers = function() {
	// Used for gradients
	Colors.gradStart = 1;
	Colors.gradEnd = 0.5;
	Colors.gradDarkStart = 0.25;
	Colors.gradDarkEnd = 0.5;
};

/**
 * Creates normal and dark gradients for all categories
 */
Colors.createGradients = function() {
	Colors.createGradientSet("gradient_", Colors.gradStart, Colors.gradEnd);
	Colors.createGradientSet("gradient_dark_", Colors.gradDarkStart, Colors.gradDarkEnd);
};

/**
 * Creates gradients for all categories
 * @param {string} name
 * @param {number} multStart
 * @param {number} multEnd
 */
Colors.createGradientSet = function(name, multStart, multEnd) {
	Object.keys(Colors.categoryColors).map(function(category) {
		let color = Colors.categoryColors[category];
		Colors.createGradientFromColorAndMults(name, category, color, multStart, multEnd);
	});
};

/**
 * Creates a gradient in the SVG going from one darkness to another
 * @param {string} name - Used to identify the type of gradient ("gradient_" or "gradient_dark_")
 * @param {string} catId - Used to get the specific gradient
 * @param {string} color - color in hex
 * @param {number} multStart - number from 0 to 1 to determine the darkness of the start color
 * @param {number} multEnd - number from 0 to 1 for end color darkness
 */
Colors.createGradientFromColorAndMults = function(name, catId, color, multStart, multEnd) {
	const darken = Colors.darkenColor;
	const color1 = darken(color, multStart);
	const color2 = darken(color, multEnd);
	GuiElements.create.gradient(name + catId, color1, color2);
};

/**
 * Multiplies the rgb values by amt to make them darker
 * @param {string} color - color in hex
 * @param {number} amt - number from 0 to 1
 * @return {string} - color in hex
 */
Colors.darkenColor = function(color, amt) {
	// Source:
	// stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
	const col = parseInt(color.slice(1), 16);
	let result = (((col & 0x0000FF) * amt) | ((((col >> 8) & 0x00FF) * amt) << 8) | (((col >> 16) * amt) << 16)).toString(16);
	while (result.length < 6) {
		result = "0" + result;
	}
	return "#" + result;
};

/**
 * Gets the color for a category
 * @param {string} category
 * @return {string} - color in hex
 */
Colors.getColor = function(category) {
	return Colors.categoryColors[category];
};

/**
 * Gets the gradient specified
 * @param {string} category - Should start with "gradient_" or "gradient_dark_"
 * @return {string} - Url to gradient
 */
Colors.getGradient = function(category) {
	return "url(#gradient_" + category + ")";
};

/**
 * Contains data about a font.  Immutable and typically generated using the Font.uiFont(size) function.
 * Properties are accessed directly to be read, but should not be assigned.  charHeight is a computed property that
 * indicates how tall the text will be when it appears on the screen and is used for centring text vertically.
 * @param {string} fontFamily - The font to use.  So far, everything is Arial
 * @param {number} fontSize
 * @param {string} fontWeight - ["bold", "normal"]
 * @constructor
 */
function Font(fontFamily, fontSize, fontWeight) {
	this.fontFamily = fontFamily;
	this.fontSize = fontSize;
	this.charHeight = this.lookupCharH(fontSize);
	this.fontWeight = fontWeight;
}

/**
 * Computes the charHeight of the font, given its size.  May need to be adjusted if more fonts are being used
 * @param {number} fontSize
 * @return {number}
 */
Font.prototype.lookupCharH = function(fontSize){
	return 0.6639 * fontSize + 1.644;
};

/**
 * Returns a Font that is identical to this font but bold
 * @return {Font}
 */
Font.prototype.bold = function(){
	return new Font(this.fontFamily, this.fontSize, "bold");
};

/**
 * Returns a Font that is identical to this font but not bold
 * @return {Font}
 */
Font.prototype.unBold = function(){
	return new Font(this.fontFamily, this.fontSize, "normal");
};

/**
 * Returns the default font of a given size.
 * @param {number} fontSize
 * @return {Font}
 */
Font.uiFont = function(fontSize){
	return new Font("Arial", fontSize, "normal");
};
/**
 * This static class hold objects which encode path information for icons.  Each entry contains information about
 * the width, height and path of the icon.  To add a new icon:
 * 1) Go to https://material.io/icons/ and search for the icon
 * 2) Download an SVG of the icon (or make one yourself in Inkscape)
 * 3) Select all objects and use Path > Object to Path to turn them into paths
 * 4) Merge all paths into one with Path > Union
 * 5) Go to File > Document Properties > Resize page to drawing or selection
 * 6) Save the file as an SVG
 * 7) Use the dimensions as the width/height
 * 8) Open the file in a text editor, and copy out the string for the path
 * 9) Create an entry in VectorPaths with the width/height/path information
 * 10) You may notice that the icon is off-center when you try to use it.  That means the starting point of the path is
 *     wrong.  Try changing the path to start with "m 0,0", or "m x,y" where x and y are the locations of the initial
 *     point in the Inkscape file
 * @static
 */
function VectorPaths(){
	const VP=VectorPaths;
	VP.backspace={};
	VP.backspace.path="m 13.7,2.96 -1.9326,1.91387 3.4149,3.37741 -3.4149,3.39614 1.9326,1.9139 3.415,-3.3962 3.4149,3.3962 1.9139,-1.9139 -3.3962,-3.39614 3.3962,-3.37741 -1.9139,-1.91387 -3.4149,3.39618 -3.415,-3.39618 z m -8.1433,-2.83328 23.1165,0 0,16.2679 -23.1165,0 -5.4976,-8.14334 5.4976,-8.12456 z";
	VP.backspace.width=28.614;
	VP.backspace.height=16.2679;
	VP.checkmark={};
	VP.checkmark.path="M 4.5064398,0.02118182 5.6767307,0.81550087 2.3670683,5.6290633 0.02647727,4.0457402 0.82608984,2.8860327 1.9963864,3.6803471 Z";
	VP.checkmark.width=6;
	VP.checkmark.height=6;
	VP.flag={};
	VP.flag.path="m 0,0 11.2202,0 0,5.69439 c 0,3.1469 7.23037,5.69439 16.16532,5.69439 8.91622,0 16.14659,-2.54749 16.14659,-5.69439 0,-3.12817 7.24911,-5.69439 16.16533,-5.69439 8.93494,0 16.16532,2.56622 16.16532,5.69439 l 0,45.53639 c 0,-3.1469 -7.23038,-5.69439 -16.16532,-5.69439 -8.91622,0 -16.16533,2.54749 -16.16533,5.69439 0,3.1469 -7.23037,5.69439 -16.14659,5.69439 -8.93495,0 -16.16532,-2.54749 -16.16532,-5.69439 l 0,53.04774 -11.2202,0 z";
	VP.flag.width=75.863;
	VP.flag.height=104.279;
	VP.stage={};
	VP.stage.path="m 80.789,36.957 12.02565,0 0,14.16105 0,0 0,8.82256 -28.99643,0 z m -80.78916,0 11.96946,0 16.97078,22.98361 -28.94024,0 z m 92.81481,-30.08286 0,27.79761 -12.13804,0 -16.0342,-21.69113 3.42787,-0.33716 c 9.96518,-1.18009 18.45057,-3.1469 24.44467,-5.61947 z m -92.81481,-0.0187 0.37463,0.16858 c 5.9941,2.47257 14.47949,4.43938 24.44467,5.61947 l 3.29675,0.33716 -16.0342,21.69113 -12.08185,0 z m 0,-6.85575 92.88974,0 0,4.28953 -1.49853,0.76799 c -5.60073,2.54749 -14.3109,4.5705 -24.78183,5.71312 l -3.35295,0.33717 -1.40486,0.13112 -6.66843,0.39336 -1.70458,0.0749 -7.02432,0.13112 -7.04307,-0.13112 -1.70457,-0.0749 -6.66843,-0.39336 -1.53598,-0.14985 -3.22183,-0.31844 c -10.47093,-1.14262 -19.16237,-3.16563 -24.78183,-5.71312 l -1.49853,-0.76799 z";
	VP.stage.width=92.890;
	VP.stage.height=59.941;
	VP.stop={};
	VP.stop.path="m 0,19.957 20.23007,-20.26754 28.65926,0 20.26753,20.26754 0,28.6218 -20.26753,20.26753 -28.65926,0 -20.23007,-20.26753 z";
	VP.stop.width=69.157;
	VP.stop.height=69.157;
	VP.file={};
	VP.file.path="m 407.092,0 -370.3896,0 c -17.03792,0 -30.865797,13.82788 -30.865797,30.8658 l 0,432.1212 c 0,17.05335 13.827877,30.8658 30.865797,30.8658 l 277.7922,0 123.4632,-123.4632 0,-339.5238 c 0,-17.03792 -13.81245,-30.8658 -30.8658,-30.8658 z m -92.5974,450.20856 0,-79.81896 79.81896,0 -79.81896,79.81896 z m 92.5974,-110.68476 -92.5974,0 c -17.03792,0 -30.8658,13.82788 -30.8658,30.8658 l 0,92.5974 -246.9264,0 0,-432.1212 370.3896,0 0,308.658 z m -339.5238,-231.4935 c 0,-8.53439 6.89851,-15.4329 15.4329,-15.4329 l 277.7922,0 c 8.53439,0 15.4329,6.89851 15.4329,15.4329 0,8.56526 -6.89851,15.4329 -15.4329,15.4329 l -277.7922,0 c -8.53439,0 -15.4329,-6.89851 -15.4329,-15.4329 z m 0,92.5974 c 0,-8.53439 6.89851,-15.4329 15.4329,-15.4329 l 277.7922,0 c 8.53439,0 15.4329,6.89851 15.4329,15.4329 0,8.56526 -6.89851,15.4329 -15.4329,15.4329 l -277.7922,0 c -8.53439,0 -15.4329,-6.89851 -15.4329,-15.4329 z m 0,92.5974 c 0,-8.53439 6.89851,-15.4329 15.4329,-15.4329 l 277.7922,0 c 8.53439,0 15.4329,6.89851 15.4329,15.4329 0,8.56526 -6.89851,15.4329 -15.4329,15.4329 l -277.7922,0 c -8.53439,0 -15.4329,-6.89851 -15.4329,-15.4329 z";
	VP.file.width=432.121;
	VP.file.height=493.853;
	VP.dropbox={};
	VP.dropbox.path="m 30.561,0 -30.6875,20.03125 21.21875,17 30.9375,-19.09375 -21.46875,-17.9375 z m 21.46875,17.9375 30.96875,19.09375 21.21875,-17 -30.6875,-20.03125 -21.5,17.9375 z m 30.96875,19.09375 -30.96875,19.09375 21.5,17.9375 30.6875,-20.03125 -21.21875,-17 z m -30.96875,19.09375 -30.9375,-19.09375 -21.21875,17 30.6875,20.03125 21.46875,-17.9375 z m 0.0625,3.875 -21.53125,17.875 -9.21875,-6.03125 0,6.75 30.75,18.4375 30.78125,-18.4375 0,-6.75 -9.21875,6.03125 -21.5625,-17.875 z";
	VP.dropbox.width=104.344;
	VP.dropbox.height=97.031;
	VP.undo={};
	VP.undo.path="m 14.148,0 -14.148438,12.3535156 14.148438,13.035156 0,-8.335937 c 14.946332,-0.350494 14.262139,12.84971 9.652344,17.05664 11.806998,-6.123566 8.245989,-26.417489 -9.652344,-25.951171 l 0,-8.1582036 z";
	VP.undo.width=30.664;
	VP.undo.height=34.109;
	VP.edit={};
	VP.edit.path="m 7.198,53.472 23.6129125,18.573045 -30.810495,14.855331 7.1975825,-33.428376 z m 33.2908765,-42.291734 23.612969,18.573214 -29.134082,37.019089 -23.618303,-18.573044 29.139416,-37.019259 z m 8.794609,-11.179794 23.612969,18.573085 -4.64312,5.901916 -23.612969,-18.5730725 4.64312,-5.9019285 z";
	VP.edit.width=72.896;
	VP.edit.height=86.900;
	VP.view={};
	VP.view.path="M 191.74609 0 C 85.854776 0 -1.5158245e-013 85.854776 0 191.74609 C 0 297.63742 85.854776 383.49023 191.74609 383.49023 C 297.63742 383.49023 383.49023 297.63742 383.49023 191.74609 C 383.49023 85.854776 297.63742 9.4739031e-014 191.74609 0 z M 191.74609 47.935547 C 271.04874 47.935547 335.55469 112.44344 335.55469 191.74609 C 335.55469 271.06472 271.04874 335.55469 191.74609 335.55469 C 112.42746 335.55469 47.9375 271.06472 47.9375 191.74609 C 47.9375 112.44344 112.42746 47.935547 191.74609 47.935547 z M 644.55859 62.539062 L 644.55859 150.69922 L 556.39844 150.69922 L 556.39844 177.60547 L 644.55859 177.60547 L 644.55859 265.76562 L 671.14844 265.76562 L 671.14844 177.60547 L 759.30859 177.60547 L 759.30859 150.69922 L 671.14844 150.69922 L 671.14844 62.539062 L 644.55859 62.539062 z M 191.74609 79.894531 C 130.06802 79.894531 79.894531 130.09998 79.894531 191.74609 L 111.85156 191.74609 C 111.85156 147.69261 147.67663 111.85156 191.74609 111.85156 L 191.74609 79.894531 z M 379.94336 312.17773 C 362.4466 339.35762 339.342 362.4782 312.16211 379.95898 L 429.49414 497.27539 C 448.22126 516.00251 478.5646 516.00251 497.25977 497.27539 C 516.00287 478.5962 516.00287 448.25322 497.25977 429.49414 L 379.94336 312.17773 z M 615.19922 390.89844 L 615.19922 416.85547 L 700.50977 416.85547 L 700.50977 390.89844 L 615.19922 390.89844 z ";
	VP.view.width=759.309;
	VP.view.height=511.321;
	VP.trash = {};
	VP.trash.path="m 133.622,0 c -10.303,0 -18.6582,8.35325 -18.6582,18.65625 0,0.0257 0.004,0.0505 0.004,0.0762 l -105.80665,0 c -3.80276,0 -6.89257,6.97823 -6.89257,15.58593 0,8.6077 3.0898,15.58399 6.89257,15.58399 l 297.32422,0 c 3.822,0 6.89453,-6.96699 6.89454,-15.58399 0,-8.5983 -3.07254,-15.58593 -6.89454,-15.58593 l -105.80468,0 c 10e-5,-0.0257 0.004,-0.0505 0.004,-0.0762 0,-10.303 -8.3362,-18.65625 -18.6582,-18.65625 l -48.4043,0 z m -115.46875,66.23829 32.14453,297.77343 215.07032,0 32.12695,-297.77343 -61.72266,0 -16.55273,261.05859 -16.47461,0 16.56836,-261.05859 -53.24805,0 0,261.05859 -16.48437,0 0,-261.05859 -53.22852,0 16.56836,261.05859 -16.47266,0 -16.55273,-261.05859 -61.74219,0 z";
	VP.trash.width = 311.111;
	VP.trash.height = 364.012;
	VP.square = {};
	VP.square.path="m 1,1 10,0 0,10 -10,0 z";
	VP.square.width=12;
	VP.square.height=12;
	VP.play = {};
	VP.play.path="m 0,0 8.66025,5 -8.66025,5 z";
	VP.play.width=8.66025;
	VP.play.height=10;
	VP.circle = {};
	VP.circle.path = "m 0,50 a50,50 0 1,0 100,0 a50,50 0 1,0 -100,0";
	VP.circle.width = 100;
	VP.circle.height = 100;
	VP.pause = {};
	VP.pause.path = "m 3,3 10,0 0,30 -10,0 z m 20,0 10,0 0,30 -10,0 z";
	VP.pause.width = 36;
	VP.pause.height = 36;
	VP.connect = {};
	VP.connect.path = "m 826.025,0 C 814.60748 1.3686646 630.30431 115.91917 564.58008 164.55859 C 529.95005 190.36164 478.22903 249.11458 451.21875 293.25391 C 439.84386 312.17205 495.00662 265.39797 510.49805 262.68359 C 526.69282 259.97372 542.77022 275.55222 543.39258 288.2168 C 544.02393 299.47471 541.90041 301.56953 536.91406 311.38477 C 514.1238 355.55109 478.6513 403.15316 482.83984 408.10352 C 515.62229 451.21859 551.91211 495.76367 551.91211 495.76367 C 551.91211 495.76367 519.1331 451.94461 492.6582 412.38672 C 487.77982 405.32185 510.55268 363.96923 613.20703 259.82422 C 637.28248 234.65702 651.36206 232.6375 665.61328 203.89062 C 674.17031 185.65783 643.1478 197.41715 611.41211 210.57812 C 593.07583 218.19787 562.0298 233.47253 563.45898 229.96484 C 564.88815 226.45715 595.21285 213.99142 610.02344 207.75586 C 674.91049 180.03624 725.6458 165.5901 731.50195 129.75586 C 732.98061 118.51145 695.57667 137.96641 633.48047 169.2207 C 610.19833 180.32565 553.73859 210.20827 555.87109 206.70508 C 558.0036 203.20188 608.8108 177.503 632.80078 165.69922 C 710.4199 126.80718 766.84468 102.54985 771.28516 68.113281 C 772.73683 61.088901 714.85532 93.073922 656.25781 127.16406 C 614.60341 151.51545 549.60909 196.11473 551.74609 191.9082 C 553.8831 187.70166 623.80921 141.72751 654.87305 123.63867 C 759.36748 61.707442 822.08306 43.820194 826.58203 0.24023438 C 826.5833 0.042420625 826.39371 -0.032053696 826.02539 0.01171875 z M 936.46289 123.5625 C 917.49736 123.5625 899.66663 130.94768 886.25781 144.36523 L 780.45703 250.15625 C 758.6986 271.91177 753.51635 304.96588 767.11719 332.10938 L 789.36133 309.86523 C 786.8099 297.15754 790.40315 283.78622 799.00586 273.91797 L 798.94531 273.85547 L 800.40625 272.37891 C 800.59244 272.18399 800.79531 271.97908 800.99023 271.78125 C 801.05133 271.72305 801.10591 271.66365 801.16992 271.60547 L 801.53711 271.23633 L 907.32617 165.44336 C 915.10847 157.66107 925.45517 153.37891 936.46094 153.37891 C 947.46962 153.37891 957.81145 157.66107 965.59375 165.44336 C 981.65874 181.50544 981.65874 207.65659 965.59375 223.70703 L 857.15625 332.16016 L 857.08008 332.08398 C 849.35306 338.82476 839.62819 342.50195 829.36719 342.50195 C 826.60048 342.50195 823.86494 342.22866 821.17969 341.69336 L 798.93945 363.93555 C 808.74078 368.82603 819.61469 371.39063 830.66992 371.39062 C 849.64708 371.39062 867.4779 364.00453 880.88672 350.5957 L 986.68359 244.80078 C 1000.0953 231.38032 1007.4824 213.54848 1007.4824 194.57422 C 1007.4824 175.60578 1000.0885 157.77115 986.67969 144.36523 C 973.26795 130.94477 955.43424 123.5625 936.46289 123.5625 z M 75.992188 235.39062 C 33.27296 235.28359 -2.6053234e-014 239.72461 0 239.72461 C 0 239.72461 80.925164 233.9112 132.21484 242.67969 C 183.50453 251.44817 246.72775 263.81098 278.92383 288.63477 C 311.11991 313.45855 314.21792 378.89192 330.72461 437.37695 C 342.42042 478.24704 422.45256 501.96834 494.01758 529.85742 C 494.01758 529.85742 394.42755 484.90848 364.98633 469.24609 C 322.92552 447.17267 333.09961 395.89258 333.09961 395.89258 C 333.09961 395.89258 333.98765 367.06106 381.25977 344.15234 C 362.4541 315.19401 354.67261 322.17715 339.91602 319.97266 C 325.15942 317.76817 304.86667 301.46071 311.30469 284.62109 C 322.03022 257.25839 394.40194 268.97466 401.06641 326.69336 C 406.03026 320.39482 402.77452 279.58002 369.11328 263.89062 C 335.44753 248.90458 297.38531 261.32199 267.84961 260.42969 C 238.31841 258.83406 167.37648 243.6082 137.86328 239.19922 C 116.78001 236.42673 95.410018 235.43928 75.992188 235.39062 z M 510.86719 270.4375 C 510.16385 270.4335 510.16075 271.13455 510.15625 271.83789 L 510.12891 276.05859 C 509.42557 276.05359 508.71701 276.75255 508.01367 276.74805 L 508.01953 276.04492 C 508.02453 275.34158 507.31972 275.33811 507.32422 274.63477 L 505.92773 273.21875 C 505.93173 272.51542 505.22737 272.51015 504.51953 273.20898 C 503.81619 273.20398 503.81309 273.90799 503.80859 274.61133 C 503.80359 275.31467 504.50195 276.02344 504.50195 276.02344 C 504.49695 276.72678 505.20177 276.73025 505.19727 277.43359 L 505.19141 278.13672 C 504.48358 278.83556 503.77989 278.83182 503.77539 279.53516 L 503.07227 279.5293 C 502.36893 279.5243 502.37325 278.82286 501.66992 278.81836 C 500.96658 278.81436 500.97092 278.10997 500.26758 278.10547 C 499.56424 278.10047 498.86133 278.0957 498.86133 278.0957 C 498.1535 278.79454 498.85156 279.50391 498.85156 279.50391 L 502.3457 283.04297 C 501.63786 283.74181 501.63361 284.44374 500.92578 285.14258 L 500.22266 285.13867 C 499.51932 285.13367 498.81581 285.12912 498.82031 284.42578 C 498.11697 284.42078 497.41368 284.41681 496.71484 283.70898 C 496.0115 283.70398 495.30919 283.70096 495.30469 284.4043 C 495.29969 285.10764 495.29471 285.80995 495.99805 285.81445 C 496.70139 285.81945 497.40039 286.52734 497.40039 286.52734 C 498.10373 286.53234 498.09939 287.23379 498.80273 287.23828 L 499.50586 287.24414 C 499.50186 287.94748 499.49669 288.65018 499.49219 289.35352 L 498.78906 289.34961 C 498.08572 289.34461 497.38281 289.33984 497.38281 289.33984 C 496.67948 289.33484 495.97678 289.33067 495.27344 289.32617 C 494.5701 289.32117 494.56505 290.02518 494.56055 290.72852 C 494.55555 291.43186 495.25391 292.14062 495.25391 292.14062 L 499.47461 292.16797 L 499.45703 294.98047 L 498.75391 294.97461 C 498.05057 294.96961 498.04514 295.67442 497.3418 295.66992 C 496.62947 297.0721 496.62971 297.07264 495.92188 297.77148 C 495.21854 297.76648 495.21348 298.47049 495.20898 299.17383 C 495.20398 299.87716 495.90799 299.88027 496.61133 299.88477 C 497.31467 299.88977 498.02323 299.19081 498.72656 299.19531 C 499.4299 299.20031 500.13222 299.20529 500.13672 298.50195 L 500.8418 298.50586 C 501.54064 299.2137 501.53554 299.91716 502.23438 300.625 L 501.52539 301.32422 L 500.11133 302.72266 L 498.69531 304.11914 C 497.98747 304.81798 497.98221 305.52089 498.68555 305.52539 C 499.38439 306.23323 499.38396 306.234 500.0918 305.53516 L 501.50781 304.13672 C 502.21115 304.14172 502.21658 303.43886 502.91992 303.44336 L 503.62305 303.44727 C 504.32188 304.15511 505.02577 304.16131 505.72461 304.86914 L 505.71875 305.57227 C 505.71375 306.27561 505.01036 306.27127 505.00586 306.97461 C 505.00086 307.67795 504.29492 308.375 504.29492 308.375 C 504.28992 309.07833 504.28494 309.78261 504.98828 309.78711 C 505.69162 309.79211 506.39453 309.79688 506.39453 309.79688 C 507.10236 309.09803 507.10742 308.39453 507.10742 308.39453 C 507.11242 307.69119 507.81581 307.69553 507.82031 306.99219 L 507.82422 306.28906 C 508.52756 306.29406 509.22635 307.00136 509.92969 307.00586 L 509.9043 311.22461 C 509.8993 311.92795 510.59766 312.63672 510.59766 312.63672 C 511.301 312.64172 512.00527 312.64475 512.00977 311.94141 C 512.01477 311.23808 512.01872 310.53478 512.72656 309.83594 C 512.73156 309.1326 512.73417 308.42909 513.4375 308.43359 L 513.44336 307.73047 C 514.1467 307.73547 514.84939 307.73964 515.55273 307.74414 L 515.54883 308.44727 C 515.54483 309.15061 515.54385 309.15155 516.24219 309.85938 C 516.23719 310.56272 516.93614 311.26932 516.93164 311.97266 C 516.92664 312.676 517.63064 312.68105 518.33398 312.68555 C 519.03731 312.69055 519.04238 311.98653 519.04688 311.2832 C 519.05187 310.57986 519.05605 309.87717 519.06055 309.17383 C 519.06555 308.47049 519.06836 307.76758 519.06836 307.76758 L 519.07422 307.06445 C 519.77755 307.06945 520.48611 306.36855 521.18945 306.37305 L 521.18359 307.07812 C 521.17859 307.78146 521.88341 307.78494 521.87891 308.48828 L 523.27539 309.9043 C 523.97423 310.61214 523.97381 310.61095 524.68164 309.91211 C 525.38498 309.91711 525.39003 309.21505 525.39453 308.51172 C 525.39953 307.80838 524.70117 307.09961 524.70117 307.09961 C 524.70617 306.39627 524.00136 306.39278 524.00586 305.68945 L 524.01172 304.98438 C 524.71956 304.28553 525.42323 304.29123 525.42773 303.58789 L 526.13086 303.5918 C 526.8342 303.5968 526.82986 304.3002 527.5332 304.30469 C 528.23654 304.30869 528.23025 305.01308 528.93359 305.01758 C 529.63692 305.02258 530.3418 305.02539 530.3418 305.02539 C 531.04964 304.32655 530.34961 303.61914 530.34961 303.61914 L 528.95312 302.20312 L 527.55469 300.78906 L 526.85547 300.08008 C 527.56331 299.38124 527.56755 298.67736 528.27539 297.97852 L 528.98047 297.98438 C 529.6838 297.98937 530.38536 297.99393 530.38086 298.69727 C 531.0842 298.70127 531.78749 298.70623 532.48633 299.41406 C 533.18967 299.41906 533.89394 299.42209 533.89844 298.71875 C 533.90344 298.01541 533.90646 297.31309 533.20312 297.30859 C 532.49979 297.30359 531.80273 296.5957 531.80273 296.5957 C 531.09939 296.5907 531.10373 295.88731 530.40039 295.88281 L 529.69727 295.87891 C 529.70227 295.17557 529.70448 294.47287 529.70898 293.76953 L 533.92969 293.79688 C 534.63302 293.80088 534.63808 293.09787 534.64258 292.39453 C 534.64758 291.69119 534.65587 290.284 533.95703 289.57617 L 533.95508 289.57617 C 533.25174 289.57117 532.54903 289.567 531.8457 289.5625 C 531.14236 289.5575 530.43945 289.55469 530.43945 289.55469 L 529.73633 289.54883 C 529.74133 288.8455 529.74014 288.84592 529.74414 288.14258 C 529.74814 287.43924 529.74891 287.43967 529.75391 286.73633 L 530.45703 286.74023 C 531.16036 286.74523 531.1658 286.04237 531.86914 286.04688 C 532.57248 286.05187 533.2793 285.35156 533.2793 285.35156 C 533.98263 285.35656 533.98769 284.65256 533.99219 283.94922 C 533.99719 283.24589 533.29318 283.24083 532.58984 283.23633 C 531.88651 283.23133 531.17795 283.93223 530.47461 283.92773 C 529.77127 283.92273 529.06895 283.91775 529.06445 284.62109 L 528.36133 284.61719 C 527.66249 283.90935 527.66564 283.20588 526.9668 282.49805 L 527.67578 281.79883 L 529.0918 280.40039 L 530.50586 279.00391 C 531.2137 278.30507 531.21896 277.6002 530.51562 277.5957 C 529.81679 276.88786 529.8172 276.88905 529.10938 277.58789 L 527.69336 278.98438 C 526.99002 278.97938 526.98458 279.68419 526.28125 279.67969 L 525.57812 279.67383 C 524.87929 278.96599 524.17736 278.96175 523.47852 278.25391 L 523.48242 277.55078 C 523.48742 276.84744 524.19081 276.85178 524.19531 276.14844 C 524.20031 275.4451 524.9082 274.74609 524.9082 274.74609 C 524.9132 274.04275 524.91623 273.34044 524.21289 273.33594 C 523.50956 273.33094 522.80664 273.32617 522.80664 273.32617 C 522.0988 274.02501 522.09375 274.72852 522.09375 274.72852 C 522.08875 275.43185 521.38535 275.42753 521.38086 276.13086 L 521.37695 276.83398 C 520.67361 276.82898 519.97482 276.12169 519.27148 276.11719 L 519.27539 275.41406 C 519.28039 274.71072 519.28516 274.00781 519.28516 274.00781 C 519.29016 273.30447 519.29433 272.59982 519.29883 271.89648 C 519.30283 271.19314 518.60352 270.48633 518.60352 270.48633 C 517.90018 270.48133 517.19786 270.47635 517.19336 271.17969 C 517.18836 271.88303 517.18439 272.58632 516.47656 273.28516 C 516.47156 273.9885 516.46701 274.69199 515.76367 274.6875 L 515.75977 275.39062 C 515.05643 275.38563 514.35177 275.38341 513.64844 275.37891 L 513.6543 274.67383 C 513.6583 273.97049 513.65732 273.97151 512.95898 273.26367 C 512.96298 272.56034 512.26504 271.85178 512.26953 271.14844 C 512.27453 270.4451 511.57053 270.442 510.86719 270.4375 z M 336.4707 278.40039 C 333.54409 278.47783 330.67561 279.99678 328.90039 282.62305 L 345.72266 291.875 C 347.15633 287.66397 345.78212 282.73098 341.58008 279.89062 C 340.00432 278.8255 338.22667 278.35392 336.4707 278.40039 z M 327.48047 284.72461 C 325.34346 288.93114 327.42318 293.86728 330.92188 296.70312 C 335.83174 298.84464 341.46688 297.47525 344.30273 293.97656 L 327.48047 284.72461 z M 852.31836 287.04883 C 833.35574 287.05183 815.52111 294.43784 802.10938 307.84375 L 696.31836 413.64258 C 682.9008 427.0485 675.51563 444.88217 675.51562 463.85352 C 675.51562 482.83359 682.90857 500.66439 696.32031 514.07031 C 709.72913 527.47622 727.56572 534.86527 746.53125 534.87109 L 746.53711 534.87109 C 765.50555 534.87109 783.33336 527.48204 796.74219 514.07031 L 902.54102 408.26953 C 924.31399 386.49656 929.48436 353.41685 915.8457 326.26172 L 892.61719 349.49219 C 895.50319 363.06975 891.32926 377.32799 881.47266 387.1875 L 773.01367 495.63672 L 772.93945 495.57031 C 765.22407 502.30818 755.48074 505.98242 745.22266 505.98242 C 734.26053 505.98242 723.99879 501.75569 716.3125 494.07812 C 708.51275 486.28129 704.2986 475.86831 704.40625 464.75781 C 704.51098 454.64519 708.19017 445.05301 714.83203 437.43945 L 714.77148 437.38281 L 716.25781 435.88281 C 716.45273 435.67626 716.65668 435.46445 716.85742 435.26953 C 716.91852 435.20843 716.98187 435.14221 717.04297 435.08984 L 717.40039 434.72656 L 823.19336 328.92773 C 830.97857 321.15125 841.31932 316.87109 852.31055 316.87109 C 855.1529 316.87109 857.97451 317.16515 860.74414 317.73828 L 883.99805 294.47852 C 874.22291 289.60258 863.35032 287.04883 852.31836 287.04883 z M 514.82812 287.87891 C 516.18508 287.71449 517.86904 289.03456 518.47266 290.88477 C 519.1625 292.99928 517.74282 295.09943 515.63281 295.08594 C 513.5183 295.77578 511.41814 294.35611 511.43164 292.24609 C 510.7418 290.13158 512.16147 288.02947 514.27148 288.04297 C 514.44788 287.95618 514.63427 287.90239 514.82812 287.87891 z M 396.66016 356.19922 C 396.66016 356.19922 395.95567 356.1946 395.95117 356.89844 L 395.92383 361.11719 C 395.22049 361.11219 394.51838 361.1078 393.81055 361.80664 C 393.11621 360.39547 393.12461 358.98908 392.42578 358.28125 C 392.42578 358.28125 392.4294 357.57872 391.72656 357.57422 L 391.02344 357.56836 C 391.02344 357.56836 390.32091 357.56374 390.31641 358.26758 L 390.31055 358.9707 C 390.31055 358.9707 390.29784 361.08101 390.99219 362.49219 C 390.28885 362.48719 389.58029 363.18614 388.87695 363.18164 C 388.18261 361.77046 387.48964 360.35959 387.49414 359.65625 L 386.79492 358.94922 L 386.0918 358.94336 C 386.0918 358.94336 385.38731 358.93874 385.38281 359.64258 L 385.37891 360.3457 C 385.37891 360.3457 386.06759 362.46051 386.05859 363.86719 C 385.35525 363.86219 384.64865 364.56114 383.94531 364.55664 L 382.55664 361.73438 L 381.85742 361.02734 L 381.1543 361.02148 C 381.1543 361.02148 380.44981 361.01786 380.44531 361.7207 L 380.44141 362.42383 C 380.44141 362.42383 381.13183 364.53804 381.82617 365.94922 C 381.28385 365.94536 380.73897 366.3625 380.19336 366.87305 C 379.98997 366.96105 379.79349 367.05979 379.5918 367.15039 C 378.87181 365.80697 377.61523 364.51562 377.61523 364.51562 L 376.91602 363.80859 L 376.21289 363.80273 L 375.50586 364.50195 L 375.5 365.20508 C 375.5 365.20508 376.13039 367.11722 376.79102 368.51953 C 376.03489 368.92005 375.29119 369.33811 374.5625 369.77539 C 373.83063 368.59486 372.66973 367.93856 372.67383 367.29688 L 371.97461 366.58984 L 371.27148 366.58398 L 370.5625 367.2832 L 370.55859 367.98633 C 370.55859 367.98633 371.25271 369.39682 372.65039 370.8125 C 371.94255 371.51134 371.23908 371.50819 370.53125 372.20703 C 369.13357 370.79135 368.43381 370.08263 367.73047 370.07812 L 367.02734 370.07422 L 366.32422 370.07031 L 365.61719 370.76758 L 365.61133 371.47266 C 365.61133 371.47266 367.00879 372.88765 367.70312 374.29883 L 366.28906 375.69531 C 364.88689 374.98298 363.48828 373.56836 363.48828 373.56836 L 362.78516 373.56445 C 362.78516 373.56445 362.08067 373.55984 362.07617 374.26367 L 362.06836 375.66992 C 362.06836 375.66992 363.33161 376.96602 364.05078 378.3125 C 363.43548 378.97587 362.83772 379.65437 362.26172 380.34961 C 361.03918 379.72011 359.93548 379.09039 359.93945 378.46875 L 359.23633 378.46484 C 359.23633 378.46484 358.5338 378.46022 358.5293 379.16406 L 358.52344 379.86719 C 358.52344 379.86719 358.51982 380.56972 359.22266 380.57422 C 359.22266 380.57422 359.98089 381.33811 360.93555 382.02539 C 360.39528 382.73926 359.8706 383.46327 359.37109 384.20508 C 358.44219 383.75601 357.58239 383.37812 357.09375 383.375 L 356.39062 383.36914 C 356.39062 383.36914 355.68809 383.36452 355.68359 384.06836 L 355.67773 384.77148 C 355.67773 384.77148 355.67311 385.47402 356.37695 385.47852 C 356.37695 385.47852 356.99541 386.08617 357.79883 386.70312 C 357.33809 387.486 356.90447 388.28428 356.48828 389.0918 C 355.5747 388.65162 354.73203 388.28237 354.25 388.2793 L 353.54688 388.27344 C 353.54688 388.27344 352.84239 388.26882 352.83789 388.97266 L 352.83398 389.67578 C 352.83398 389.67578 352.82741 390.38027 353.53125 390.38477 C 353.53125 390.38477 354.52486 390.73259 355.37305 391.4043 C 354.93088 392.38652 354.51493 393.38156 354.13867 394.39258 C 353.29963 394.17985 352.55298 393.89545 352.10352 393.89258 L 351.40039 393.88672 L 350.69141 394.58594 L 350.6875 395.28906 C 350.6875 395.28906 350.68193 395.99159 351.38477 395.99609 C 351.38477 395.99609 352.30878 396.31805 353.33008 396.73242 C 353.06122 397.58636 352.82097 398.45051 352.59961 399.32031 C 351.58105 399.10558 350.66406 398.80664 350.66406 398.80664 L 349.96094 398.80273 L 349.25391 399.5 L 349.24805 400.20312 L 349.94727 400.91211 C 349.94727 400.91211 350.96971 401.26372 352.05859 401.71289 C 351.87747 402.61512 351.7269 403.5245 351.59766 404.43945 L 349.2207 404.42383 L 348.51758 404.41992 L 347.81055 405.11719 L 347.80469 405.82031 L 348.50391 406.5293 C 348.50391 406.5293 349.98166 407.02916 351.28906 407.19727 C 351.22992 407.91542 351.18672 408.6359 351.16016 409.35938 L 348.48633 409.3418 C 348.48633 409.3418 347.78183 409.33718 347.77734 410.04102 L 347.76953 411.44727 L 348.4668 412.15625 L 351.13672 412.17188 C 351.15286 412.8924 351.18906 413.61431 351.23828 414.33789 C 349.93029 414.49004 348.44922 414.96875 348.44922 414.96875 C 348.44922 414.96875 347.74669 414.96413 347.74219 415.66797 L 347.73633 416.37109 C 347.73633 416.37109 347.73271 417.07558 348.43555 417.08008 L 351.50195 417.09766 C 351.61352 417.97868 351.74607 418.85989 351.9082 419.74219 C 351.04762 419.98611 350.28068 420.15095 349.82031 420.60547 C 349.82031 420.60547 349.11583 420.59889 349.11133 421.30273 L 349.10742 422.00781 C 349.10742 422.00781 349.1028 422.71034 349.80664 422.71484 L 350.50977 422.7207 C 350.50977 422.7207 351.48804 422.70761 352.55078 422.49609 C 352.76205 423.29056 352.99219 424.07525 353.24023 424.84961 C 352.40364 425.23161 351.64209 425.53997 351.19531 425.53711 L 350.48633 426.23633 L 350.48242 426.93945 C 350.48242 426.93945 350.47585 427.64394 351.17969 427.64844 L 351.88477 427.65234 C 351.88477 427.65234 352.92767 427.32086 354.03125 427.12109 C 354.34723 427.96173 354.68821 428.78772 355.04688 429.60156 L 353.27344 430.47461 L 352.56445 431.17383 L 352.56055 431.87695 C 352.56055 431.87695 352.55593 432.58144 353.25977 432.58594 L 353.96289 432.58984 C 353.96289 432.58984 354.99315 432.24881 356.08984 431.8125 C 356.50984 432.64756 356.95568 433.46469 357.41992 434.26758 C 356.64654 434.85427 356.05469 435.41602 356.05469 435.41602 L 355.34766 436.11523 L 355.3418 436.81836 L 356.04102 437.52734 L 356.74414 437.53125 C 356.74414 437.53125 357.81883 437.17741 358.94336 436.72656 C 359.46382 437.51299 360.00187 438.28493 360.56445 439.03516 C 359.8337 439.68191 359.32544 440.36251 358.83594 440.35938 L 358.12891 441.05859 L 358.12305 441.76172 L 358.82227 442.46875 L 359.52539 442.47461 C 359.52539 442.47461 360.66691 441.88257 361.92188 440.75977 C 362.45868 441.41135 363.00993 442.04769 363.57812 442.66797 C 362.28744 443.94361 361.62148 444.62921 361.61719 445.30078 L 361.60938 446.70703 L 362.30664 447.41602 L 363.01172 447.41992 C 363.01172 447.41992 364.42672 446.02246 365.83789 445.32812 L 367.23633 446.74219 C 366.524 448.14437 365.10742 449.54297 365.10742 449.54297 L 365.10156 450.24609 C 365.10156 450.24609 365.09694 450.94862 365.80078 450.95312 L 367.20703 450.96289 C 367.20703 450.96289 368.62398 449.56543 370.03516 448.87109 C 370.734 449.57893 371.43593 449.58319 372.13477 450.29102 C 371.42244 451.6932 370.71115 453.0963 370.00781 453.0918 L 370.00195 453.79492 C 370.00195 453.79492 369.99833 454.49745 370.70117 454.50195 L 371.4043 454.50781 C 371.4043 454.50781 372.10878 454.51143 372.11328 453.80859 C 372.11328 453.80859 373.32014 452.59255 374.06445 451.29492 C 374.79011 451.73803 375.52367 452.16589 376.27148 452.57031 C 375.58525 453.92196 374.91645 455.25713 374.91211 455.93555 L 374.9082 456.63867 C 374.9082 456.63867 374.90263 457.34316 375.60547 457.34766 L 376.31055 457.35156 C 376.31055 457.35156 377.01308 457.35814 377.01758 456.6543 C 377.01758 456.6543 378.34956 455.32793 379.07812 453.96484 C 379.23247 454.03586 379.38786 454.10442 379.54297 454.17383 C 380.11047 454.57237 380.67972 454.69976 381.24609 455.27344 C 380.53376 456.67561 380.5262 458.08241 379.81836 458.78125 L 379.8125 459.48438 C 379.8125 459.48438 379.80888 460.18886 380.51172 460.19336 L 381.21484 460.19727 C 381.21484 460.19727 381.91738 460.20189 381.92188 459.49805 C 381.92188 459.49805 382.6396 457.39356 384.05078 456.69922 C 384.75412 456.70422 385.45292 457.41152 386.15625 457.41602 C 386.14725 458.8227 385.43419 460.2244 385.42969 460.92773 L 385.42578 461.63086 L 386.125 462.33984 L 386.82812 462.34375 C 386.82812 462.34375 387.53261 462.34837 387.53711 461.64453 C 387.53711 461.64453 388.2525 459.54084 388.96484 458.13867 C 389.66817 458.14367 390.36697 458.85097 391.07031 458.85547 C 391.06131 460.26215 390.3457 462.36719 390.3457 462.36719 L 390.33984 463.07031 L 391.03906 463.77734 L 391.74219 463.7832 L 392.44922 463.08398 C 392.44922 463.08398 393.16658 460.97834 393.87891 459.57617 C 394.58225 459.58017 395.28554 459.58514 395.98438 460.29297 L 395.95703 464.51367 L 396.65625 465.2207 L 397.35938 465.22461 L 398.06836 464.52539 C 398.06836 464.52539 398.78397 462.42035 398.79297 461.01367 C 399.49631 461.01867 400.20096 461.02284 400.9043 461.02734 L 400.88086 464.54492 C 400.88086 464.54492 400.87624 465.24745 401.58008 465.25195 L 402.98633 465.26172 L 403.69531 464.5625 L 403.7168 461.04492 C 404.42014 461.04992 405.12283 461.05409 405.82617 461.05859 C 405.81717 462.46527 406.50781 464.58008 406.50781 464.58008 C 406.50781 464.58008 406.5032 465.28456 407.20703 465.28906 L 407.91016 465.29297 C 407.91016 465.29297 408.61269 465.29759 408.61719 464.59375 L 408.62109 463.89062 L 408.64453 460.375 C 409.34787 460.38 410.05193 460.38243 410.75977 459.68359 C 411.45411 461.09477 411.44374 462.5031 412.14258 463.21094 C 412.14258 463.21094 412.13796 463.91347 412.8418 463.91797 L 413.54492 463.92383 C 413.54492 463.92383 414.24941 463.92745 414.25391 463.22461 L 414.25781 462.52148 C 414.25781 462.52148 414.27246 460.41117 413.57812 459 C 414.28146 459.005 414.98807 458.30605 415.69141 458.31055 C 416.38575 459.72172 417.08067 461.1326 417.07617 461.83594 L 417.77539 462.54297 L 418.47852 462.54883 C 418.47852 462.54883 419.18105 462.55345 419.18555 461.84961 L 419.18945 461.14648 C 419.18945 461.14648 418.50077 459.03167 418.50977 457.625 C 419.21311 457.63 419.91972 456.93105 420.62305 456.93555 L 422.01172 459.75781 L 422.71094 460.46484 L 423.41406 460.4707 C 423.41406 460.4707 424.11855 460.47532 424.12305 459.77148 L 424.12695 459.06836 C 424.12695 459.06836 423.43653 456.95414 422.74219 455.54297 C 423.44552 455.54797 424.15349 454.84728 424.86133 454.14844 C 425.55567 455.55961 426.95508 456.97656 426.95508 456.97656 L 427.65234 457.68359 L 428.35547 457.68945 L 429.06445 456.99023 L 429.06836 456.28711 C 429.06836 456.28711 428.37989 454.17289 427.68555 452.76172 C 428.39339 452.06288 429.09685 452.06603 429.80469 451.36719 C 430.49903 452.77836 431.90098 453.49197 431.89648 454.19531 L 432.5957 454.90234 L 433.29883 454.9082 L 434.00586 454.20898 L 434.01172 453.50586 C 434.01172 453.50586 433.3176 452.0934 431.91992 450.67773 C 432.62776 449.97889 433.32927 449.984 434.03711 449.28516 C 435.43478 450.70083 436.13455 451.40956 436.83789 451.41406 L 438.24414 451.42188 L 438.95312 450.72266 L 438.95703 450.01953 C 438.95703 450.01953 437.55957 448.60453 436.86523 447.19336 L 438.28125 445.79492 C 439.68343 446.50726 441.08008 447.92383 441.08008 447.92383 L 441.78516 447.92773 C 441.78516 447.92773 442.48769 447.93431 442.49219 447.23047 L 442.49609 446.52734 L 442.50195 445.82227 C 442.50195 445.82227 441.1045 444.40726 440.41016 442.99609 C 441.118 442.29725 441.12224 441.59337 441.83008 440.89453 C 443.23226 441.60687 444.63536 442.3201 444.63086 443.02344 L 445.33398 443.02734 C 445.33398 443.02734 446.03652 443.03392 446.04102 442.33008 L 446.04688 441.62695 C 446.04688 441.62695 446.0515 440.92246 445.34766 440.91797 C 445.34766 440.91797 443.94904 439.50335 442.54688 438.79102 C 443.2547 438.09218 443.25896 437.38829 443.9668 436.68945 C 445.36898 437.40179 446.77127 438.11464 447.47461 438.11914 L 448.17969 438.12305 C 448.17969 438.12305 448.88222 438.12767 448.88672 437.42383 L 448.89062 436.7207 C 448.89062 436.7207 448.8962 436.01816 448.19336 436.01367 C 448.19336 436.01367 446.79476 434.5971 445.39258 433.88477 C 446.10042 433.18593 446.10467 432.484 446.8125 431.78516 C 448.21468 432.4975 449.62147 432.50505 450.32031 433.21289 L 451.02344 433.21875 C 451.02344 433.21875 451.72792 433.22337 451.73242 432.51953 L 451.73633 431.81641 C 451.73633 431.81641 451.74095 431.11386 451.03711 431.10938 C 451.03711 431.10938 448.93067 430.39164 448.23633 428.98047 C 448.24133 428.27713 448.94863 427.57834 448.95312 426.875 C 450.3598 426.884 452.4668 427.60156 452.4668 427.60156 L 453.16992 427.60547 L 453.87695 426.90625 L 453.88281 426.20312 C 453.88281 426.20312 453.88743 425.50059 453.18359 425.49609 C 453.18359 425.49609 451.07795 424.77874 449.67578 424.06641 C 449.67978 423.36307 450.38808 422.66428 450.39258 421.96094 C 451.79926 421.96994 453.9043 422.6875 453.9043 422.6875 L 454.60742 422.69141 L 455.31641 421.99219 L 455.32031 421.28906 L 454.62109 420.58008 C 454.62109 420.58008 452.51546 419.86468 451.11328 419.15234 C 451.11828 418.449 451.12224 417.74572 451.83008 417.04688 L 456.05078 417.07227 L 456.75781 416.375 L 456.76367 415.67188 L 456.06445 414.96289 C 456.06445 414.96289 453.95941 414.24728 452.55273 414.23828 C 452.55773 413.53494 452.56191 412.83029 452.56641 412.12695 L 456.08203 412.15039 C 456.08203 412.15039 456.78652 412.15501 456.79102 411.45117 L 456.79492 410.74805 L 456.79883 410.04492 L 456.09961 409.33594 L 452.58398 409.31445 C 452.58798 408.61111 452.59316 407.90646 452.59766 407.20312 C 454.00434 407.21213 456.11914 406.52344 456.11914 406.52344 C 456.11914 406.52344 456.82167 406.52806 456.82617 405.82422 L 456.83203 405.12109 C 456.83203 405.12109 456.83665 404.41856 456.13281 404.41406 L 455.42969 404.4082 L 451.91211 404.38672 C 451.91711 403.68338 451.9215 402.97931 451.22266 402.27148 C 452.63383 401.57714 454.74805 400.88867 454.74805 400.88867 L 454.75 400.89062 C 455.45783 400.19178 455.46289 399.48828 455.46289 399.48828 C 455.46289 399.48828 455.46751 398.78575 454.76367 398.78125 L 454.06055 398.77539 C 454.06055 398.77539 451.95023 398.76268 450.53906 399.45703 C 450.54406 398.75369 449.84511 398.04514 449.84961 397.3418 C 451.26078 396.64746 452.67167 395.95448 453.375 395.95898 L 454.08398 395.25977 L 454.08789 394.55664 C 454.08789 394.55664 454.09251 393.85216 453.38867 393.84766 L 452.68555 393.84375 C 452.68555 393.84375 450.57074 394.53244 449.16406 394.52344 C 449.16906 393.8201 448.47011 393.1135 448.47461 392.41016 L 451.29688 391.02148 L 452.00586 390.32227 L 452.00977 389.61914 C 452.00977 389.61914 452.01439 388.91465 451.31055 388.91016 L 450.60742 388.90625 C 450.60742 388.90625 448.49321 389.59472 447.08203 390.28906 C 447.08703 389.58572 446.38828 388.87775 445.68945 388.16992 C 447.10062 387.47558 448.51562 386.07812 448.51562 386.07812 L 449.22461 385.38086 L 449.22852 384.67578 L 448.5293 383.96875 L 447.82617 383.96289 C 447.82617 383.96289 445.71195 384.65332 444.30078 385.34766 C 443.60194 384.63982 443.60704 383.93636 442.9082 383.22852 C 444.31937 382.53418 445.03104 381.13222 445.73438 381.13672 L 446.44336 380.4375 L 446.44727 379.73438 L 445.74805 379.02734 L 445.04492 379.02148 C 445.04492 379.02148 443.63442 379.7156 442.21875 381.11328 C 441.51991 380.40544 441.52501 379.70198 440.82617 378.99414 C 441.5385 377.59196 442.94863 376.89865 442.95312 376.19531 L 442.95898 375.49219 L 442.96289 374.78906 L 442.26367 374.08008 L 441.56055 374.07617 C 441.56055 374.07617 440.14554 375.47363 438.73438 376.16797 L 437.33594 374.75195 C 438.04828 373.34977 439.46289 371.95117 439.46289 371.95117 L 439.46875 371.24805 C 439.46875 371.24805 439.47337 370.54551 438.76953 370.54102 L 438.06641 370.53516 L 437.36328 370.53125 C 437.36328 370.53125 435.94828 371.92871 434.53711 372.62305 C 433.83827 371.91521 433.13439 371.91097 432.43555 371.20312 C 433.14789 369.80096 433.85916 368.39784 434.5625 368.40234 L 434.56836 367.69922 C 434.56836 367.69922 434.57298 366.99669 433.86914 366.99219 L 433.16602 366.98633 C 433.16602 366.98633 432.46348 366.98271 432.45898 367.68555 C 432.45898 367.68555 431.04242 369.08415 430.33008 370.48633 C 429.63125 369.77849 428.92736 369.77228 428.22852 369.06445 C 428.94085 367.66227 429.6537 366.25998 429.6582 365.55664 L 429.66211 364.85352 C 429.66211 364.85352 429.66673 364.15098 428.96289 364.14648 L 428.25977 364.14062 C 428.25977 364.14062 427.55723 364.137 427.55273 364.83984 C 427.55273 364.83984 426.13617 366.23846 425.42383 367.64062 C 424.725 366.9328 424.02306 366.92854 423.32422 366.2207 C 424.03655 364.81852 424.04411 363.41173 424.75195 362.71289 L 424.75586 362.00977 C 424.75586 362.00977 424.76243 361.30528 424.05859 361.30078 L 423.35352 361.29688 C 423.35352 361.29688 422.65098 361.2913 422.64648 361.99414 C 422.64648 361.99414 421.93071 364.10058 420.51953 364.79492 C 419.8162 364.78992 419.1174 364.08263 418.41406 364.07812 C 418.42306 362.67146 419.13867 360.56641 419.13867 360.56641 L 419.14453 359.86328 L 418.44531 359.1543 L 417.74219 359.15039 C 417.74219 359.15039 417.0377 359.14382 417.0332 359.84766 C 417.0332 359.84766 416.3178 361.95329 415.60547 363.35547 C 414.90213 363.35047 414.20334 362.64317 413.5 362.63867 C 413.509 361.232 414.22461 359.12695 414.22461 359.12695 L 414.22852 358.42383 L 413.5293 357.7168 L 412.82617 357.71094 L 412.11914 358.41016 C 412.11914 358.41016 411.40178 360.51579 410.68945 361.91797 C 409.98611 361.91297 409.28282 361.909 408.58398 361.20117 L 408.60742 357.68359 L 408.61133 356.98047 L 407.91211 356.27344 L 407.20898 356.26758 L 406.50195 356.9668 C 406.50195 356.9668 405.78439 359.07185 405.77539 360.47852 C 405.07205 360.47352 404.36935 360.46934 403.66602 360.46484 L 403.68945 356.94922 C 403.68945 356.94922 403.69407 356.24473 402.99023 356.24023 L 402.28711 356.23633 L 401.58203 356.23047 L 400.875 356.92969 L 400.85352 360.44531 C 400.15019 360.44031 399.44553 360.43809 398.74219 360.43359 C 398.75119 359.02692 398.0625 356.91211 398.0625 356.91211 C 398.0625 356.91211 398.06712 356.20761 397.36328 356.20312 L 396.66016 356.19922 z M 398.23047 391.68555 C 407.22175 391.68536 415.03097 397.73537 417.43359 406.98242 C 420.17946 417.55049 413.07919 428.05513 402.51562 430.09766 C 391.95206 432.14019 382.14431 425.74776 379.39844 415.17969 C 377.35591 404.61613 383.75029 394.81031 394.31836 392.06445 C 395.6388 391.80914 396.946 391.68557 398.23047 391.68555 z M 397.92578 394.02344 C 390.03812 394.37687 382.92444 400.25523 382.25391 408.86719 C 380.78874 418.00158 387.06011 427.1868 396.90234 427.95312 C 405.3334 429.4138 414.52116 422.43712 415.98633 413.30273 C 417.45149 404.16833 411.18012 394.98508 401.33789 394.21875 C 400.19609 394.03561 399.05259 393.97295 397.92578 394.02344 z M 398.51367 395.7832 C 399.39284 395.78883 400.27146 395.9697 401.32422 396.32812 C 408.34861 397.77978 413.23054 404.1424 413.18555 411.17578 L 405.45898 409.71875 C 404.77364 406.9009 402.67604 404.77797 399.86719 404.05664 C 399.16385 404.05164 398.46094 404.04688 398.46094 404.04688 L 395.69727 396.29297 C 396.75452 395.94805 397.6345 395.77758 398.51367 395.7832 z M 391.46289 398.37695 L 394.22852 406.13086 C 392.81734 406.8252 392.09906 408.92985 391.38672 410.33203 C 391.37772 411.73871 391.36404 413.84995 392.76172 415.26562 L 387.79883 421.56445 C 385.71131 418.03427 383.63295 413.09639 384.36328 408.88086 C 385.09811 403.962 387.93271 400.46447 391.46289 398.37695 z M 399.14258 407.56836 C 401.24809 408.28519 401.94259 409.69685 401.93359 411.10352 C 401.92459 412.5102 399.80511 413.90353 398.39844 413.89453 C 396.99176 413.88553 395.59842 411.76605 395.60742 410.35938 C 395.61642 408.95271 397.7359 407.55936 399.14258 407.56836 z M 404.73242 413.23242 L 412.46094 414.6875 C 411.00927 421.71188 403.9488 425.887 396.91992 425.13867 C 394.8099 425.12517 393.40766 424.41237 391.30664 422.99219 L 396.26953 416.69336 C 396.97286 416.69836 396.96855 417.40175 397.67188 417.40625 C 400.48073 418.12758 403.30775 416.03678 404.73242 413.23242 z M 526.60156 494.19336 C 525.89822 494.18836 525.89317 494.89236 525.88867 495.5957 L 525.86133 499.81641 C 525.15799 499.81241 524.45139 500.51036 523.74805 500.50586 L 523.75195 499.80273 C 523.75695 499.09939 523.05409 499.09396 523.05859 498.39062 L 521.66016 496.97656 C 521.66516 496.27322 520.96174 496.26796 520.25391 496.9668 C 519.55057 496.9618 519.54552 497.6658 519.54102 498.36914 C 519.53602 499.07247 520.23633 499.7793 520.23633 499.7793 C 520.23133 500.48264 520.93419 500.48807 520.92969 501.19141 L 520.92578 501.89453 C 520.21795 502.59337 519.51427 502.58963 519.50977 503.29297 L 518.80664 503.28711 C 518.1033 503.28211 518.10764 502.57872 517.4043 502.57422 C 516.70097 502.56922 516.70528 501.86778 516.00195 501.86328 C 515.29861 501.85828 514.5957 501.85352 514.5957 501.85352 C 513.88786 502.55236 514.58789 503.25977 514.58789 503.25977 L 518.08203 506.79883 C 517.37419 507.49767 517.368 508.20155 516.66016 508.90039 L 515.95703 508.89648 C 515.25369 508.89148 514.55019 508.88692 514.55469 508.18359 C 513.85135 508.17859 513.14806 508.17464 512.44922 507.4668 C 511.74589 507.4618 511.04356 507.45682 511.03906 508.16016 C 511.03406 508.8635 511.02908 509.56777 511.73242 509.57227 C 512.43576 509.57627 513.13477 510.28516 513.13477 510.28516 C 513.8381 510.29016 514.53711 510.99609 514.53711 510.99609 L 515.24023 511.00195 C 515.23523 511.70528 515.23106 512.40799 515.22656 513.11133 L 514.52344 513.10742 C 513.8201 513.10242 513.11719 513.09766 513.11719 513.09766 C 512.41385 513.09266 511.71114 513.08848 511.00781 513.08398 C 510.30447 513.07898 510.29942 513.783 510.29492 514.48633 C 510.28992 515.18967 510.99023 515.89648 510.99023 515.89648 L 515.20898 515.92383 L 515.19141 518.73828 L 514.48828 518.73438 C 513.78495 518.72938 513.77951 519.43222 513.07617 519.42773 C 512.37283 519.42273 511.66602 520.12305 511.66602 520.12305 C 510.96269 520.11805 510.95762 520.82205 510.95312 521.52539 C 510.94813 522.22873 511.65213 522.23183 512.35547 522.23633 C 513.0588 522.24133 513.76736 521.54237 514.4707 521.54688 C 515.17404 521.55187 515.87636 521.55686 515.88086 520.85352 L 516.58398 520.85742 C 517.28282 521.56525 517.27968 522.26872 517.97852 522.97656 L 517.26953 523.67578 C 517.26453 524.37912 517.26056 525.08241 516.55273 525.78125 L 515.13672 527.17969 C 514.42889 527.87853 514.42558 528.58144 515.12891 528.58594 C 515.82775 529.29377 515.82733 529.29258 516.53516 528.59375 L 517.95117 527.19727 C 518.6545 527.20227 518.65799 526.49745 519.36133 526.50195 L 520.06445 526.50781 C 520.76329 527.21564 521.46718 527.21989 522.16602 527.92773 L 522.16211 528.63086 C 522.15711 529.33419 521.45372 529.32987 521.44922 530.0332 C 521.44422 530.73654 520.73633 531.43555 520.73633 531.43555 C 520.73233 532.13889 520.7283 532.8412 521.43164 532.8457 C 522.13498 532.8497 522.83789 532.85547 522.83789 532.85547 C 523.54573 532.15663 523.55078 531.45313 523.55078 531.45312 C 523.55578 530.74978 524.25722 530.75412 524.26172 530.05078 L 524.26758 529.34766 C 524.97092 529.35266 525.66971 530.05995 526.37305 530.06445 L 526.3457 534.28516 C 526.3407 534.9885 527.04102 535.69531 527.04102 535.69531 C 527.74436 535.70031 528.44667 535.70529 528.45117 535.00195 C 528.45617 534.29861 528.46014 533.59532 529.16797 532.89648 C 529.17297 532.19315 529.17752 531.48964 529.88086 531.49414 L 529.88477 530.79102 C 530.58811 530.79602 531.29275 530.80019 531.99609 530.80469 L 531.99023 531.50781 C 531.98523 532.21115 531.98221 532.91347 532.68555 532.91797 C 532.68055 533.62131 533.3795 534.32986 533.375 535.0332 C 533.37 535.73654 534.074 535.74159 534.77734 535.74609 C 535.48068 535.75109 535.48378 535.04709 535.48828 534.34375 C 535.49328 533.64041 535.49745 532.93576 535.50195 532.23242 C 535.50695 531.52908 535.51172 530.82617 535.51172 530.82617 L 535.51758 530.12305 C 536.22092 530.12805 536.92753 529.42909 537.63086 529.43359 L 537.62695 530.13672 C 537.62295 530.84006 538.32481 530.84354 538.32031 531.54688 L 539.71875 532.96289 C 539.71375 533.66623 540.41716 533.6715 541.125 532.97266 C 541.82834 532.97766 541.8334 532.27365 541.83789 531.57031 C 541.84289 530.86697 541.14258 530.1582 541.14258 530.1582 C 541.14758 529.45486 540.44473 529.45139 540.44922 528.74805 L 540.45312 528.04492 C 541.16096 527.34608 541.86464 527.34982 541.86914 526.64648 L 542.57227 526.65234 C 543.2756 526.65734 543.27127 527.36073 543.97461 527.36523 C 544.67795 527.37023 544.67361 528.07167 545.37695 528.07617 C 546.08029 528.08017 546.7832 528.08594 546.7832 528.08594 C 547.49103 527.3871 546.79297 526.67969 546.79297 526.67969 L 545.39453 525.26367 L 543.99805 523.84766 L 543.29883 523.14062 C 544.00667 522.44178 544.01091 521.7379 544.71875 521.03906 L 545.42188 521.04297 C 546.12521 521.04697 546.82872 521.05253 546.82422 521.75586 C 547.52755 521.76086 548.23085 521.76482 548.92969 522.47266 C 549.63303 522.47766 550.33534 522.48264 550.33984 521.7793 C 550.34484 521.07596 550.34982 520.37169 549.64648 520.36719 C 548.94314 520.36219 548.24414 519.6543 548.24414 519.6543 C 547.5408 519.6493 546.8418 518.94336 546.8418 518.94336 L 546.13867 518.9375 C 546.14367 518.23416 546.14784 517.53146 546.15234 516.82812 L 550.37305 516.85547 C 551.07639 516.86047 551.07948 516.15647 551.08398 515.45312 C 551.09748 513.34312 551.09788 513.34239 550.39453 513.33789 L 550.39258 513.33789 C 549.68925 513.33289 548.98654 513.32872 548.2832 513.32422 C 547.57986 513.31922 546.87695 513.31641 546.87695 513.31641 L 546.17188 513.31055 C 546.17687 512.60721 546.17764 512.60764 546.18164 511.9043 C 546.18664 511.20096 546.18741 511.20139 546.19141 510.49805 L 546.89453 510.50195 C 547.59787 510.50695 547.60135 509.80409 548.30469 509.80859 C 549.00802 509.81359 549.7168 509.11328 549.7168 509.11328 C 550.42014 509.11828 550.42323 508.41427 550.42773 507.71094 C 550.43273 507.0076 549.73068 507.00255 549.02734 506.99805 C 548.324 506.99305 547.61544 507.69395 546.91211 507.68945 C 546.20877 507.68445 545.5045 507.67947 545.5 508.38281 L 544.79688 508.37891 C 544.09804 507.67108 544.10314 506.96761 543.4043 506.25977 L 544.11133 505.56055 L 545.52734 504.16211 L 546.94336 502.76562 C 547.6512 502.06678 547.65646 501.36192 546.95312 501.35742 C 546.25429 500.64958 546.25276 500.65077 545.54492 501.34961 L 544.13086 502.74609 C 543.42302 503.44493 543.42209 503.44591 542.71875 503.44141 L 542.01562 503.43555 C 541.3168 502.72771 540.6129 502.72345 539.91406 502.01562 L 539.91992 501.3125 C 539.92492 500.60916 540.62831 500.6135 540.63281 499.91016 C 540.63781 499.20682 541.34375 498.50781 541.34375 498.50781 C 541.34875 497.80447 541.35373 497.10216 540.65039 497.09766 C 539.94705 497.09266 539.24414 497.08789 539.24414 497.08789 L 537.82812 498.48633 C 537.82313 499.18967 537.11973 499.18533 537.11523 499.88867 L 537.10938 500.5918 C 536.40605 500.5868 535.70725 499.8795 535.00391 499.875 L 535.00977 499.17188 C 535.01477 498.46853 535.01953 497.76367 535.01953 497.76367 C 535.02453 497.06033 535.0287 496.35764 535.0332 495.6543 C 535.0382 494.95096 534.33789 494.24414 534.33789 494.24414 C 533.63456 494.23914 532.93028 494.23416 532.92578 494.9375 C 532.92078 495.64084 532.91682 496.34413 532.20898 497.04297 C 532.20398 497.74631 532.20138 498.44981 531.49805 498.44531 L 531.49219 499.14844 C 530.78885 499.14344 530.08615 499.13927 529.38281 499.13477 L 529.38672 498.43164 C 529.39172 497.7283 529.3967 497.02598 528.69336 497.02148 C 528.69836 496.31814 527.99941 495.60959 528.00391 494.90625 C 528.00891 494.20292 527.30489 494.19786 526.60156 494.19336 z M 557.00195 502.52148 C 556.66003 502.49869 556.52895 502.56268 556.79102 502.82812 C 565.1321 518.35555 557.97577 537.30064 537.54297 542.79688 C 536.1363 542.78787 538.94157 544.21345 540.34375 544.92578 C 568.3243 569.01924 586.65162 562.80516 616.74219 586.91211 C 646.83726 610.31572 656.49414 639.91992 656.49414 639.91992 C 653.11692 618.09395 635.06114 582.107 608.50977 554.50586 C 586.14692 531.85508 566.48828 526.10156 566.48828 526.10156 C 581.29887 519.866 600.23438 528.42773 600.23438 528.42773 C 600.23438 528.42773 589.80206 510.07253 559.60352 502.8457 C 558.72435 502.84008 557.57182 502.55947 557.00195 502.52148 z M 530.01367 510.39453 C 532.12368 510.40803 534.22444 511.82749 534.21094 513.9375 C 534.90078 516.05201 533.4811 518.15413 531.37109 518.14062 C 529.25657 518.83047 527.15643 517.40884 527.16992 515.29883 C 526.48008 513.18431 527.89916 511.08437 530.01367 510.39453 z ";
	VP.connect.width = 1007.480;
	VP.connect.height = 639.918;
	VP.show = {};
	VP.show.path = "m 60.619,56.797 60.6191,-47.69339 -11.502,-9.10408 -49.1171,38.66427 -49.0796,-38.66427 -11.53937,9.10408 60.61897,47.69339 z m 0,42.5606 60.6191,-47.6933 -11.502,-9.0667 -49.1171,38.6268 -49.0796,-38.6268 -11.53937,9.0667 60.61897,47.6933 z";
	VP.show.width = 121.238;
	VP.show.height = 99.358;
	VP.hide = {};
	VP.hide.path = "m 60.619,42.561 60.6191,47.69339 -11.502,9.10408 -49.1171,-38.66427 -49.0796,38.66427 -11.53937,-9.10408 60.61897,-47.69339 z m 0,-42.5606 60.6191,47.6933 -11.502,9.0667 -49.1171,-38.6268 -49.0796,38.6268 -11.53937,-9.0667 60.61897,-47.6933 z";
	VP.hide.width = 121.238;
	VP.hide.height = 99.358;
	VP.share = {};
	VP.share.width = 24.000;
	VP.share.height = 24.000;
	VP.share.path = "M 18 2 C 16.34 2 15 3.34 15 5 C 15 5.24 15.039844 5.4692187 15.089844 5.6992188 L 8.0390625 9.8105469 C 7.4990625 9.3105469 6.79 9 6 9 C 4.34 9 3 10.34 3 12 C 3 13.66 4.34 15 6 15 C 6.79 15 7.4990625 14.689453 8.0390625 14.189453 L 15.160156 18.349609 C 15.110156 18.559609 15.080078 18.78 15.080078 19 C 15.080078 20.61 16.39 21.919922 18 21.919922 C 19.61 21.919922 20.919922 20.61 20.919922 19 C 20.919922 17.39 19.61 16.080078 18 16.080078 C 17.24 16.080078 16.559063 16.379609 16.039062 16.849609 L 8.9101562 12.699219 C 8.9601563 12.469219 9 12.24 9 12 C 9 11.76 8.9601563 11.530781 8.9101562 11.300781 L 15.960938 7.1894531 C 16.500937 7.6894531 17.21 8 18 8 C 19.66 8 21 6.66 21 5 C 21 3.34 19.66 2 18 2 z";
	VP.copy = {};
	VP.copy.width = 24;
	VP.copy.height = 24;
	VP.copy.path = "M 4 1 C 2.9 1 2 1.9 2 3 L 2 17 L 4 17 L 4 3 L 16 3 L 16 1 L 4 1 z M 8 5 C 6.9 5 6 5.9 6 7 L 6 21 C 6 22.1 6.9 23 8 23 L 19 23 C 20.1 23 21 22.1 21 21 L 21 7 C 21 5.9 20.1 5 19 5 L 8 5 z M 8 7 L 19 7 L 19 21 L 8 21 L 8 7 z";
	VP.dots = {};
	VP.dots.width = 24;
	VP.dots.height = 24;
	VP.dots.path = "M 12 4 C 10.9 4 10 4.9 10 6 C 10 7.1 10.9 8 12 8 C 13.1 8 14 7.1 14 6 C 14 4.9 13.1 4 12 4 z M 12 10 C 10.9 10 10 10.9 10 12 C 10 13.1 10.9 14 12 14 C 13.1 14 14 13.1 14 12 C 14 10.9 13.1 10 12 10 z M 12 16 C 10.9 16 10 16.9 10 18 C 10 19.1 10.9 20 12 20 C 13.1 20 14 19.1 14 18 C 14 16.9 13.1 16 12 16 z ";
	VP.volumeUp = {};
	VP.volumeUp.width = 24;
	VP.volumeUp.height = 24;
	VP.volumeUp.path = "M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z";
	VP.volumeMute = {};
	VP.volumeMute.width = 9;
	VP.volumeMute.height = 16;
	VP.volumeMute.path = "m 0,5 0,6 4,0 5,5 0,-16 -5,5 -4,0 z";
	VP.zoomIn = {};
	VP.zoomIn.width = 17.490;
	VP.zoomIn.height = 17.490;
	VP.zoomIn.path = "m 6.5,0 c -3.59,0 -6.5,2.91 -6.5,6.5 0,3.59 2.91,6.5 6.5,6.5 1.61,0 3.090469,-0.590313 4.230469,-1.570312 l 0.269531,0.28125 0,0.789062 5,4.990234 1.490234,-1.490234 -4.990234,-5 -0.789062,0 -0.28125,-0.269531 c 0.979999,-1.14 1.570312,-2.620469 1.570312,-4.230469 0,-3.59 -2.91,-6.5 -6.5,-6.5 z m 0,2 c 2.49,0 4.5,2.01 4.5,4.5 0,2.49 -2.01,4.5 -4.5,4.5 -2.49,0 -4.5,-2.01 -4.5,-4.5 0,-2.49 2.01,-4.5 4.5,-4.5 z m -0.5,2 0,2 -2,0 0,1 2,0 0,2 1,0 0,-2 2,0 0,-1 -2,0 0,-2 -1,0 z";
	VP.zoomOut = {};
	VP.zoomOut.width = 24;
	VP.zoomOut.height = 24;
	VP.zoomOut.path = "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z";
	VP.resetZoom = {};
	VP.resetZoom.width = 17.490;
	VP.resetZoom.height = 17.490;
	VP.resetZoom.path = "m 6.5,0 c -3.59,0 -6.5,2.91 -6.5,6.5 0,3.59 2.91,6.5 6.5,6.5 1.61,0 3.090469,-0.590314 4.230469,-1.570312 l 0.269531,0.28125 0,0.789062 5,4.990234 1.490234,-1.490234 -4.990234,-5 -0.789062,0 -0.28125,-0.269531 c 0.979998,-1.14 1.570312,-2.620469 1.570312,-4.230469 0,-3.59 -2.91,-6.5 -6.5,-6.5 z m 0,2 c 2.49,0 4.5,2.01 4.5,4.5 0,2.49 -2.01,4.5 -4.5,4.5 -2.49,0 -4.5,-2.01 -4.5,-4.5 0,-2.49 2.01,-4.5 4.5,-4.5 z m 0,1.7792969 c -0.5877027,0 -1.0381972,0.2332712 -1.3496094,0.6992187 -0.3090707,0.4636061 -0.4628906,1.1383715 -0.4628906,2.0234375 0,0.8827249 0.1538199,1.5574899 0.4628906,2.0234379 0.3114122,0.463606 0.7619067,0.695312 1.3496094,0.695312 0.587703,0 1.036632,-0.231706 1.345703,-0.695312 0.311412,-0.465948 0.466797,-1.140713 0.466797,-2.0234379 0,-0.885066 -0.155385,-1.5598314 -0.466797,-2.0234375 -0.309071,-0.4659475 -0.758,-0.6992187 -1.345703,-0.6992187 z m 0,0.5625 c 0.3676067,0 0.643539,0.1804331 0.826172,0.5410156 0.184974,0.3582411 0.277344,0.8979757 0.277344,1.6191406 0,0.7188239 -0.09237,1.2585579 -0.277344,1.6191409 -0.182633,0.358241 -0.4585653,0.537109 -0.826172,0.537109 -0.3652654,0 -0.6411977,-0.178868 -0.8261719,-0.537109 -0.1826326,-0.360583 -0.2734375,-0.900317 -0.2734375,-1.6191409 0,-0.7211649 0.090805,-1.2608995 0.2734375,-1.6191406 0.1849742,-0.3605825 0.4609065,-0.5410156 0.8261719,-0.5410156 z";
	VP.settings = {};
	VP.settings.width = 24;
	VP.settings.height = 24;
	VP.settings.path = "M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z";
	VP.cloud = {};
	VP.cloud.width = 24;
	VP.cloud.height = 16;
	VP.cloud.path = "m 19.35,6.04 c -0.68,-3.45 -3.71,-6.04 -7.35,-6.04 -2.89,0 -5.4,1.64 -6.65,4.04 -3.01,0.32 -5.35,2.87 -5.35,5.96 0,3.31 2.69,6 6,6 l 13,0 c 2.76,0 5,-2.24 5,-5 0,-2.64 -2.05,-4.78 -4.65,-4.96 z";
	VP.cloudDownload = {};
	VP.cloudDownload.width = 24;
	VP.cloudDownload.height = 16;
	VP.cloudDownload.path = "m 19.35,6.04 c -0.68,-3.45 -3.71,-6.04 -7.35,-6.04 -2.89,0 -5.4,1.64 -6.65,4.04 -3.01,0.32 -5.35,2.87 -5.35,5.96 0,3.31 2.69,6 6,6 l 13,0 c 2.76,0 5,-2.24 5,-5 0,-2.64 -2.05,-4.78 -4.65,-4.96 z m -2.35,2.96 -5,5 -5,-5 3,0 0,-4 4,0 0,4 3,0 z";
	VP.letterX = {};
	VP.letterX.width = 4.430;
	VP.letterX.height = 4.430;
	VP.letterX.path = "m 0,0.69785501 0.69785501,-0.69785501 1.51201679,1.522593 1.5225833,-1.522593 0.6978509,0.69785501 -1.5225889,1.51201679 1.5225889,1.5225833 -0.6978509,0.6978509 -1.5225833,-1.5225889 -1.51201679,1.5225889 -0.69785501,-0.6978509 1.522593,-1.5225833 z";
	VP.cloudUpload = {};
	VP.cloudUpload.width = 24;
	VP.cloudUpload.height = 16;
	VP.cloudUpload.path = "m 19.35,6.04 c -0.68,-3.45 -3.71,-6.04 -7.35,-6.04 -2.89,0 -5.4,1.64 -6.65,4.04 -3.01,0.32 -5.35,2.87 -5.35,5.96 0,3.31 2.69,6 6,6 l 13,0 c 2.76,0 5,-2.24 5,-5 0,-2.64 -2.05,-4.78 -4.65,-4.96 z m -5.35,2.96 0,4 -4,0 0,-4 -3,0 5,-5 5,5 -3,0 z";
	VP.warning = {};
	VP.warning.width = 22;
	VP.warning.height = 19;
	VP.warning.path = "m 0,19 22,0 -11,-19 -11,19 z m 12,-3 -2,0 0,-2 2,0 0,2 z m 0,-4 -2,0 0,-4 2,0 0,4 z";
	VP.info = {};
	VP.info.width = 20;
	VP.info.height = 20;
	VP.info.path = "m 10,0 c -5.52,0 -10,4.48 -10,10 0,5.52 4.48,10 10,10 5.52,0 10,-4.48 10,-10 0,-5.52 -4.48,-10 -10,-10 z m 1,15 -2,0 0,-6 2,0 0,6 z m 0,-8 -2,0 0,-2 2,0 0,2 z";
	VP.undoDelete = {};
	VP.undoDelete.width = 87.924;
	VP.undoDelete.height = 113.045;
	VP.undoDelete.path = "m 28.262,0 -6.28125,6.2793 -21.98047,0 0,12.56054 87.92383,0 0,-12.56054 -21.98047,0 -6.28125,-6.2793 -31.40039,0 z m -21.98242,25.12109 0,75.36329 c 0,6.90831 5.65224,12.56054 12.56055,12.56054 l 50.24218,0 c 6.90832,0 12.56055,-5.65223 12.56055,-12.56054 l 0,-75.36329 -75.36328,0 z m 35.52344,12.25586 0,13.23243 c 32.63892,-0.75632 39.13249,32.15793 17.60156,42.08984 8.4063,-6.82329 9.65417,-28.23254 -17.60156,-27.66406 l 0,13.51953 -25.80078,-21.14063 25.80078,-20.03711 z";
}
/**
 * Static class contains metadata about images used in the app.  Currently not images are actually used since vectors
 * are better and don't take time to load.  Each record is an object and can be passed to UI-related functions
 * that need a reference to an image
 */
function ImageLists() {
	const IL = ImageLists;
	IL.hBIcon = {};
	IL.hBIcon.lightName = "hBIconWhite";
	IL.hBIcon.darkName = "hBIconDarkGray";
	IL.hBIcon.width = 526;
	IL.hBIcon.height = 334;
}
/*
 * Static class holds all constants and functions required for Block rendering.
 * Note that some of the constants are repeated for each type of Block, so be sure to edit all of them if you're
 * editing one.
 */

/**
 * Initializes the static class by setting all constants
 */
function BlockGraphics() {
	// Set constants for blocks
	BlockGraphics.SetBlock();
	BlockGraphics.SetCommand();
	BlockGraphics.SetReporter();
	BlockGraphics.SetPredicate();
	BlockGraphics.SetString();
	BlockGraphics.SetHat();
	BlockGraphics.SetLoop();

	// Set constants for block parts
	BlockGraphics.SetLabelText();
	BlockGraphics.SetValueText();

	// Set constants for Slots
	BlockGraphics.SetDropSlot();
	BlockGraphics.SetHighlight();
	BlockGraphics.SetHitBox();
	BlockGraphics.SetGlow();

	// Pre-compute some strings useful for rendering blocks
	BlockGraphics.CalcCommand();
	BlockGraphics.CalcPaths();
}

/* Constants for all Blocks */
BlockGraphics.SetBlock = function() {
	BlockGraphics.block = {};
	BlockGraphics.block.pMargin = 7; // Margin between parts
};

/* Used by CommandBlocks, LoopBlocks, and HatBlocks */
BlockGraphics.SetCommand = function() {
	BlockGraphics.command = {};

	// Minimum dimensions
	BlockGraphics.command.height = 34;
	BlockGraphics.command.width = 40;

	BlockGraphics.command.vMargin = 5; // The margin above and below the content (BlockParts) of the Block
	BlockGraphics.command.hMargin = 7; // The margin to the left and right of the content

	BlockGraphics.command.bumpOffset = 7;
	BlockGraphics.command.bumpDepth = 4;
	BlockGraphics.command.bumpTopWidth = 15;
	BlockGraphics.command.bumpBottomWidth = 7;
	BlockGraphics.command.cornerRadius = 3;

	// Define the size of the snap bounding box (how close the Block being dragged must be to snap)
	BlockGraphics.command.snap = {};
	BlockGraphics.command.snap.left = 20;
	BlockGraphics.command.snap.right = 20;
	BlockGraphics.command.snap.top = 20;
	BlockGraphics.command.snap.bottom = 20;

	// How much Blocks are shifted down and to the right when they are bumped out of position by another Block
	BlockGraphics.command.shiftX = 20;
	BlockGraphics.command.shiftY = 20;
};

/* Used by RoundSlots and ReporterBlocks */
BlockGraphics.SetReporter = function() {
	BlockGraphics.reporter = {};

	// Minimum dimensions
	BlockGraphics.reporter.height = 30;
	BlockGraphics.reporter.width = 30;

	BlockGraphics.reporter.vMargin = 6;
	BlockGraphics.reporter.hMargin = 10;

	// Slot constants
	BlockGraphics.reporter.slotHeight = 22;
	BlockGraphics.reporter.slotWidth = 22;
	BlockGraphics.reporter.slotHMargin = 10; // Space to sides of content

	BlockGraphics.reporter.strokeW = 1;
	BlockGraphics.reporter.slotFill = "#fff";
	BlockGraphics.reporter.slotSelectedFill = "#000";
};

/* Used by HexSlots and HexBlocks */
BlockGraphics.SetPredicate = function() {
	BlockGraphics.predicate = {};

	// Minimum dimensions
	BlockGraphics.predicate.height = 30;
	BlockGraphics.predicate.width = 27;

	BlockGraphics.predicate.vMargin = 6;
	BlockGraphics.predicate.hMargin = 10;

	// Width of pointy part of hexagons
	BlockGraphics.predicate.hexEndL = 10;

	// Slot constants
	BlockGraphics.predicate.slotHeight = 18;
	BlockGraphics.predicate.slotWidth = 25;
	BlockGraphics.predicate.slotHMargin = 5;
	BlockGraphics.predicate.slotHexEndL = 7;
};

/* Used be RectSlots */
BlockGraphics.SetString = function() {
	BlockGraphics.string = {};
	BlockGraphics.string.slotHeight = 22;
	BlockGraphics.string.slotWidth = 22;
	BlockGraphics.string.slotHMargin = 4;
};

/* Additional constants for HatBlocks */
BlockGraphics.SetHat = function() {
	BlockGraphics.hat = {};

	// Radius of ellipse at top of Block
	BlockGraphics.hat.hRadius = 60;
	BlockGraphics.hat.vRadius = 40;

	// Width of ellipse
	BlockGraphics.hat.topW = 80;

	// Minimum width is larger than CommandBlocks to leave room for ellipse
	BlockGraphics.hat.width = 90;

	// Additional height added by ellipse.  Used for spacing Blocks in the Palette
	BlockGraphics.hat.hatHEstimate = 10;
};

/* Additional constants for LoopBlocks */
BlockGraphics.SetLoop = function() {
	BlockGraphics.loop = {};

	// Minimum width of loop blocks
	BlockGraphics.loop.width = 40;
	
	BlockGraphics.loop.bottomH = 7;
	BlockGraphics.loop.side = 7;
};

/* LabelText constants */
BlockGraphics.SetLabelText = function() {
	BlockGraphics.labelText = {};
	BlockGraphics.labelText.font = Font.uiFont(12).bold();
	BlockGraphics.labelText.fill = "#ffffff";
	BlockGraphics.labelText.disabledFill = "#e4e4e4";
};

/* Constants for text in Slots */
BlockGraphics.SetValueText = function() {
	BlockGraphics.valueText = {};
	BlockGraphics.valueText.font = Font.uiFont(12);
	BlockGraphics.valueText.fill = "#000000";
	BlockGraphics.valueText.selectedFill = "#fff";
	BlockGraphics.valueText.grayedFill = "#aaa";
};

/* Constants for DropSlots */
BlockGraphics.SetDropSlot = function() {
	BlockGraphics.dropSlot = {};
	BlockGraphics.dropSlot.slotHeight = 22;
	BlockGraphics.dropSlot.slotWidth = 25;
	BlockGraphics.dropSlot.slotHMargin = 5;
	BlockGraphics.dropSlot.triH = 6;
	BlockGraphics.dropSlot.triW = 8;
	BlockGraphics.dropSlot.bg = "#000";
	BlockGraphics.dropSlot.bgOpacity = 0.25;
	BlockGraphics.dropSlot.selectedBg = "#000";
	BlockGraphics.dropSlot.selectedBgOpacity = 1;
	BlockGraphics.dropSlot.triColor = "#000";
	BlockGraphics.dropSlot.textFill = "#fff";
	BlockGraphics.dropSlot.selectedTriColor = "#fff";
};

/* Constants for indicator that shows where Blocks will be snapped */
BlockGraphics.SetHighlight = function() {
	BlockGraphics.highlight = {};
	BlockGraphics.highlight.margin = 5;
	BlockGraphics.highlight.hexEndL = 15;
	BlockGraphics.highlight.slotHexEndL = 10;
	BlockGraphics.highlight.strokeC = "#fff";
	BlockGraphics.highlight.strokeDarkC = "#000";
	BlockGraphics.highlight.strokeW = 3;
	BlockGraphics.highlight.commandL = 10;
};

/* Constants for Slot hit box */
BlockGraphics.SetHitBox = function() {
	BlockGraphics.hitBox = {};
	BlockGraphics.hitBox.hMargin = BlockGraphics.block.pMargin / 2;
	BlockGraphics.hitBox.vMargin = 3;
};

/* Constants for outline on running Blocks */
BlockGraphics.SetGlow = function() {
	BlockGraphics.glow = function() {};
	BlockGraphics.glow.color = "#fff";
	BlockGraphics.glow.strokeW = 2;
};

/* Computes intermediate values from constants */
BlockGraphics.CalcCommand = function() {
	const com = BlockGraphics.command;
	com.extraHeight = 2 * com.cornerRadius;
	com.extraWidth = 2 * com.cornerRadius + com.bumpTopWidth + com.bumpOffset;
	com.bumpSlantWidth = (com.bumpTopWidth - com.bumpBottomWidth) / 2;
};

/* Generates pre-made parts of paths. Final paths are generated by inserting numbers between pre-made strings */
BlockGraphics.CalcPaths = function() {
	const com = BlockGraphics.command;
	let path1 = "";
	//path1+="m "+com.x+","+com.y;
	path1 += " " + com.bumpOffset + ",0";
	path1 += " " + com.bumpSlantWidth + "," + com.bumpDepth;
	path1 += " " + com.bumpBottomWidth + ",0";
	path1 += " " + com.bumpSlantWidth + "," + (0 - com.bumpDepth);
	path1 += " ";
	let path2 = ",0";
	path2 += " a " + com.cornerRadius + " " + com.cornerRadius + " 0 0 1 " + com.cornerRadius + " " + com.cornerRadius;
	path2 += " l 0,";
	let path3 = "";
	path3 += " a " + com.cornerRadius + " " + com.cornerRadius + " 0 0 1 " + (0 - com.cornerRadius) + " " + com.cornerRadius;
	path3 += " l ";
	let path4 = ",0";
	path4 += " " + (0 - com.bumpSlantWidth) + "," + com.bumpDepth;
	path4 += " " + (0 - com.bumpBottomWidth) + ",0";
	path4 += " " + (0 - com.bumpSlantWidth) + "," + (0 - com.bumpDepth);
	path4 += " " + (0 - com.bumpOffset) + ",0";
	path4 += " a " + com.cornerRadius + " " + com.cornerRadius + " 0 0 1 " + (0 - com.cornerRadius) + " " + (0 - com.cornerRadius);
	path4 += " ";
	let path4NoBump = ",0";
	path4NoBump += " " + (0 - com.bumpSlantWidth - com.bumpBottomWidth - com.bumpSlantWidth - com.bumpOffset) + ",0";
	path4NoBump += " a " + com.cornerRadius + " " + com.cornerRadius + " 0 0 1 " + (0 - com.cornerRadius) + " " + (0 - com.cornerRadius);
	path4NoBump += " ";
	let path5 = "";
	path5 += " a " + com.cornerRadius + " " + com.cornerRadius + " 0 0 1 " + com.cornerRadius + " " + (0 - com.cornerRadius);
	path5 += " z";
	com.path1 = path1;
	com.path2 = path2;
	com.path3 = path3;
	com.path4 = path4;
	com.path4NoBump = path4NoBump;
	com.path5 = path5;
};

/* Types of blocks are referred to by numbers, as indicated by this function */

/**
 * @param {number} type
 * @return {object}
 */
BlockGraphics.getType = function(type) {
	switch (type) {
		case 0:
			return BlockGraphics.command;
		case 1:
			return BlockGraphics.reporter;
		case 2:
			return BlockGraphics.predicate;
		case 3:
			return BlockGraphics.string;
		case 4:
			return BlockGraphics.hat;
		case 5:
			return BlockGraphics.loop;
		case 6:
			return BlockGraphics.loop;
	}
};

/* Group of functions that generate strings for SVG paths */
BlockGraphics.buildPath = {};

/**
 * Creates the path of a CommandBlock
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {string}
 */
BlockGraphics.buildPath.command = function(x, y, width, height) {
	let path = "";
	path += "m " + (x + BlockGraphics.command.cornerRadius) + "," + y;
	path += BlockGraphics.command.path1;

	path += width - BlockGraphics.command.extraWidth;
	path += BlockGraphics.command.path2;
	path += height - BlockGraphics.command.extraHeight;
	path += BlockGraphics.command.path3;
	path += BlockGraphics.command.extraWidth - width;
	path += BlockGraphics.command.path4 + "l 0,";
	path += BlockGraphics.command.extraHeight - height;
	path += BlockGraphics.command.path5;
	return path;
};

/**
 * Creates the path of a highlight between two CommandBlocks
 * @param {number} x
 * @param {number} y
 * @return {string}
 */
BlockGraphics.buildPath.highlightCommand = function(x, y) {
	let path = "";
	path += "m " + x + "," + y;
	path += "l " + BlockGraphics.command.cornerRadius + ",0";
	path += BlockGraphics.command.path1;
	path += BlockGraphics.highlight.commandL + ",0";
	return path;
};

/**
 * Creates round path of a reporter Block/Slot
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {string}
 */
BlockGraphics.buildPath.reporter = function(x, y, width, height) {
	const radius = height / 2;
	const flatWidth = width - height;
	let path = "";
	path += "m " + (x + radius) + "," + (y + height);
	path += " a " + radius + " " + radius + " 0 0 1 0 " + (0 - height);
	path += " l " + flatWidth + ",0";
	path += " a " + radius + " " + radius + " 0 0 1 0 " + height;
	path += " z";
	return path;
};

/**
 * Creates the hexagonal path of a Slot/Block/highlight
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {boolean} isSlot
 * @param {boolean} isHighlight
 * @return {string}
 */
BlockGraphics.buildPath.predicate = function(x, y, width, height, isSlot, isHighlight) {
	let hexEndL;
	let halfHeight = height / 2;
	let bG;
	if (isHighlight) {
		bG = BlockGraphics.highlight;
	} else {
		bG = BlockGraphics.predicate;
	}
	if (isSlot) {
		hexEndL = bG.slotHexEndL;
	} else {
		hexEndL = bG.hexEndL;
	}
	let flatWidth = width - 2 * hexEndL;
	let path = "";
	path += "m " + x + "," + (y + halfHeight);
	path += " " + hexEndL + "," + (0 - halfHeight);
	path += " " + flatWidth + ",0";
	path += " " + hexEndL + "," + halfHeight;
	path += " " + (0 - hexEndL) + "," + halfHeight;
	path += " " + (0 - flatWidth) + ",0";
	path += " " + (0 - hexEndL) + "," + (0 - halfHeight);
	path += " z";
	return path;
};

/* Creates the rectangular path of a RectSlot */
BlockGraphics.buildPath.string = function(x, y, width, height) {
	let path = "";
	path += "m " + x + "," + y;
	path += " " + width + ",0";
	path += " 0," + height;
	path += " " + (0 - width) + ",0";
	path += " z";
	return path;
};

/* Creates the path of a HatBlock */
BlockGraphics.buildPath.hat = function(x, y, width, height) {
	let path = "";
	let hat = BlockGraphics.hat;
	let flatWidth = width - hat.topW - BlockGraphics.command.cornerRadius;
	let flatHeight = height - BlockGraphics.command.cornerRadius * 2;
	path += "m " + x + "," + y;
	path += " a " + hat.hRadius + " " + hat.vRadius + " 0 0 1 " + hat.topW + " 0";
	path += " l " + flatWidth;
	path += BlockGraphics.command.path2;
	path += flatHeight;
	path += BlockGraphics.command.path3;
	path += BlockGraphics.command.extraWidth - width;
	path += BlockGraphics.command.path4;
	path += "z";
	return path;
};

/**
 * Creates the path of a LoopBlock
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} innerHeight - The height of the space in the middle of the loop
 * @param {boolean} [bottomOpen=true] - Whether a bump should be placed on the bottom of the path
 * @return {string}
 */
BlockGraphics.buildPath.loop = function(x, y, width, height, innerHeight, bottomOpen) {
	if (bottomOpen == null) {
		bottomOpen = true;
	}
	let path = "";
	const loop = BlockGraphics.loop;
	const comm = BlockGraphics.command;
	path += "m " + (x + comm.cornerRadius) + "," + y;
	path += comm.path1;
	path += width - comm.extraWidth;
	path += comm.path2;
	path += height - innerHeight - 2 * comm.cornerRadius - loop.bottomH;
	path += comm.path3;
	path += (comm.extraWidth - width + loop.side) + ",0";
	path += " " + (0 - comm.bumpSlantWidth) + "," + comm.bumpDepth;
	path += " " + (0 - comm.bumpBottomWidth) + ",0";
	path += " " + (0 - comm.bumpSlantWidth) + "," + (0 - comm.bumpDepth);
	path += " " + (0 - comm.bumpOffset) + ",0";
	path += " a " + comm.cornerRadius + " " + comm.cornerRadius + " 0 0 0 " + (0 - comm.cornerRadius) + " " + comm.cornerRadius;
	path += " l 0," + (innerHeight - 2 * comm.cornerRadius);
	path += " a " + comm.cornerRadius + " " + comm.cornerRadius + " 0 0 0 " + comm.cornerRadius + " " + comm.cornerRadius;
	path += " l " + (width - 2 * comm.cornerRadius - loop.side);
	path += comm.path2;
	path += loop.bottomH - 2 * comm.cornerRadius;
	path += comm.path3;
	path += (comm.extraWidth - width);
	if (bottomOpen) {
		path += comm.path4 + "l 0,";
	} else {
		path += comm.path4NoBump + "l 0,";
	}
	path += (0 - height + 2 * comm.cornerRadius);
	path += comm.path5;
	return path;
};

/**
 * Creates the path of a DoubleLoopBlock (used for if/else Block)
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} innerHeight1 - The height of the first space
 * @param {number} innerHeight2 - The height of the second space
 * @param {number} midHeight - The height of the part of the Block between the spaces
 * @return {string}
 */
BlockGraphics.buildPath.doubleLoop = function(x, y, width, height, innerHeight1, innerHeight2, midHeight) {
	let path = "";
	const loop = BlockGraphics.loop;
	const comm = BlockGraphics.command;
	path += "m " + (x + comm.cornerRadius) + "," + y;
	path += comm.path1;
	path += width - comm.extraWidth;
	let innerHeight = innerHeight1;
	let currentH = height - midHeight - innerHeight1 - innerHeight2 - 2 * comm.cornerRadius - loop.bottomH;
	for (let i = 0; i < 2; i++) {
		path += comm.path2;
		path += currentH;
		path += comm.path3;
		path += (comm.extraWidth - width + loop.side) + ",0";
		path += " " + (0 - comm.bumpSlantWidth) + "," + comm.bumpDepth;
		path += " " + (0 - comm.bumpBottomWidth) + ",0";
		path += " " + (0 - comm.bumpSlantWidth) + "," + (0 - comm.bumpDepth);
		path += " " + (0 - comm.bumpOffset) + ",0";
		path += " a " + comm.cornerRadius + " " + comm.cornerRadius + " 0 0 0 " + (0 - comm.cornerRadius) + " " + comm.cornerRadius;
		path += " l 0," + (innerHeight - 2 * comm.cornerRadius);
		path += " a " + comm.cornerRadius + " " + comm.cornerRadius + " 0 0 0 " + comm.cornerRadius + " " + comm.cornerRadius;
		path += " l " + (width - 2 * comm.cornerRadius - loop.side);
		innerHeight = innerHeight2;
		currentH = midHeight - 2 * comm.cornerRadius;
	}
	path += comm.path2;
	path += loop.bottomH - 2 * comm.cornerRadius;
	path += comm.path3;
	path += (comm.extraWidth - width);
	path += comm.path4 + "l 0,";
	path += (0 - height + 2 * comm.cornerRadius);
	path += comm.path5;
	return path;
};

/* Group of functions that create the SVG elements for Blocks/Slots */
BlockGraphics.create = {};

/**
 * Creates the path element for the Block
 * @param {string} category - indicates which category's gradient to use
 * @param {Element} group - SVG group, Path will automatically be added to this group
 * @param {boolean} returnsValue - Whether the block returns a value and should be given an outline
 * @param {boolean} active - Whether the block is currently runnable or should be grayed out
 * @return {Element} - SVG path element for the background of the Block
 */
BlockGraphics.create.block = function(category, group, returnsValue, active) {
	if (!active) category = "inactive";
	const path = GuiElements.create.path(group);
	const fill = Colors.getGradient(category);
	path.setAttributeNS(null, "fill", fill);
	BlockGraphics.update.stroke(path, category, returnsValue, active);
	return path;
};

/**
 * Creates the SVG path element for a Slot
 * @param {Element} group - SVG group, Path will automatically be added to this group
 * @param {number} type - number representing the type/shape of slot
 * @param {string} category - indicates which category's gradient to use
 * @param {boolean} active - Whether the Slot is currently active or should be grayed out
 */
BlockGraphics.create.slot = function(group, type, category, active) {
	if (!active) category = "inactive";
	const bG = BlockGraphics.reporter;
	const path = GuiElements.create.path(group);
	if (type === 2) {
		path.setAttributeNS(null, "fill", "url(#gradient_dark_" + category + ")");
	} else {
		path.setAttributeNS(null, "fill", bG.slotFill);
	}
	return path;
};

/**
 * Creates the hit box for a slot.  Does not worry about position or size
 * @param {Element} group
 */
BlockGraphics.create.slotHitBox = function(group) {
	const rectE = GuiElements.create.rect(group);
	rectE.setAttributeNS(null, "fill", "#000");
	GuiElements.update.opacity(rectE, 0);
	return rectE;
};

/**
 * Creates text for LabelText
 * @param {string} text
 * @param {Element} group
 */
BlockGraphics.create.labelText = function(text, group) {
	const bG = BlockGraphics.labelText;
	const textElement = GuiElements.create.text();
	textElement.setAttributeNS(null, "font-family", bG.font.fontFamily);
	textElement.setAttributeNS(null, "font-size", bG.font.fontSize);
	textElement.setAttributeNS(null, "font-weight", bG.font.fontWeight);
	textElement.setAttributeNS(null, "fill", bG.fill);
	textElement.setAttributeNS(null, "class", "noselect");
	const textNode = document.createTextNode(text);
	textElement.appendChild(textNode);
	group.appendChild(textElement);
	return textElement;
};

/**
 * Creates text for inside Slot
 * @param {string} text
 * @param {Element} group
 */
BlockGraphics.create.valueText = function(text, group) {
	const bG = BlockGraphics.valueText;
	const textElement = GuiElements.create.text();
	textElement.setAttributeNS(null, "font-family", bG.font.fontFamily);
	textElement.setAttributeNS(null, "font-size", bG.font.fontSize);
	textElement.setAttributeNS(null, "font-weight", bG.font.fontWeight);
	textElement.setAttributeNS(null, "fill", bG.fill);
	textElement.setAttributeNS(null, "class", "noselect");
	GuiElements.update.text(textElement, text);
	group.appendChild(textElement);
	return textElement;
};

/* Group of functions used for modifying existing SVG elements */
BlockGraphics.update = {};

/**
 * Updates a path's shape, size and location.  Necessary parameters depend on type.
 * @param {Element} path
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} [type]
 * @param {boolean} [isSlot]
 * @param {number} [innerHeight1]
 * @param {number} [innerHeight2]
 * @param {number} [midHeight]
 * @param {boolean} [bottomOpen]
 * @return {*}
 */
BlockGraphics.update.path = function(path, x, y, width, height, type, isSlot, innerHeight1, innerHeight2, midHeight, bottomOpen) {
	let pathD;
	switch (type) {
		case 0:
			pathD = BlockGraphics.buildPath.command(x, y, width, height);
			break;
		case 1:
			pathD = BlockGraphics.buildPath.reporter(x, y, width, height);
			break;
		case 2:
			pathD = BlockGraphics.buildPath.predicate(x, y, width, height, isSlot, false);
			break;
		case 3:
			pathD = BlockGraphics.buildPath.string(x, y, width, height);
			break;
		case 4:
			pathD = BlockGraphics.buildPath.hat(x, y, width, height);
			break;
		case 5:
			pathD = BlockGraphics.buildPath.loop(x, y, width, height, innerHeight1, bottomOpen);
			break;
		case 6:
			pathD = BlockGraphics.buildPath.doubleLoop(x, y, width, height, innerHeight1, innerHeight2, midHeight);
			break;
	}
	path.setAttributeNS(null, "d", pathD);
	return path;
};

/**
 * Moves text to location
 * @param {Element} text
 * @param {number} x
 * @param {number} y
 */
BlockGraphics.update.text = function(text, x, y) {
	text.setAttributeNS(null, "x", x);
	text.setAttributeNS(null, "y", y);
};

/**
 * Makes a path start glowing (adds a white outline)
 * @param {Element} path
 */
BlockGraphics.update.glow = function(path) {
	const glow = BlockGraphics.glow;
	path.setAttributeNS(null, "stroke", glow.color);
	path.setAttributeNS(null, "stroke-width", glow.strokeW);
};

/**
 * Updates the outline of a path
 * @param {Element} path
 * @param {string} category
 * @param {boolean} returnsValue
 * @param {boolean} active
 */
BlockGraphics.update.stroke = function(path, category, returnsValue, active) {
	if (!active) category = "inactive";
	if (returnsValue) {
		const outline = Colors.getColor(category);
		path.setAttributeNS(null, "stroke", outline);
		path.setAttributeNS(null, "stroke-width", BlockGraphics.reporter.strokeW);
	} else {
		path.setAttributeNS(null, "stroke-width", 0);
	}
};

/**
 * Updates a HexSlot's fill
 * @param {Element} path
 * @param {string} category
 * @param {boolean} active
 */
BlockGraphics.update.hexSlotGradient = function(path, category, active) {
	if (!active) category = "inactive";
	path.setAttributeNS(null, "fill", "url(#gradient_dark_" + category + ")");
};

/**
 * Change whether the Block appears active or inactive
 * @param {string} path
 * @param {string} category
 * @param {boolean} returnsValue
 * @param {boolean} active
 * @param {boolean} glowing
 */
BlockGraphics.update.blockActive = function(path, category, returnsValue, active, glowing) {
	if (!active) category = "inactive";
	const fill = Colors.getGradient(category);
	path.setAttributeNS(null, "fill", fill);
	if (!glowing) {
		BlockGraphics.update.stroke(path, category, returnsValue, active);
	}
};

/**
 * Creates the string for the path of the highlight indicator
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} type
 * @param {boolean} isSlot
 * @return {string}
 */
BlockGraphics.buildPath.highlight = function(x, y, width, height, type, isSlot) {
	const bG = BlockGraphics.highlight;
	let pathD;
	const hX = x - bG.margin;
	const hY = y - bG.margin;
	const hWidth = width + 2 * bG.margin;
	const hHeight = height + 2 * bG.margin;
	switch (type) {
		case 0:
			pathD = BlockGraphics.buildPath.highlightCommand(x, y);
			break;
		case 1:
			pathD = BlockGraphics.buildPath.reporter(hX, hY, hWidth, hHeight);
			break;
		case 2:
			pathD = BlockGraphics.buildPath.predicate(hX, hY, hWidth, hHeight, isSlot, true);
			break;
		case 3:
			pathD = BlockGraphics.buildPath.string(hX, hY, hWidth, hHeight);
			break;
	}
	return pathD;
};

/**
 * Moves an element to the top of a group by removing it an re-adding it
 * @param {Element} obj
 * @param {Element} layer
 */
BlockGraphics.bringToFront = function(obj, layer) {
	obj.remove();
	layer.appendChild(obj);
};
/* Recordings and sound effects are cached by static properties in the Sound class.  An instance of the sound class
 * represents a single sound or recording.  Sound playback is handled by static functions.  Note that sound recording
 * is handled by the RecordingManager, not in the Sound class
 */

/* The frontend should never deal with file extensions.  All information about sounds/recordings should have the
 * file extension removed before the frontend sees it
 */

/**
 * Information about a sound
 * @param {string} id - Used in communication between the frontend/backend
 * @param {boolean} isRecording - Whether the sound is a recording
 * @constructor
 */
function Sound(id, isRecording){
	// Ids are used in save files while names are shown in the UI.
	// If we decide to change display names for built-in sounds, we will keep ids the same.
	this.id = id;
	this.name = Sound.nameFromId(id, isRecording);
	this.isRecording = isRecording;
}

Sound.setConstants = function(){
	// Cached lists
	Sound.soundList = [];
	Sound.recordingList = [];

	// List of data about currently playing sounds
	Sound.playingSoundStatuses = [];

	// Enum for types of sounds
	Sound.type = {};
	Sound.type.effect = "effect"; // Sounds built in to app
	Sound.type.ui = "ui"; // Sounds used in UI, not sound blocks (snap sound, for example)
	Sound.type.recording = "recording"; // Sounds local to project, recorded by user

	// Load into cache
	Sound.loadSounds(true);
	Sound.loadSounds(false);

	// Sound when Blocks are snapped together
	Sound.click = "click2";
};

/**
 * Stops all playing sounds and plays the specified sound
 * @param {string} id - The sound to play
 * @param {boolean} isRecording - Whether the sound is a recording
 * @param {function} sentCallback - Called when command to play sound is received by backend successfully
 * @param {function} errorCallback - Called if backend encounters an error (such as sound not found)
 * @param {function} donePlayingCallback - Called when sound stops playing, is interrupted, etc.
 */
Sound.playAndStopPrev = function(id, isRecording, sentCallback, errorCallback, donePlayingCallback){
	Sound.stopAllSounds(null, function(){
		Sound.playWithCallback(id, isRecording, sentCallback, errorCallback, donePlayingCallback);
	});
};

/**
 * Plays the specified sound
 * @param {string} id - The sound to play
 * @param {boolean} isRecording - Whether the sound is a recording
 * @param {function} sentCallback - Called when command to play sound is received by backend successfully
 * @param {function} errorCallback - Called if backend encounters an error (such as sound not found)
 * @param {function} donePlayingCallback - Called when sound stops playing, is interrupted, etc.
 */
Sound.playWithCallback = function(id, isRecording, sentCallback, errorCallback, donePlayingCallback){
	let status = {};
	status.donePlayingCallback = donePlayingCallback;
	Sound.playingSoundStatuses.push(status);
	const removeEntry = function(){
		let index = Sound.playingSoundStatuses.indexOf(status);
		if(index > -1) {
			Sound.playingSoundStatuses.splice(index, 1);
			return true;
		}
		return false;
	};
	const errorFn = function(){
		removeEntry();
		if(errorCallback != null) errorCallback();
	};
	const donePlayingFn = function(){
		if(removeEntry()) {
			if (donePlayingCallback != null) donePlayingCallback();
		}
	};
	Sound.getDuration(id, isRecording, function(duration){
		//id = id.split(".wav").join(""); //TODO: remove .wav replacement
		let request = new HttpRequestBuilder("sound/play");
		request.addParam("filename", id);
		request.addParam("type", Sound.boolToType(isRecording));
		HtmlServer.sendRequestWithCallback(request.toString(), function(){
			setTimeout(donePlayingFn, duration);
			if(sentCallback != null) sentCallback();
		}, errorFn);
	}, errorFn);
};

/**
 * Plays the specified sound and tracks progress with a status object
 * @param {string} id
 * @param {boolean} isRecording
 * @param {object} status
 */
Sound.play = function(id, isRecording, status){
	if(status == null){
		Sound.playWithCallback(id, isRecording);
	}
	else{
		status.donePlaying = false;
		status.requestSent = false;
		status.error = false;
		Sound.playWithCallback(id, isRecording, function(){
			status.requestSent = true;
		}, function(){
			status.donePlaying = false;
			status.requestSent = false;
			status.error = true;
		}, function(){
			status.donePlaying = true;
			status.requestSent = true;
		});
	}
};

/**
 * Looks up the duration of the sound
 * @param {number} id
 * @param {boolean} isRecording
 * @param {function} callbackFn - called with the duration as a number
 * @param {function} callbackError
 */
Sound.getDuration = function(id, isRecording, callbackFn, callbackError){
	let request = new HttpRequestBuilder("sound/duration");
	request.addParam("filename", id);
	request.addParam("type", Sound.boolToType(isRecording));
	HtmlServer.sendRequestWithCallback(request.toString(), function(result){
		let res = Number(result);
		if(!isNaN(res)){
			if(callbackFn != null) callbackFn(res);
		} else{
			if(callbackError != null) callbackError();
		}
	}, callbackError);
};

/**
 * Tells the Sound class that the file has changed.  Prompts cache of recordings to be reloaded
 */
Sound.changeFile = function(){
	Sound.recordingList = [];
	Sound.loadSounds(true);
};

/**
 * @param {boolean} isRecording
 * @param {function} [callbackFn] - Called with a list of Sounds when that are loaded
 */
Sound.loadSounds = function(isRecording, callbackFn){
	let request = new HttpRequestBuilder("sound/names");
	request.addParam("type", Sound.boolToType(isRecording));
	HtmlServer.sendRequestWithCallback(request.toString(), function(result){
		let list = result.split("\n");
		if(result === "") list = [];
		let resultList = list.map(function(id){
			return new Sound(id, isRecording);
		});
		if(isRecording){
			Sound.recordingList = resultList;
		} else {
			Sound.soundList = resultList;
		}
		if(callbackFn != null) callbackFn(resultList);
	});
};

/**
 * Determine's a Sound's name from its id.  idRecording implies id == name.
 * @param {string} id
 * @param {boolean} isRecording
 * @return {string}
 */
Sound.nameFromId = function(id, isRecording){
	if(isRecording) return id;
	let name = id;
	/*if(name.substring(name.length - 4) === ".wav") { //TODO: remove this line
		name = name.substring(0, name.length - 4);
	}*/
	name = name.split("_").join(" ");
	name = name.replace(/\b\w/g, l => l.toUpperCase());
	return name;
};

/**
 * Stops all running sounds and calls the donePlaying callbacks of the sounds
 * @param {object} [status] - A status object for the request
 * @param {function} [callbackFn] - Called when the request completes (even if there is an error)
 */
Sound.stopAllSounds=function(status, callbackFn){
	if(status == null) status = {};
	let request = new HttpRequestBuilder("sound/stopAll");
	let callback = function() {
		status.finished = true;
		Sound.playingSoundStatuses.forEach(function (playStatus) {
			if(playStatus.donePlayingCallback != null) playStatus.donePlayingCallback();
		});
		Sound.playingSoundStatuses = [];
		if(callbackFn != null) callbackFn();
	};
	HtmlServer.sendRequestWithCallback(request.toString(), callback, callback);
};

/**
 * Reads from the cached list of sounds
 * @param {boolean} isRecording
 * @return {Array}
 */
Sound.getSoundList = function(isRecording){
	if(isRecording) {
		return Sound.recordingList;
	}
	return Sound.soundList;
};

/**
 * Retrieves the string to put as the type parameter for the request
 * @param {boolean} isRecording
 * @return {string}
 */
Sound.boolToType = function(isRecording){
	if(isRecording){
		return Sound.type.recording;
	} else {
		return Sound.type.effect;
	}
};

/**
 * Returns the name of the sound effect with the provided id, or null if no such sound exists.
 * @param {string} id (of sound effect, not recording)
 * @return {string|null}
 */
Sound.lookupById = function(id){
	let result = null;
	Sound.soundList.forEach(function(sound){
		if(sound.id === id) {
			result = sound;
		}
	});
	return result;
};

/**
 * Plays the snap sound effect if it is enabled
 */
Sound.playSnap = function(){
	if(SettingsManager.enableSnapNoise.getValue() === "true") {
		let snapSoundRequest = new HttpRequestBuilder("sound/play");
		snapSoundRequest.addParam("type", Sound.type.ui);
		snapSoundRequest.addParam("filename", Sound.click);
		HtmlServer.sendRequestWithCallback(snapSoundRequest.toString());
	}
};


/**
 * TouchReceiver is a static class that handles all touch events.
 * It adds touch event handlers and keeps track of what types of objects are being touched/dragged.
 */
function TouchReceiver() {
	const TR = TouchReceiver;   // shorthand
	TR.mouse = DebugOptions.shouldUseMouseMode();   // Use true when debugging on a desktop.
	TR.longTouchInterval = 700;   // The number of ms before a touch is considered a long touch.
	TR.fixScrollingInterval = 100;   // Duration between firing fix scroll timer
	TR.blocksMoving = false;   // No BlockStacks are currently moving.
	TR.targetType = "none";   // Stores the type of object being interacted with.
	TR.touchDown = false;   // Is a finger currently on the screen?
	TR.longTouch = false;   // Has the event already been handled by a long touch event?
	TR.target = null;   // The object being interacted with.
	TR.startX = 0;   // The x coord of the initial touch.
	TR.startY = 0;   // The y coord of the initial touch.
	TR.startX2 = 0;   // The x coord of the second touch.
	TR.startY2 = 0;   // The y coord of the second touch.
	TR.longTouchTimer = null;   // Triggers long touch events.
	TR.timerRunning = false;   // Indicates if the long touch timer is running.
	TR.zooming = false;   // There are not two touches on the screen.
	TR.dragging = false;   // Whether the user is dragging their finger
	TR.moveThreshold = 10;   // The minimum threshold before we consider the user to be dragging the screen
	TR.interactionEnabeled = true;   // Whether touches should be responded to
	TR.interactionTimeOut = null;
	let handlerMove = "touchmove";   // Handlers are different for touchscreens and mice.
	let handlerUp = "touchend";
	let handlerDown = "touchstart";
	if (TR.mouse) {
		handlerMove = "mousemove";
		handlerUp = "mouseup";
		handlerDown = "mousedown";
	}
	TR.handlerMove = handlerMove;
	TR.handlerUp = handlerUp;
	TR.handlerDown = handlerDown;
	// Add event handlers for handlerMove and handlerUp events to the whole document.
	TR.addListeners();
	// TR.test=true;
}
/** 
 * Adds event handlers for handlerMove and handlerUp events to the whole document.
 */
TouchReceiver.addListeners = function() {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(document.body, TR.handlerMove, TouchReceiver.handleMove, false);
	TR.addEventListenerSafe(document.body, TR.handlerUp, TouchReceiver.handleUp, false);
	TR.addEventListenerSafe(document.body, TR.handlerDown, TouchReceiver.handleDocumentDown, false);
};

/** 
 * Handles movement events and prevents drag gestures from scrolling document.
 * @param {event} event - passed event arguments.
 */
TouchReceiver.handleMove = function(event) {
	TouchReceiver.touchmove(event);   // Deal with movement.
};

/** 
 * Handles end of touch events
 * @param {event} event - passed event arguments.
 */
TouchReceiver.handleUp = function(event) {
	TouchReceiver.touchend(event);
};

/**
 * Handles new touch events
 * @param {event} event
 */
TouchReceiver.handleDocumentDown = function(event) {
	if (TouchReceiver.touchstart(event)) {
		Overlay.closeOverlays();   // Close any visible overlays.
	}
};

/**
 * Ignores interaction from the user until enableInteraction is called or the timeout expires
 * @param {number} timeOut
 */
TouchReceiver.disableInteraction = function(timeOut) {
	const TR = TouchReceiver;
	TR.interactionEnabeled = false;
	TR.interactionTimeOut = window.setTimeout(function() {
		TouchReceiver.enableInteraction();
	}, timeOut);
};

/**
 * Re-enables interaction
 */
TouchReceiver.enableInteraction = function() {
	const TR = TouchReceiver;
	TR.interactionEnabeled = true;
	if (TR.interactionTimeOut != null) {
		window.clearTimeout(TR.interactionTimeOut);
		TR.interactionTimeOut = null;
	}
};

/**
 * Returns the touch x coord from the event arguments
 * @param {event} e - passed event arguments.
 * @return {number} - x coord.
 */
TouchReceiver.getX = function(e) {
	if (TouchReceiver.mouse) {   // Depends on if a desktop or touchscreen is being used.
		return e.clientX / GuiElements.zoomFactor;
	}
	return e.touches[0].pageX / GuiElements.zoomFactor;
};

/**
 * Returns the touch y coord from the event arguments
 * @param {event} e - passed event arguments.
 * @return {number} - y coord.
 */
TouchReceiver.getY = function(e) {
	if (TouchReceiver.mouse) {   // Depends on if a desktop or touchscreen is being used.
		return e.clientY / GuiElements.zoomFactor;
	}
	return e.touches[0].pageY / GuiElements.zoomFactor;
};

/**
 * Returns the touch x coord at the specified index
 * @param {event} e
 * @param {number} i
 * @return {number}
 */
TouchReceiver.getTouchX = function(e, i) {
	return e.touches[i].pageX / GuiElements.zoomFactor;
};

/**
 * Returns the touch y coord at the specified index
 * @param {event} e
 * @param {number} i
 * @return {number}
 */
TouchReceiver.getTouchY = function(e, i) {
	return e.touches[i].pageY / GuiElements.zoomFactor;
};

/**
 * Handles new touch events.  Does not know which element was touched, the information is filled in by the calling
 * function.  Returns whether the touch is started
 * @param {event} e - passed event arguments.
 * @param {boolean=true} [preventD] - Whether preventDefault should be called. Should not be called on scrollable items
 * @return {boolean} - returns true iff !TR.touchDown
 */
TouchReceiver.touchstart = function(e, preventD) {
	const TR = TouchReceiver;
	if (!TR.interactionEnabeled) {
		e.preventDefault();
		return false;
	}
	if (preventD == null) {
		preventD = true;
	}
	if (preventD) {
		// GuiElements.alert("Prevented 1");
		e.preventDefault();   // Stops 300 ms delay events
	}
	// e.stopPropagation();
	const startTouch = !TR.touchDown;
	if (startTouch) {   // prevents multitouch issues.
		TR.stopLongTouchTimer();
		TR.dragging = false;
		TR.touchDown = true;
		TR.targetType = "none";   // Does not know the target of the touch.
		TR.target = null;
		TR.longTouch = false;
		TR.startX = TR.getX(e);
		TR.startY = TR.getY(e);
	}
	return startTouch;
};

/**
 * Checks if the application should start zooming.  Only called in response to a new touch on the canvas
 * @param {event} e
 */
TouchReceiver.checkStartZoom = function(e) {
	const TR = TouchReceiver;   // shorthand
	if (!TR.zooming && !TR.mouse && e.touches.length >= 2) {
		// There must be 2 touches in touch mode and not already be zooming
		// We know the current touch is on the canvas
		if ((!TR.dragging && TR.targetIsInTabSpace()) || TabManager.scrolling) {
			// If the previous touch started on the canvas and we aren't dragging, we start to zoom.
			// If the tab is scrolling and a new touch is on the canvas, we start scrolling.
			TR.dragging = true;
			if (TabManager.scrolling) {
				TabManager.endScroll();
				// First we stop dragging the canvas
			}
			// Now we get the data to start zooming
			TR.zooming = true;
			TR.startX = TR.getTouchX(e, 0);
			TR.startY = TR.getTouchY(e, 0);
			TR.startX2 = TR.getTouchX(e, 1);
			TR.startY2 = TR.getTouchY(e, 1);
			TabManager.startZooming(TR.startX, TR.startY, TR.startX2, TR.startY2);
		}
	}
};

/**
 * Returns whether the current touch is in the canvas
 * @return {boolean}
 */
TouchReceiver.targetIsInTabSpace = function() {
	const TR = TouchReceiver;
	if (TR.targetType === "tabSpace") {
		return true;
	} else if (TR.targetType === "block") {
		return true;
	} else if (TR.targetType === "slot") {
		// Have to make sure it isn't a slot on the BlockPalette
		return !TR.target.parent.stack.isDisplayStack;
	}
	return false;
};

/**
 * Handles new touch events for Blocks.  Stores the target Block.
 * @param {Block} target - The Block that was touched.
 * @param {event} e - passed event arguments.
 * @fix rename to touchStartBlock.
 */
TouchReceiver.touchStartBlock = function(target, e) {
	const TR = TouchReceiver;
	if (!target.stack.isDisplayStack) {
		TR.checkStartZoom(e);
	}
	if (TR.touchstart(e)) {
		Overlay.closeOverlays();   // Close any visible overlays.
		if (target.stack.isDisplayStack) {   // Determine what type of stack the Block is a member of.
			TR.targetType = "displayStack";
			TR.setLongTouchTimer();
		} else {
			TR.targetType = "block";
			TR.setLongTouchTimer();
		}
		TouchReceiver.target = target;   // Store target Block.
	}
};
/**
 * Handles new touch events for Slots.  Stores the target Slot.
 * @param {Slot} slot - The Slot that was touched.
 * @param {event} e - passed event arguments.
 */
TouchReceiver.touchStartSlot = function(slot, e) {
	const TR = TouchReceiver;
	if (!slot.parent.stack.isDisplayStack) {
		TR.checkStartZoom(e);
	}
	if (TR.touchstart(e)) {
		if (!slot.isEditable() || slot.isEditing() !== true) {
			Overlay.closeOverlays();   // Close any visible overlays.
		}
		TR.targetType = "slot";
		TouchReceiver.target = slot;   // Store target Slot.
		TR.setLongTouchTimer();
	}
};
/**
 * Handles new touch events for CategoryBNs.  Stores the target CategoryBN.
 * @param {Category} target - The Category of the CategoryBN that was touched.
 * @param {event} e - passed event arguments.
 */
TouchReceiver.touchStartCatBN = function(target, e) {
	const TR = TouchReceiver;
	if (TR.touchstart(e)) {
		Overlay.closeOverlays();   // Close any visible overlays.
		TR.targetType = "category";
		target.select();   // Makes the button light up and the category become visible.
		Overlay.closeOverlays();   // Close any visible overlays.
	}
};
/**
 * Handles new touch events for Buttons.  Stores the target Button.
 * @param {Button} target - The Button that was touched.
 * @param {event} e - passed event arguments.
 */
TouchReceiver.touchStartBN = function(target, e) {
	const TR = TouchReceiver;
	const shouldPreventDefault = !target.scrollable && target.menuBnList == null;
	if (!shouldPreventDefault) {
		e.stopPropagation();   // Prevent other calls from preventing default
	}
	if (TR.touchstart(e, shouldPreventDefault)) {
		Overlay.closeOverlaysExcept(target.partOfOverlay);
		TR.setLongTouchTimer();
		TR.targetType = "button";
		TR.target = target;
		target.press();   // Changes the button's appearance and may trigger an action.
	}
};
/**
 * @param {SmoothScrollBox} target
 * @param {event} e - passed event arguments.
 */
TouchReceiver.touchStartScrollBox = function(target, e) {
	const TR = TouchReceiver;
	if (TR.touchstart(e, false)) {
		Overlay.closeOverlaysExcept(target.partOfOverlay);
		TR.targetType = "scrollBox";
		TR.target = target;
		e.stopPropagation();
	}
};
/**
 * @param {event} e
 */
TouchReceiver.touchStartTabSpace = function(e) {
	const TR = TouchReceiver;
	TR.checkStartZoom(e);
	if (TR.touchstart(e)) {
		Overlay.closeOverlays();   // Close any visible overlays.
		TR.targetType = "tabSpace";
		TR.target = null;
	}
};
/**
 * @param {event} e
 */
TouchReceiver.touchStartDisplayBox = function(e) {
	const TR = TouchReceiver;
	if (TR.touchstart(e)) {
		Overlay.closeOverlays();   // Close any visible overlays.
		TR.targetType = "displayBox";
		TR.target = null;
		DisplayBoxManager.hide();   // Close all overlays
		// Avoids a bug where the touchEnd handler is never called if the object the user touched is removed
		TR.touchDown = false;
		e.stopPropagation();
	}
};
/**
 * @param {event} e
 */
TouchReceiver.touchStartOverlayPart = function(e) {
	const TR = TouchReceiver;
	if (TR.touchstart(e)) {

	}
};
/**
 * @param {SmoothMenuBnList} target
 * @param e
 */
TouchReceiver.touchStartSmoothMenuBnList = function(target, e) {
	const TR = TouchReceiver;
	if (TR.touchstart(e, false)) {
		Overlay.closeOverlaysExcept(target.partOfOverlay);
		TR.targetType = "smoothMenuBnList";
		TouchReceiver.target = target;   // Store target.
		e.stopPropagation();
	}
};
/**
 * @param {TabRow} tabRow
 * @param {number} index - The index of the tab that was tapped
 * @param e
 */
TouchReceiver.touchStartTabRow = function(tabRow, index, e) {
	const TR = TouchReceiver;
	if (TR.touchstart(e)) {
		Overlay.closeOverlaysExcept(tabRow.partOfOverlay);
		TR.targetType = "tabrow";
		tabRow.selectTab(index);
	}
};
/**
 * @param {CollapsibleItem} collapsibleItem
 * @param e
 */
TouchReceiver.touchStartCollapsibleItem = function(collapsibleItem, e) {
	const TR = TouchReceiver;
	if (TR.touchstart(e, false)) {
		Overlay.closeOverlays();
		TR.targetType = "collapsibleItem";
		TR.target = collapsibleItem;
		e.stopPropagation();
	}
};

/**
 * Handles touch movement events.  Tells stacks, Blocks, Buttons, etc. how to respond.
 * @param {event} e - passed event arguments.
 */
TouchReceiver.touchmove = function(e) {
	const TR = TouchReceiver;
	let shouldPreventDefault = true;   // Don't prevent default if the target scrolls
	if (!TR.interactionEnabeled) {
		e.preventDefault();
		return;
	}
	// We start dragging when the touch moves outside the threshold
	if (TR.touchDown && (TR.hasMovedOutsideThreshold(e) || TR.dragging)) {
		TR.dragging = true;
		TR.stopLongTouchTimer();
		if (TR.longTouch) {
			Overlay.closeOverlays();
			TR.longTouch = false;
		}
		if (TR.zooming) {
			// If we are currently zooming, we update the zoom.
			if (e.touches.length < 2) {
				TR.touchend(e);
			} else {
				const x1 = TR.getTouchX(e, 0);
				const y1 = TR.getTouchY(e, 0);
				const x2 = TR.getTouchX(e, 1);
				const y2 = TR.getTouchY(e, 1);
				TabManager.updateZooming(x1, y1, x2, y2);
			}
		} else {
			// If the user drags a Slot, the block they are dragging should become the target.
			if (TR.targetType === "slot") {
				TR.target = TR.target.parent;   // Now the user is dragging a block.
				if (TR.target.stack.isDisplayStack) {
					TR.targetType = "displayStack";
				} else {
					TR.targetType = "block";
				}
			}
			/* If the user drags a Block that is in a DisplayStack,
			 the DisplayStack copies to a new BlockStack, which can be dragged. */
			if (TR.targetType === "displayStack") {
				const x = TR.target.stack.getAbsX();
				const y = TR.target.stack.getAbsY();
				// The first block of the duplicated BlockStack is the new target.
				TR.target = TR.target.stack.duplicate(x, y).firstBlock;
				TR.targetType = "block";
			}
			/* If the user drags a Block that is a member of a BlockStack,
			 then the BlockStack should move. */
			if (TR.targetType === "block") {
				// If the CodeManager has not started the movement, this must be done first.
				let x = TR.getX(e);
				let y = TR.getY(e);
				if (TR.blocksMoving) {
					// The CodeManager handles moving BlockStacks.
					CodeManager.move.update(x, y);
				} else {
					CodeManager.move.start(TR.target, x, y);
					TR.blocksMoving = true;
				}
			}
			// If the user drags the palette, it should scroll.
			if (TR.targetType === "scrollBox") {
				shouldPreventDefault = false;
			}
			// If the user drags the tab space, it should scroll.
			if (TR.targetType === "tabSpace") {
				if (!TabManager.scrolling) {
					TabManager.startScroll(TR.getX(e), TR.getY(e));
				} else {
					TabManager.updateScroll(TR.getX(e), TR.getY(e));
				}
			}
			// If the user drags a button and it has a menuBnList, it should scroll it.
			if (TR.targetType === "button") {
				TR.target.interrupt();
				if (TR.target.scrollable) {
					TR.targetType = "smoothMenuBnList";
					TR.target.interrupt();
					TR.target = null;
				}
			}
			// If the user drags a smoothMenuBnList, it should scroll.
			if (TR.targetType === "smoothMenuBnList") {
				shouldPreventDefault = false;
			}
			// If the user drags a collapsibleItem, it should scroll
			if (TR.targetType === "collapsibleItem") {
				shouldPreventDefault = false;
				TR.targetType = "scrollBox";
				TR.target = null;
			}
		}
	}
	shouldPreventDefault &= TR.targetType !== "smoothMenuBnList";
	shouldPreventDefault &= TR.targetType !== "button" || !TR.target.scrollable;
	shouldPreventDefault &= TR.targetType !== "scrollBox";
	shouldPreventDefault &= TR.targetType !== "collapsibleItem";
	if (shouldPreventDefault) {
		// GuiElements.alert("Prevented 2 t:" + TR.targetType + "!");
		e.preventDefault();
	}
};

/**
 * Returns whether the touch has moved outside the threshold and should be considered a drag
 * @param {event} e
 * @return {boolean}
 */
TouchReceiver.hasMovedOutsideThreshold = function(e) {
	const TR = TouchReceiver;
	if (!TR.touchDown) return false;
	const distX = TR.startX - TR.getX(e);
	const distY = TR.startY - TR.getY(e);
	return (distX * distX + distY * distY >= TR.moveThreshold * TR.moveThreshold);
};

/**
 * Handles touch end events.  Tells stacks, Blocks, Buttons, etc. how to respond.
 * @param {event} e - passed event arguments.
 * @fix DateTime is no longer necessary to prevent repeat events.
 */
TouchReceiver.touchend = function(e) {
	const TR = TouchReceiver;
	let shouldPreventDefault = true;
	if (TR.zooming) {
		if (e.touches.length === 0) {
			TabManager.endZooming();
			TR.zooming = false;
			TR.touchDown = false;
		} else if (e.touches.length === 1) {
			// Switch from zooming to panning
			TabManager.endZooming();
			TR.zooming = false;
			TR.targetType = "tabSpace";
			TR.target = null;
			TabManager.startScroll(TR.getX(e), TR.getY(e));
		} else if (e.touches.length > 1) {
			// No action necessary
		}
	} else if (TR.touchDown && !TR.longTouch) {   // Prevents multitouch problems.
		TR.touchDown = false;
		TR.dragging = false;
		if (TR.targetType === "block") {
			if (TR.blocksMoving) {   // If a stack is moving, tell the CodeManager to end the movement.
				CodeManager.move.end();
				TR.blocksMoving = false;
			} else {   // The stack was tapped, so it should run.
				TR.target.stack.startRun();
			}
		} else if (TR.targetType === "button") {
			TR.target.release();   // Pass message on to button.
		} else if (TR.targetType === "slot") {
			// If a Slot is pressed and released without dragging, it is time to edit its value.
			TR.target.onTap();
		} else if (TR.targetType === "scrollBox") {
			shouldPreventDefault = false;
		} else if (TR.targetType === "tabSpace") {
			TabManager.endScroll();
		} else if (TR.targetType === "smoothMenuBnList") {
			shouldPreventDefault = false;
		} else if (TR.targetType === "collapsibleItem") {
			TR.target.toggle();
		}
	} else {
		TR.touchDown = false;
	}
	if (shouldPreventDefault) {
		// GuiElements.alert("Prevented 3");
		e.preventDefault();
	}
};

/**
 * Called when a user's interaction with the screen should be interrupted due to a dialog, etc.
 * Blocks that are moving should stop moving, but actions should not be triggered.
 */
TouchReceiver.touchInterrupt = function() {
	const TR = TouchReceiver;
	const touchWasDown = TR.touchDown;
	TR.touchDown = false;
	if (touchWasDown && !TR.longTouch) {   // Only interrupt if there is a finger on the screen.
		TR.touchDown = false;
		if (TR.targetType === "block") {
			if (TR.blocksMoving) {   // If a stack is moving, tell the CodeManager to end the movement.
				CodeManager.move.interrupt();
				TR.blocksMoving = false;
			}
		} else if (TR.targetType === "button") {
			TR.target.interrupt();   // Remove the highlight without triggering the action.
		} else if (TR.targetType === "tabSpace") {
			TabManager.endScroll();
		}
	}
};

/**
 * Triggered when the longTouchTimer tics.  Potentially shows a context menu
 */
TouchReceiver.touchLong = function() {
	const TR = TouchReceiver;
	TR.stopLongTouchTimer();
	if (TR.touchDown && !TR.zooming) {
		if (TR.targetType === "slot") {
			TR.target = TR.target.parent;   // Now the user is holding a block.
			if (TR.target.stack.isDisplayStack) {
				TR.targetType = "displayStack";
			} else {
				TR.targetType = "block";
			}
		}
		if (TR.targetType === "displayStack") {
			// Show the menu for variables
			if (TR.target.blockTypeName === "B_Variable" || TR.target.blockTypeName === "B_List") {
				TR.longTouch = true;
				new BlockContextMenu(TR.target, TR.startX, TR.startY);
			}
		}
		if (TR.targetType === "block") {
			TR.longTouch = true;
			new BlockContextMenu(TR.target, TR.startX, TR.startY);
		}
		if (TR.targetType === "button") {
			TR.target.longTouch();
		}
	}
};

/**
 * Starts the longTouchTimer
 */
TouchReceiver.setLongTouchTimer = function() {
	const TR = TouchReceiver;
	TR.stopLongTouchTimer();
	TR.longTouchTimer = self.setInterval(function() {
		TouchReceiver.touchLong();
	}, TR.longTouchInterval);
	TR.timerRunning = true;
};

/**
 * Stops the longTouchTimer
 */
TouchReceiver.stopLongTouchTimer = function() {
	const TR = TouchReceiver;
	if (TR.timerRunning) {
		TR.longTouchTimer = window.clearInterval(this.longTouchTimer);
		TR.timerRunning = false;
	}
};

/**
 * Adds handlerDown listeners to the parts of a CategoryBN.
 * @param {Element} element - The part of the CategoryBN the listeners are being applied to.
 * @param {Category} category - The category of the CategoryBN.
 */
TouchReceiver.addListenersCat = function(element, category) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		// When it is touched, the SVG element will tell the TouchReceiver its Category.
		TouchReceiver.touchStartCatBN(category, e);
	}, false);
};
/**
 * Adds handlerDown listeners to the parts of a Block.
 * @param {Element} element - The part of the Block the listeners are being applied to.
 * @param {Block} parent - The Block the SVG element belongs to.
 */
TouchReceiver.addListenersChild = function(element, parent) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		// When it is touched, the SVG element will tell the TouchReceiver its Block.
		TouchReceiver.touchStartBlock(parent, e);
	}, false);
};
/**
 * Adds handlerDown listeners to the parts of a Slot.
 * @param {Element} element - The part of the Slot the listeners are being applied to.
 * @param {Slot} slot - The Slot the SVG element belongs to.
 */
TouchReceiver.addListenersSlot = function(element, slot) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		// When it is touched, the SVG element will tell the TouchReceiver its Slot.
		TouchReceiver.touchStartSlot(slot, e);
	}, false);
};
/**
 * Adds handlerDown listeners to the parts of a Button.
 * @param {Element} element - The part of the Button the listeners are being applied to.
 * @param {Button} parent - The Button the SVG element belongs to.
 */
TouchReceiver.addListenersBN = function(element, parent) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		// When it is touched, the SVG element will tell the TouchReceiver its Button.
		TouchReceiver.touchStartBN(parent, e);
	}, false);
};
/**
 * @param {Element} element
 * @param {SmoothScrollBox} parent
 */
TouchReceiver.addListenersScrollBox = function(element, parent) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		// When it is touched, the SVG element will tell the TouchReceiver.
		TouchReceiver.touchStartScrollBox(parent, e);
	}, false);
};
/**
 * Adds handlerDown listeners to the background space in the Tab where blocks go. Used for scrolling.
 * @param {Element} element
 */
TouchReceiver.addListenersTabSpace = function(element) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		// When it is touched, the SVG element will tell the TabManager.
		TouchReceiver.touchStartTabSpace(e);
	}, false);
};
/**
 * Adds handlerDown listeners to the parts of the displayBox.
 * @param {Element} element - The part of the displayBox the listeners are being applied to.
 */
TouchReceiver.addListenersDisplayBox = function(element) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		// When it is touched, the SVG element will tell the TouchReceiver.
		TouchReceiver.touchStartDisplayBox(e);
	}, false);
};
/**
 * @param {Element} element
 * @param {TabRow} tabRow
 * @param {number} index
 */
TouchReceiver.addListenersTabRow = function(element, tabRow, index) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		TouchReceiver.touchStartTabRow(tabRow, index, e);
		TR.touchDown = false;
		e.stopPropagation();
	}, false);
};
/**
 * Adds handlerDown listeners to the parts of any overlay that do not already have handlers.
 * @param {Element} element - The part the listeners are being applied to.
 */
TouchReceiver.addListenersOverlayPart = function(element) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		TouchReceiver.touchStartOverlayPart(e);
	}, false);
};
/**
 * @param {Element} element
 * @param {SmoothMenuBnList} parent
 */
TouchReceiver.addListenersSmoothMenuBnListScrollRect = function(element, parent) {
	const TR = TouchReceiver;
	element.parent = parent;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		TouchReceiver.touchStartSmoothMenuBnList(this.parent, e);
	}, false);
};
/**
 * @param {Element} element
 * @param {CollapsibleItem} item
 */
TouchReceiver.addListenersCollapsibleItem = function(element, item) {
	const TR = TouchReceiver;
	TR.addEventListenerSafe(element, TR.handlerDown, function(e) {
		TouchReceiver.touchStartCollapsibleItem(item, e);
	}, false);
};

/**
 * Makes the element call the function when the right type of listener is triggered.  The function is made safe by
 * DebugOptions so errors can be caught
 * @param {Element} element - The element to add the listeners to
 * @param {string} type - The listener to add
 * @param {function} func - The function to call when the listener is triggered
 */
TouchReceiver.addEventListenerSafe = function(element, type, func) {
	element.addEventListener(type, DebugOptions.safeFunc(func), false);
};

/**
 * Creates a timer that deals with a bug in iOS that occurs if the user tries to scroll an object that is already
 * at its maximum or minimum position.  The timer regularly checks the scroll and moves it 1 pixel if it is at either
 * extreme
 * @param {Element} div - The div to fix
 * @param {object|null} [statusObj] - An object with boolean field .still which is updates to indicate whether
 *                                    the div has stopped scrolling
 * @return {number|null} - The id of the timer or null
 */
TouchReceiver.createScrollFixTimer = function(div, statusObj) {
	// If the timer isn't necessary and there is no status object, there is no reason to make the timer
	if (!GuiElements.isIos && statusObj == null) return null;
	const mem = {};
	// Used to detect scrolling
	mem.lastY = null;
	mem.lastX = null;
	const fixScroll = function() {
		const stillY = mem.lastY == null || mem.lastY === div.scrollTop;
		const stillX = mem.lastX == null || mem.lastX === div.scrollLeft;
		const still = stillX && stillY;

		// Update status object
		if (statusObj != null) statusObj.still = still;
		// Do no more if we don't have to
		if (!GuiElements.isIos) return;

		mem.lastY = div.scrollTop;
		mem.lastX = div.scrollLeft;

		const height = parseInt(window.getComputedStyle(div).getPropertyValue('height'), 10);
		// Don't do the fix until the div stops moving
		if (TouchReceiver.touchDown || !still) return;
		// The div can't move so it doesn't matter
		if (div.scrollHeight === height) return;
		if (div.scrollTop <= 0) {
			// The div is at the top; move it down
			div.scrollTop = 1;
		} else if (div.scrollHeight - height - 1 <= div.scrollTop && div.scrollTop > 2) {
			// The div is at the bottom and is tall enough that moving up won't move it to the top.  Move it up.
			div.scrollTop = div.scrollHeight - height - 2;
		}
	};
	TouchReceiver.setInitialScrollFix(div);
	return self.setInterval(fixScroll, TouchReceiver.fixScrollingInterval);
};

/**
 * Gives the div an initial bump away from the top. If called when the div is created, prevents the div from jumping
 * visually
 * @param {Element} div
 */
TouchReceiver.setInitialScrollFix = function(div) {
	if (!GuiElements.isIos) return;
	if (div.scrollTop <= 0) {
		div.scrollTop = 1;
	}
};
/**
 * The bar at the top of the screen.  The TitleBar is a static class which builds the title bar when TitleBar() is
 * called by GuiElements.  It changes its appearance on small screens, becoming shorter and adding a show/hide button
 * to show/hide the BlockPalette.  Its title shows the name of the current project.
 */
function TitleBar() {
	let TB = TitleBar;
	TB.titleTextVisble = true;
	TB.titleText = "";
	TB.prevTitleText = "";
	TB.debugEnabled = false;
	TitleBar.createBar();
	TitleBar.makeButtons();
	TitleBar.makeTitleText();
}

/**
 * The TitleBar must set certain graphics before the BlockPalette, but others after.  Thus it has two setGraphics
 * functions.
 */
TitleBar.setGraphicsPart1 = function() {
	const TB = TitleBar;
	if (GuiElements.smallMode) {
		TB.height = 35;
		TB.buttonMargin = Button.defaultMargin / 2;
	} else {
		TB.height = 54;
		TB.buttonMargin = Button.defaultMargin;
	}
	TB.width = GuiElements.width;
	TB.buttonW = TB.height * 64 / 54;

	const maxBnWidth = (TB.width - 11 * TB.buttonMargin - DeviceStatusLight.radius * 2) / 7;
	TB.buttonW = Math.min(maxBnWidth, TB.buttonW);

	TB.longButtonW = 85;
	TB.bnIconMargin = 3;
	TB.bg = Colors.black;
	TB.flagFill = "#0f0";
	TB.stopFill = "#f00";
	TB.titleColor = Colors.white;
	TB.font = Font.uiFont(16).bold();

	TB.buttonH = TB.height - 2 * TB.buttonMargin;
	TB.bnIconH = TB.buttonH - 2 * TB.bnIconMargin;
	const maxIconHeight = maxBnWidth * 0.7;
	TB.bnIconH = Math.min(maxIconHeight, TB.bnIconH);
	TB.shortButtonW = TB.buttonH;
	TB.shortButtonW = TB.buttonW;

};

TitleBar.setGraphicsPart2 = function() {
	/* Compute the locations of all the buttons */
	const TB = TitleBar;
	TB.stopBnX = GuiElements.width - TB.buttonW - TB.buttonMargin;
	TB.flagBnX = TB.stopBnX - TB.buttonW - TB.buttonMargin;
	TB.undoBnX = TB.flagBnX - TB.buttonW - 3 * TB.buttonMargin;
	TB.debugX = TB.undoBnX - TB.longButtonW - 3 * TB.buttonMargin;

	TB.fileBnX = TB.buttonMargin;
	if (GuiElements.smallMode) {
		TB.showBnX = TB.buttonMargin;
		TB.fileBnX = TB.showBnX + TB.buttonMargin + TB.shortButtonW;
	}
	TB.viewBnX = TB.fileBnX + TB.buttonMargin + TB.buttonW;
	TB.hummingbirdBnX = BlockPalette.width - Button.defaultMargin - TB.buttonW;

	TB.titleLeftX = BlockPalette.width;
	TB.titleRightX = TB.undoBnX - TB.buttonMargin;
	TB.titleWidth = TB.titleRightX - TB.titleLeftX;

	let suggestedUndoBnX = TB.hummingbirdBnX + TB.buttonW + TB.buttonMargin;
	if (TB.undoBnX < suggestedUndoBnX) {
		TB.hummingbirdBnX = TB.undoBnX - TB.buttonW - TB.buttonMargin;
	}
	TB.statusX = TB.hummingbirdBnX - TB.buttonMargin - DeviceStatusLight.radius * 2;
};

/**
 * Creates the rectangle for the TitleBar
 */
TitleBar.createBar = function() {
	const TB = TitleBar;
	TB.bgRect = GuiElements.draw.rect(0, 0, TB.width, TB.height, TB.bg);
	GuiElements.layers.titleBg.appendChild(TB.bgRect);
};

/**
 * Creates all the buttons and menus
 */
TitleBar.makeButtons = function() {
	const TB = TitleBar;
	const TBLayer = GuiElements.layers.titlebar;
	TB.flagBn = new Button(TB.flagBnX, TB.buttonMargin, TB.buttonW, TB.buttonH, TBLayer);
	TB.flagBn.addColorIcon(VectorPaths.flag, TB.bnIconH, TB.flagFill);
	TB.flagBn.setCallbackFunction(CodeManager.eventFlagClicked, false);
	TB.stopBn = new Button(TB.stopBnX, TB.buttonMargin, TB.buttonW, TB.buttonH, TBLayer);
	TB.stopBn.addColorIcon(VectorPaths.stop, TB.bnIconH, TB.stopFill);
	TB.stopBn.setCallbackFunction(CodeManager.stop, false);

	TB.deviceStatusLight = new DeviceStatusLight(TB.statusX, TB.height / 2, TBLayer, DeviceManager);
	TB.hummingbirdBn = new Button(TB.hummingbirdBnX, TB.buttonMargin, TB.buttonW, TB.buttonH, TBLayer);
	TB.hummingbirdBn.addIcon(VectorPaths.connect, TB.bnIconH * 0.8);
	TB.hummingbirdMenu = new DeviceMenu(TB.hummingbirdBn);

	if (GuiElements.smallMode) {
		TB.showHideBn = new ShowHideButton(this.showBnX, TB.buttonMargin, TB.buttonW, TB.buttonH, TBLayer, TB.bnIconH);
		TB.showHideBn.setCallbackFunctions(GuiElements.showPaletteLayers, GuiElements.hidePaletteLayers);
		TB.showHideBn.build(GuiElements.paletteLayersVisible);
	} else {
		TB.showHideBn = null;
	}

	TB.fileBn = new Button(TB.fileBnX, TB.buttonMargin, TB.buttonW, TB.buttonH, TBLayer);
	TB.fileBn.addIcon(VectorPaths.file, TB.bnIconH);
	TB.fileBn.setCallbackFunction(OpenDialog.closeFileAndShowDialog, true);

	TB.viewBn = new Button(TB.viewBnX, TB.buttonMargin, TB.buttonW, TB.buttonH, TBLayer);
	TB.viewBn.addIcon(VectorPaths.settings, TB.bnIconH);
	TB.viewMenu = new SettingsMenu(TB.viewBn);
	TB.viewBn.setLongTouchFunction(function() {
		//DialogManager.showAlertDialog("Test", "Test", "Test");
		GuiElements.alert("Long touch");
		TB.viewMenu.reloadAdvanced();
	});

	TB.undoButton = new Button(TB.undoBnX, TB.buttonMargin, TB.buttonW, TB.buttonH, TBLayer);
	TB.undoButton.addIcon(VectorPaths.undoDelete, TB.bnIconH * 0.9);
	UndoManager.setUndoButton(TB.undoButton);

	TB.debugBn = null;
	if (TB.debugEnabled) {
		TB.enableDebug();
	}
};

/**
 * Removes all the buttons so they can be redrawn
 */
TitleBar.removeButtons = function() {
	let TB = TitleBar;
	TB.flagBn.remove();
	TB.stopBn.remove();
	TB.fileBn.remove();
	TB.viewBn.remove();
	TB.undoButton.remove();
	TB.hummingbirdBn.remove();
	if (TB.debugBn != null) TB.debugBn.remove();
	if (TB.showHideBn != null) TB.showHideBn.remove();
	TB.deviceStatusLight.remove();
};

/**
 * Makes the text element for the TitleBar
 */
TitleBar.makeTitleText = function() {
	const TB = TitleBar;
	TB.titleLabel = GuiElements.draw.text(0, 0, "", TB.font, TB.titleColor);
	GuiElements.layers.titlebar.appendChild(TB.titleLabel);
};

/**
 * Sets the text of the TitleBar
 * @param {string|null} text - The text to display or null if there is no text
 */
TitleBar.setText = function(text) {
	const TB = TitleBar;
	if (text == null) text = TB.prevTitleText;
	else TB.prevTitleText = text;
	TB.titleText = text;
	TitleBar.updateText();
};

/**
 * Moves the text to the correct position
 */
TitleBar.updateText = function() {
	let TB = TitleBar;
	if (GuiElements.width < BlockPalette.width * 2) {
		if (TB.titleTextVisble) {
			// The text doesn't fit.  Hide it.
			TB.titleLabel.remove();
			TB.titleTextVisble = false;
		}
	} else {
		if (!TB.titleTextVisble) {
			// The text fits but is hidden. Show it.
			GuiElements.layers.titlebar.appendChild(TB.titleLabel);
			TB.titleTextVisble = true;
		}
		let maxWidth = TB.titleWidth;
		GuiElements.update.textLimitWidth(TB.titleLabel, TB.titleText, maxWidth);
		let width = GuiElements.measure.textWidth(TB.titleLabel);
		let x = GuiElements.width / 2 - width / 2;
		let y = TB.height / 2 + TB.font.charHeight / 2;
		if (x < TB.titleLeftX) {
			x = TB.titleLeftX;
		} else if (x + width > TB.titleRightX) {
			x = TB.titleRightX - width;
		}
		GuiElements.move.text(TB.titleLabel, x, y);
	}
};

/**
 * Builds the debug Button
 */
TitleBar.enableDebug = function() {
	const TB = TitleBar;
	TB.debugEnabled = true;
	const TBLayer = GuiElements.layers.titlebar;
	if (TB.debugBn == null) {
		TB.debugBn = new Button(TB.debugX, TB.buttonMargin, TB.longButtonW, TB.buttonH, TBLayer);
		TB.debugBn.addText("Debug");
		TB.debugMenu = new DebugMenu(TB.debugBn);
	}
};

/**
 * Hides the debug button
 */
TitleBar.hideDebug = function() {
	TitleBar.debugEnabled = false;
	TitleBar.debugBn.remove();
	TitleBar.debugBn = null;
};

/**
 * Like setGraphics, there are two updateZoom functions
 */
TitleBar.updateZoomPart1 = function() {
	TitleBar.setGraphicsPart1();
};

/**
 * Redraws the buttons
 */
TitleBar.updateZoomPart2 = function() {
	let TB = TitleBar;
	let viewShowing = TB.viewBn.toggled;
	TB.setGraphicsPart2();
	GuiElements.update.rect(TB.bgRect, 0, 0, TB.width, TB.height);
	TitleBar.removeButtons();
	TitleBar.makeButtons();
	if (viewShowing) {
		// This menu must stay open even while resizing
		TB.viewBn.press();
		TB.viewBn.release();
		// Pressing the button shows the menu.
	}
	TB.updateText();
};


/**
 * The BlockPalette is the side panel on the left that holds all the Blocks.  BlockPalette is a static class, since
 * there is only one Palette.  The BlockPalette class creates and manages a set of Categories, each of which
 * controls the Blocks inside it and the CategoryBN that brings it into the foreground.
 */
function BlockPalette() {
	BlockPalette.categories = [];   // List of categories
	BlockPalette.selectedCat = null;   // category in the foreground
	BlockPalette.createCatBg();   // Black bar along left side of screen
	BlockPalette.createPalBg();   // Dark gray rectangle behind the CategoryBNs
	BlockPalette.createCategories();
	BlockPalette.selectFirstCat();
	BlockPalette.visible = true;
	// Stores a group featuring a trash icon that appears when Blocks are dragged over it
	BlockPalette.trash = null;
	if (GuiElements.paletteLayersVisible && SettingsManager.sideBarVisible.getValue() !== "true") {
		// Hide the Palette if it should be hidden but isn't
		GuiElements.hidePaletteLayers(true);
	}
}
BlockPalette.setGraphics = function() {

	// Dimensions used within a category
	BlockPalette.mainVMargin = 10;   // The space before the first Block in a Category
	BlockPalette.mainHMargin = Button.defaultMargin;   // The space between the Blocks and the left side of the screen
	BlockPalette.blockMargin = 5;   // The vertical spacing between Blocks
	BlockPalette.sectionMargin = 10;   // The additional space added between sections
	BlockPalette.insideBnH = 38;   // Height of buttons within a category (such as Create Variable button)
	BlockPalette.insideBnW = 150;   // Width of buttons within a category

	// Dimensions for the region with CategoryBNs
	BlockPalette.width = 253;
	BlockPalette.catVMargin = Button.defaultMargin;   // Margins between buttons
	BlockPalette.catHMargin = Button.defaultMargin;
	BlockPalette.catH = 30 * 3 + BlockPalette.catVMargin * 3;   // 3 rows of BNs, 3 margins, 30 = height per BN
	BlockPalette.height = GuiElements.height - TitleBar.height - BlockPalette.catH;
	BlockPalette.catY = TitleBar.height;
	BlockPalette.y = BlockPalette.catY + BlockPalette.catH;
	BlockPalette.bg = Colors.darkDarkGray;
	BlockPalette.catBg = Colors.darkDarkGray;

	BlockPalette.labelFont = Font.uiFont(13);
	BlockPalette.labelColor = Colors.white;

	BlockPalette.trashOpacity = 0.8;
	BlockPalette.trashHeight = 120;
	BlockPalette.trashColor = Colors.white;
};

/**
 * Called when the zoom level changes or the screen is resized to recompute dimensions
 */
BlockPalette.updateZoom = function() {
	let BP = BlockPalette;
	BP.setGraphics();
	GuiElements.update.rect(BP.palRect, 0, BP.y, BP.width, BP.height);
	GuiElements.update.rect(BP.catRect, 0, BP.catY, BP.width, BP.catH);
	GuiElements.move.group(GuiElements.layers.categories, 0, TitleBar.height);
	for (let i = 0; i < BlockPalette.categories.length; i++) {
		BlockPalette.categories[i].updateZoom();
	}
};

/**
 * Creates the gray rectangle below the CategoryBNs
 */
BlockPalette.createCatBg = function() {
	let BP = BlockPalette;
	BP.catRect = GuiElements.draw.rect(0, BP.catY, BP.width, BP.catH, BP.catBg);
	GuiElements.layers.catBg.appendChild(BP.catRect);
	GuiElements.move.group(GuiElements.layers.categories, 0, TitleBar.height);
};

/**
 * Creates the long black rectangle on the left of the screen
 */
BlockPalette.createPalBg = function() {
	let BP = BlockPalette;
	BP.palRect = GuiElements.draw.rect(0, BP.y, BP.width, BP.height, BP.bg);
	GuiElements.layers.paletteBG.appendChild(BP.palRect);
};

/**
 * Creates the categories listed in the BlockList
 */
BlockPalette.createCategories = function() {
	const catCount = BlockList.catCount();
	const numberOfRows = Math.ceil(catCount / 2);

	// Automatically alternates between two columns while adding categories
	const col1X = BlockPalette.catHMargin;
	const col2X = BlockPalette.catHMargin + CategoryBN.hMargin + CategoryBN.width;

	let firstColumn = true;
	let currentY = BlockPalette.catVMargin;
	let currentX = col1X;
	let usedRows = 0;
	for (let i = 0; i < catCount; i++) {
		if (firstColumn && usedRows >= numberOfRows) {
			currentX = col2X;
			firstColumn = false;
			currentY = BlockPalette.catVMargin;
		}
		const currentCat = new Category(currentX, currentY, BlockList.getCatName(i), BlockList.getCatId(i));
		BlockPalette.categories.push(currentCat);
		usedRows++;
		currentY += CategoryBN.height + CategoryBN.vMargin;
	}
};

/**
 * Retrieves the category with the given id.  Called when a specific category needs to be refreshed
 * @param {string} id
 * @return {Category}
 */
BlockPalette.getCategory = function(id) {
	let i = 0;
	while (BlockPalette.categories[i].id !== id) {
		i++;
	}
	return BlockPalette.categories[i];
};

/**
 * Selects the first category, making it visible on the screen
 */
BlockPalette.selectFirstCat = function() {
	BlockPalette.categories[0].select();
};

/**
 * Determines whether the specified point is over the Palette.  Used for determining if Blocks should be deleted
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
BlockPalette.isStackOverPalette = function(x, y) {
	const BP = BlockPalette;
	if (!GuiElements.paletteLayersVisible) return false;
	return CodeManager.move.pInRange(x, y, 0, BP.catY, BP.width, GuiElements.height - TitleBar.height);
};

/**
 * Makes a trash can icon appear over the Palette to indicate that the Blocks being dragged will be deleted
 */
BlockPalette.showTrash = function() {
	let BP = BlockPalette;
	// If the trash is not visible
	if (!BP.trash) {
		BP.trash = GuiElements.create.group(0, 0);
		let trashBg = GuiElements.draw.rect(0, BP.y, BP.width, BP.height, BP.bg);
		GuiElements.update.opacity(trashBg, BP.trashOpacity);
		BP.trash.appendChild(trashBg);

		let trashWidth = VectorIcon.computeWidth(VectorPaths.trash, BP.trashHeight);
		let imgX = BP.width / 2 - trashWidth / 2; // Center X
		let imgY = BP.y + BP.height / 2 - BP.trashHeight / 2; // Center Y
		let trashIcon = new VectorIcon(imgX, imgY, VectorPaths.trash, BP.trashColor, BP.trashHeight, BP.trash);

		// Add to group
		GuiElements.layers.trash.appendChild(BP.trash);
	}
};

/**
 * Removes the trash icon
 */
BlockPalette.hideTrash = function() {
	let BP = BlockPalette;
	if (BP.trash) {
		BP.trash.remove();
		BP.trash = null;
	}
};

/**
 * Recursively tells a specific section of a category to expand/collapse
 * @param {string} id - The id of the section
 * @param {boolean} collapsed - Whether the section should expand or collapse
 */
BlockPalette.setSuggestedCollapse = function(id, collapsed) {
	BlockPalette.passRecursively("setSuggestedCollapse", id, collapsed);
};

/**
 * Recursively tells categories that a file is now open
 */
BlockPalette.markOpen = function() {
	BlockPalette.passRecursively("markOpen");
};

/**
 * Recursively passes message to all children (Categories and their children) of the Palette
 * @param {string} message
 */
BlockPalette.passRecursivelyDown = function(message) {
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	BlockPalette.passRecursively.apply(BlockPalette, arguments);
};

/**
 * Recursively passes a message to all categories
 * @param {string} functionName - The function to call on each category
 */
BlockPalette.passRecursively = function(functionName) {
	const args = Array.prototype.slice.call(arguments, 1);
	BlockPalette.categories.forEach(function(category) {
		category[functionName].apply(category, args);
	});
};

/**
 * Reloads all categories.  Called when a new file is opened.
 */
BlockPalette.refresh = function() {
	BlockPalette.categories.forEach(function(category) {
		category.refreshGroup();
	})
};
/**
 * DisplayStacks are used for holding Blocks in the BlockPalette.
 * DisplayStacks are similar to BlockStacks but cannot run the Blocks inside them.  When a Block in a DisplayStack
 * is dragged, it is duplicated into a BlockStack.  Like BlockStacks, they require a Block to be created
 * @param {Block} firstBlock - The first Block in the DisplayStack
 * @param {Element} group - The group the DisplayStack should be inside
 * @param {Category} category - The category the DisplayStack is a member of
 * @constructor
 */
function DisplayStack(firstBlock, group, category) {
	this.firstBlock = firstBlock;
	// Location determined by first Block
	this.x = firstBlock.getAbsX();
	this.y = firstBlock.getAbsY();
	this.group = GuiElements.create.group(this.x, this.y, group);
	this.category = category;
	this.firstBlock.changeStack(this);
	this.dim = {};
	// Dimensions of regions command blocks can be attached to.
	this.dim.cw = 0;
	this.dim.ch = 0;
	// Dimensions of regions reporter/predicate blocks can be attached to.
	this.dim.rw = 0;
	this.dim.rh = 0;
	this.updateDim();
	this.isRunning = false;
	this.currentBlock = null;
	this.isDisplayStack = true;
	this.move(this.x, this.y);
}

/**
 * Computes the dimensions of the Stack and stores them
 */
DisplayStack.prototype.updateDim = function() {
	// Reset values to defaults
	this.dim.cAssigned = false;
	this.dim.rAssigned = false;
	this.firstBlock.updateDim();
	this.firstBlock.updateAlign(0, 0);
	this.dim.cx1 = this.firstBlock.x;
	this.dim.cy1 = this.firstBlock.y;
	this.dim.cx2 = this.dim.cx1;
	this.dim.cy2 = this.dim.cy1;
	this.dim.rx1 = 0;
	this.dim.ry1 = 0;
	this.dim.rx2 = 0;
	this.dim.ry2 = 0;
	// Block expands bounding box to encompass it
	this.firstBlock.updateStackDim();

	// Compute dimensions from bounding box
	this.dim.cw = this.dim.cx2 - this.dim.cx1;
	this.dim.ch = this.dim.cy2 - this.dim.cy1;
	this.dim.rw = this.dim.rx2 - this.dim.rx1;
	this.dim.rh = this.dim.ry2 - this.dim.ry1;

	// Convert to abs coords
	// TODO: see if these are used anywhere
	this.dim.cx1 = this.relToAbsX(this.dim.cx1);
	this.dim.cy1 = this.relToAbsY(this.dim.cy1);
	this.dim.rx1 = this.relToAbsX(this.dim.rx1);
	this.dim.ry1 = this.relToAbsY(this.dim.ry1);

	// Notify category that size has changed
	this.category.updateWidth();
};

/**
 * @param {number} x
 * @return {number}
 */
DisplayStack.prototype.relToAbsX = function(x) {
	return this.category.relToAbsX(x + this.x);
};
/**
 * @param {number} y
 * @return {number}
 */
DisplayStack.prototype.relToAbsY = function(y) {
	return this.category.relToAbsY(y + this.y);
};
/**
 * @param {number} x
 * @return {number}
 */
DisplayStack.prototype.absToRelX = function(x) {
	return this.category.absToRelX(x) - this.x;
};
/**
 * @param {number} y
 * @return {number}
 */
DisplayStack.prototype.absToRelY = function(y) {
	return this.category.absToRelY(y) - this.y;
};
/**
 * @return {number}
 */
DisplayStack.prototype.getAbsX = function() {
	return this.relToAbsX(0);
};
/**
 * @return {number}
 */
DisplayStack.prototype.getAbsY = function() {
	return this.relToAbsY(0);
};

/**
 * Moves the Stack to the specified coords
 * @param {number} x - Relative x coord
 * @param {number} y - Relative y coord
 */
DisplayStack.prototype.move = function(x, y) {
	this.x = x;
	this.y = y;
	GuiElements.move.group(this.group, x, y);
};

/**
 * Copies the DisplayStack to the specified location
 * TODO: check if these are abs or rel coords
 * @param {number} x - Relative x coord
 * @param {number} y - Relative y coord
 * @return {BlockStack}
 */
DisplayStack.prototype.duplicate = function(x, y) {
	const tab = TabManager.activeTab;
	const firstCopyBlock = this.firstBlock.duplicate(x, y);
	return new BlockStack(firstCopyBlock, tab);
};

/**
 * Removes the DisplayStack
 */
DisplayStack.prototype.remove = function() {
	this.group.remove();
};

/**
 * @param deviceClass
 */
DisplayStack.prototype.hideDeviceDropDowns = function(deviceClass) {
	this.updateDim();
};

/**
 * @param deviceClass
 */
DisplayStack.prototype.showDeviceDropDowns = function(deviceClass) {
	this.updateDim();
};

/**
 * @param {string} message
 */
DisplayStack.prototype.passRecursivelyDown = function(message) {
	const myMessage = message;
	let funArgs = Array.prototype.slice.call(arguments, 1);

	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);

	if(myMessage === "showDeviceDropDowns" && this.showDeviceDropDowns != null) {
		this.showDeviceDropDowns.apply(this, funArgs);
	}
	if(myMessage === "hideDeviceDropDowns" && this.hideDeviceDropDowns != null) {
		this.hideDeviceDropDowns.apply(this, funArgs);
	}
};

/**
 * @param {string} functionName
 */
DisplayStack.prototype.passRecursively = function(functionName) {
	let args = Array.prototype.slice.call(arguments, 1);
	this.firstBlock[functionName].apply(this.firstBlock, args);
};
/**
 * A button shown in the BlockPalette and used to activate a Category
 * @param {number} x
 * @param {number} y
 * @param {Category} category
 * @constructor
 */
function CategoryBN(x, y, category) {
	this.x = x;
	this.y = y;
	this.category = category;
	this.text = this.category.name;
	this.catId = this.category.id;
	this.fill = Colors.getGradient(this.catId);
	this.buildGraphics();
}

CategoryBN.setGraphics = function() {
	const BP = BlockPalette;
	const CBN = CategoryBN;
	CBN.bg = Colors.darkDarkGray;
	CBN.font = Font.uiFont(15);
	CBN.foreground = "#fff";
	CBN.height = 30;
	CBN.colorW = 8;   // The width of the band of color on the left
	CBN.labelLMargin = 6;   // The amount of space between the text of the button and the band of color

	CBN.hMargin = BP.catHMargin;
	CBN.width = (BP.width - 2 * BP.catHMargin - CBN.hMargin) / 2;
	const numberOfRows = Math.ceil(BlockList.catCount() / 2);
	CBN.vMargin = (BP.catH - BP.catVMargin - numberOfRows * CBN.height) / (numberOfRows - 1);
	CBN.labelX = CBN.colorW + CBN.labelLMargin;
	CBN.labelY = (CBN.height + CBN.font.charHeight) / 2;
};

/**
 * Renders the visuals of the CategoryBN
 */
CategoryBN.prototype.buildGraphics = function() {
	const CBN = CategoryBN;
	this.group = GuiElements.create.group(this.x, this.y, GuiElements.layers.categories);
	this.bgRect = GuiElements.draw.rect(0, 0, CBN.width, CBN.height, CBN.bg);
	this.colorRect = GuiElements.draw.rect(0, 0, CBN.colorW, CBN.height, this.fill);
	this.label = GuiElements.draw.text(CBN.labelX, CBN.labelY, this.text, CBN.font, CBN.foreground);
	this.group.appendChild(this.bgRect);
	this.group.appendChild(this.colorRect);
	this.group.appendChild(this.label);
	GuiElements.layers.categories.appendChild(this.group);
	this.addListeners();
};

/**
 * Makes the button appear selected
 */
CategoryBN.prototype.select = function() {
	this.bgRect.setAttributeNS(null, "fill", this.fill);
};

/**
 * Makes the button appear deselected
 */
CategoryBN.prototype.deselect = function() {
	this.bgRect.setAttributeNS(null, "fill", CategoryBN.bg);
};

/**
 * Adds event listeners to the parts of the button
 */
CategoryBN.prototype.addListeners = function() {
	const TR = TouchReceiver;
	const cat = this.category;
	TouchReceiver.addListenersCat(this.bgRect, cat);
	TouchReceiver.addListenersCat(this.colorRect, cat);
	TouchReceiver.addListenersCat(this.label, cat);
};
/**
 * Represents a selection of Blocks available in the BlockPalette.  Each Category has a button which, when pressed,
 * brings it to the foreground.
 * The contents of a category is determined by the BlockList static class. Each category has a dedicated function in
 * BlockList that populates its contents.
 *
 * @param {number} buttonX - The x coord of the CategoryBN's location
 * @param {number} buttonY - The y coord of the CategoryBN
 * @param {string} name - The display name of the category to show on the button
 * @param {string} id - The id used to refer to the category
 * @constructor
 */
function Category(buttonX, buttonY, name, id) {
	this.buttonX = buttonX;
	this.buttonY = buttonY;
	this.id = id;
	this.name = name;

	this.x = 0;
	this.y = TitleBar.height + BlockPalette.catH;

	this.group = GuiElements.create.group(0, 0);
	this.smoothScrollBox = new SmoothScrollBox(this.group, GuiElements.layers.paletteScroll, 0, BlockPalette.y,
		BlockPalette.width, BlockPalette.height, 0, 0);
	this.button = new CategoryBN(this.buttonX, this.buttonY, this);

	this.prepareToFill();
	this.fillGroup();
}

/**
 * Prepares this Category to be filled with Block/Buttons/etc.
 */
Category.prototype.prepareToFill = function() {
	// Initialize arrays to track contents
	this.blocks = [];
	this.displayStacks = [];
	this.buttons = [];
	this.labels = [];
	this.collapsibleSets = [];
	this.buttonsThatRequireFiles = [];

	// Keep track of current position in category
	this.currentBlockX = BlockPalette.mainHMargin;
	this.currentBlockY = BlockPalette.mainVMargin;
	this.lastHadStud = false;

	// Used to determine when filling the category is done
	this.finalized = false;
};

/**
 * Uses a function in BlockList to fill this Category, and marks the Category as finalized once filled.
 */
Category.prototype.fillGroup = function() {
	DebugOptions.assert(!this.finalized);
	BlockList["populateCat_" + this.id](this);
	this.finalize();
};

/**
 * Removes all contents of the category so it can be rebuilt
 */
Category.prototype.clearGroup = function() {
	this.displayStacks.forEach(function(stack) {
		stack.remove();
	});
	this.buttons.forEach(function(button) {
		button.remove();
	});
	this.labels.forEach(function(label) {
		label.remove();
	});
	this.collapsibleSets.forEach(function(set) {
		set.remove();
	});
};

/**
 * Removes all contents and rebuilds the category.  Called when available blocks should change
 */
Category.prototype.refreshGroup = function() {
	this.clearGroup();
	this.prepareToFill();
	this.fillGroup();
};

/**
 * Marks this category as no longer being filled
 */
Category.prototype.finalize = function() {
	DebugOptions.assert(!this.finalized);
	this.finalized = true;
	this.height = this.currentBlockY;
	this.updateWidth();
};

/**
 * Add a Block with the specified name
 * @param {string} blockName
 */
Category.prototype.addBlockByName = function(blockName) {
	DebugOptions.assert(!this.finalized);
	const block = new window[blockName](this.currentBlockX, this.currentBlockY);
	this.addBlock(block);
};

/**
 * Add a Variable Block for the specified variable
 * @param {Variable} variable
 */
Category.prototype.addVariableBlock = function(variable) {
	DebugOptions.assert(!this.finalized);
	const block = new B_Variable(this.currentBlockX, this.currentBlockY, variable);
	this.addBlock(block);
};

/**
 * Add a List Block for the specified List
 * @param {List} list
 */
Category.prototype.addListBlock = function(list) {
	DebugOptions.assert(!this.finalized);
	const block = new B_List(this.currentBlockX, this.currentBlockY, list);
	this.addBlock(block);
};

/**
 * Add a Block that has already been created
 * @param {Block} block
 */
Category.prototype.addBlock = function(block) {
	DebugOptions.assert(!this.finalized);
	this.blocks.push(block);
	// If the last Block had a stud and the top of this Block is flat, we shift this Block down a bit
	if (this.lastHadStud && !block.topOpen) {
		this.currentBlockY += BlockGraphics.command.bumpDepth;
		block.move(this.currentBlockX, this.currentBlockY);
	}
	// If this Block is a hat block, we make room for the hat
	if (block.hasHat) {
		this.currentBlockY += BlockGraphics.hat.hatHEstimate;
		block.move(this.currentBlockX, this.currentBlockY);
	}
	// We put the Block in a DisplayStack
	const displayStack = new DisplayStack(block, this.group, this);
	this.displayStacks.push(displayStack);
	// Update the coords for the next Block
	this.currentBlockY += displayStack.firstBlock.height;
	this.currentBlockY += BlockPalette.blockMargin;
	this.lastHadStud = block.bottomOpen;
};

/**
 * Creates and adds a CollapsibleSet with a CollapsibleItem for each entry in the nameIdList.
 * Used in the Robots category
 * @param {Array<object>} nameIdList - An array or objects, each with fields for name and id
 * @return {CollapsibleSet}
 */
Category.prototype.addCollapsibleSet = function(nameIdList) {
	DebugOptions.assert(!this.finalized);
	const x = this.currentBlockX;
	const y = this.currentBlockY;
	const set = new CollapsibleSet(y, nameIdList, this, this.group);
	this.collapsibleSets.push(set);
	this.lastHadStud = false;
	this.currentBlockY += set.height;
	this.currentBlockY += BlockPalette.blockMargin;
	return set;
};

/**
 * Adds space between Blocks to denote sections
 */
Category.prototype.addSpace = function() {
	DebugOptions.assert(!this.finalized);
	this.currentBlockY += BlockPalette.sectionMargin;
};

/**
 * Adds a Button with the specified callback function
 * @param {string} text - The text to place on the Button
 * @param {function} callback - Called when the Button is tapped
 * @param {boolean} [onlyEnabledIfOpen=false] - Whether the Button should only be enabled if a file is open (Ex: the Record Bn)
 * @return {Button} - The created button
 */
Category.prototype.addButton = function(text, callback, onlyEnabledIfOpen) {
	DebugOptions.assert(!this.finalized);
	if (onlyEnabledIfOpen == null) {
		onlyEnabledIfOpen = false;
	}

	const width = BlockPalette.insideBnW;
	const height = BlockPalette.insideBnH;
	if (this.lastHadStud) {
		this.currentBlockY += BlockGraphics.command.bumpDepth;
	}

	const button = new Button(this.currentBlockX, this.currentBlockY, width, height, this.group);
	const BP = BlockPalette;
	button.addText(text);
	button.setCallbackFunction(callback, true);
	this.currentBlockY += height;
	this.currentBlockY += BlockPalette.blockMargin;
	this.buttons.push(button);
	this.lastHadStud = false;
	if (onlyEnabledIfOpen) {
		if(!SaveManager.fileIsOpen()) {
			button.disable();
		}
		this.buttonsThatRequireFiles.push(button);
	}
	return button;
};

/**
 * Adds a text label
 * @param {string} text - The text to display
 */
Category.prototype.addLabel = function(text) {
	DebugOptions.assert(!this.finalized);
	const BP = BlockPalette;
	const x = this.currentBlockX;
	const y = this.currentBlockY;
	const labelE = GuiElements.draw.text(x, y, text, BP.labelFont, BP.labelColor);
	this.group.appendChild(labelE);
	this.labels.push(labelE);
	const height = GuiElements.measure.textHeight(labelE);
	GuiElements.move.element(labelE, x, y + height);
	this.currentBlockY += height;
	this.currentBlockY += BlockPalette.blockMargin;
	this.lastHadStud = false;
};

/**
 * Removes some of the space at the bottom so the height measurement is correct
 */
Category.prototype.trimBottom = function() {
	DebugOptions.assert(!this.finalized);
	if (this.lastHadStud) {
		this.currentBlockY += BlockGraphics.command.bumpDepth;
	}
	this.currentBlockY -= BlockPalette.blockMargin;
	this.currentBlockY += BlockPalette.mainVMargin;
};

/**
 * Brings the category to the foreground and marks it as selected in the BlockPalette
 */
Category.prototype.select = function() {
	if (BlockPalette.selectedCat === this) {
		return;
	}
	if (BlockPalette.selectedCat != null) {
		BlockPalette.selectedCat.deselect();
	}
	BlockPalette.selectedCat = this;
	this.button.select();
	this.smoothScrollBox.show();
};

/**
 * Removes the category from the foreground
 */
Category.prototype.deselect = function() {
	BlockPalette.selectedCat = null;
	this.smoothScrollBox.hide();
	this.button.deselect();
};

/**
 * Computes the width of the Category and stores it in this.width
 */
Category.prototype.computeWidth = function() {
	let currentWidth = 0;
	// The width is the maximum width across DisplayStacks and CollapsibleSets
	for (let i = 0; i < this.blocks.length; i++) {
		const blockW = this.blocks[i].width;
		if (blockW > currentWidth) {
			currentWidth = blockW;
		}
	}
	this.collapsibleSets.forEach(function(set) {
		const width = set.width;
		currentWidth = Math.max(width, currentWidth);
	});
	this.width = Math.max(currentWidth + 2 * BlockPalette.mainHMargin, BlockPalette.width);
};

/**
 * Recomputes the width of the Category and updates the smoothScrollBox to match it
 */
Category.prototype.updateWidth = function() {
	if (!this.finalized) return;
	this.computeWidth();
	this.smoothScrollBox.setContentDims(this.width, this.height);
};

/**
 * Updates the dimensions of a Category that contains a CollapsibleSet.  Called by the CollapsibleSet after
 * expand/collapse
 */
Category.prototype.updateDimSet = function() {
	if (!this.finalized) return;
	this.computeWidth();
	let currentH = BlockPalette.mainVMargin;
	this.collapsibleSets.forEach(function(set) {
		currentH += set.height;
		currentH += BlockPalette.blockMargin;
	});
	currentH -= BlockPalette.blockMargin;
	currentH += BlockPalette.mainVMargin;
	this.height = currentH;
	this.smoothScrollBox.setContentDims(this.width, this.height);
};

/**
 * Indicates that a file is now open.
 */
Category.prototype.markOpen = function() {
	this.buttonsThatRequireFiles.forEach(function(button) {
		button.enable();
	});
};

/* Convert coordinates relative to the Category to coords relative to the screen */
/**
 * @param {number} x
 * @return {number}
 */
Category.prototype.relToAbsX = function(x) {
	if (!this.finalized) return x;
	return this.smoothScrollBox.relToAbsX(x);
};
/**
 * @param {number} y
 * @return {number}
 */
Category.prototype.relToAbsY = function(y) {
	if (!this.finalized) return y;
	return this.smoothScrollBox.relToAbsY(y);
};
/**
 * @param {number} x
 * @return {number}
 */
Category.prototype.absToRelX = function(x) {
	if (!this.finalized) return x;
	return this.smoothScrollBox.absToRelX(x);
};
/**
 * @param {number} y
 * @return {number}
 */
Category.prototype.absToRelY = function(y) {
	if (!this.finalized) return y;
	return this.smoothScrollBox.absToRelY(y);
};
/**
 * @return {number}
 */
Category.prototype.getAbsX = function() {
	return this.relToAbsX(0);
};
/**
 * @return {number}
 */
Category.prototype.getAbsY = function() {
	return this.relToAbsY(0);
};

/**
 * Passes a message to Slots/Blocks/CollapsibleSets within this Category
 * @param {string} message
 */
Category.prototype.passRecursivelyDown = function(message) {
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);
};
/**
 * @param {string} functionName
 */
Category.prototype.passRecursively = function(functionName) {
	const args = Array.prototype.slice.call(arguments, 1);
	this.displayStacks.forEach(function(stack) {
		stack[functionName].apply(stack, args);
	});
	this.collapsibleSets.forEach(function(set) {
		set[functionName].apply(set, args);
	});
};

/**
 * Updates the dimensions of the category in response to a screen resize
 */
Category.prototype.updateZoom = function() {
	if (!this.finalized) return;
	this.smoothScrollBox.move(0, BlockPalette.y);
	this.smoothScrollBox.updateZoom();
	this.smoothScrollBox.setDims(BlockPalette.width, BlockPalette.height);
};

/**
 * Passes a suggested collapse/expand message to any collapsible sets within this category
 * @param {string} id
 * @param {boolean} collapsed
 */
Category.prototype.setSuggestedCollapse = function(id, collapsed) {
	this.collapsibleSets.forEach(function(set) {
		set.setSuggestedCollapse(id, collapsed);
	});
};
/**
 * Represents a set of items that can be collapsed/expanded and each contain Blocks.  Meant for use in the BlockPalette
 * @param {number} y - The y coordinate the set should appear at
 * @param {Array<object>} nameIdList - An array of entries, each containing a field for name and id
 * @param {Category} category - The Category this set is a part of
 * @param {Element} group - The SVG group element this set should be added to
 * @constructor
 */
function CollapsibleSet(y, nameIdList, category, group) {
	this.y = y;
	this.category = category;
	this.group = group;
	// Create a collapsibleItem for each entry of the nameIdList
	this.collapsibleItems = [];
	nameIdList.forEach(function(entry){
		this.collapsibleItems.push(new CollapsibleItem(entry.name, entry.id, this, group));
	}.bind(this));
	// Stack the collapsibleItems appropriately
	this.updateDimAlign();
}

CollapsibleSet.setConstants = function(){
	const CS = CollapsibleSet;
	CS.itemMargin = 0;
};

/**
 * Retrieves the CollapsibleItem at the specified index
 * @param {number} index
 * @return {CollapsibleItem}
 */
CollapsibleSet.prototype.getItem = function(index) {
	return this.collapsibleItems[index];
};

/**
 * Finds the index of a CollapsibleItem by id.  Throws an error if the item is not found
 * @param {string} id
 * @return {number}
 */
CollapsibleSet.prototype.findItem = function(id) {
	const items = this.collapsibleItems;
	for(let i = 0; i < items.length; i++) {
		if(items[i].id === id) {
			return i;
		}
	}
	DebugOptions.throw("Collapsible item not found.");
};

/**
 * Expands the collapsible item at the specified index, then updates the dimensions
 * @param {number} index
 */
CollapsibleSet.prototype.expand = function(index) {
	this.collapsibleItems[index].expand();
	this.updateDimAlign();
};

/**
 * Collapses the collapsible item at the specified index, then updates the dimensions
 * @param {number} index
 */
CollapsibleSet.prototype.collapse = function(index) {
	this.collapsibleItems[index].collapse();
	this.updateDimAlign();
};

/**
 * Updates the dimensions and alignment of the CollapsibleSet and notifies its Category to update dimensions
 */
CollapsibleSet.prototype.updateDimAlign = function() {
	const CS = CollapsibleSet;
	let currentY = this.y;
	let width = 0;
	this.collapsibleItems.forEach(function(item) {
		currentY += item.updateDimAlign(currentY);
		currentY += CS.itemMargin;
		width = Math.max(width, item.getWidth());
	});
	currentY -= CS.itemMargin;
	this.height = currentY;
	this.width = width;
	this.category.updateDimSet();
};

/**
 * Computes and stores the width of the CollapsibleSet and alerts its Category that the width may have changed
 * Triggered when a block inside changes width
 */
CollapsibleSet.prototype.updateWidth = function() {
	let width = 0;
	this.collapsibleItems.forEach(function(item) {
		width = Math.max(width, item.getWidth());
	});
	this.width = width;
	this.category.updateWidth();
};

/**
 * Removes the CollapsibleSet from the SVG
 */
CollapsibleSet.prototype.remove = function() {
	this.collapsibleItems.forEach(function(item){
		item.remove();
	});
};

/**
 * Passes a suggested expand/collapse message to all CollapsibleItems
 * @param {string} id
 * @param {boolean} collapsed
 */
CollapsibleSet.prototype.setSuggestedCollapse = function(id, collapsed) {
	this.passRecursively("setSuggestedCollapse", id, collapsed);
};

CollapsibleSet.prototype.passRecursivelyDown = function(message){
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);
};
CollapsibleSet.prototype.passRecursively = function(functionName){
	const args = Array.prototype.slice.call(arguments, 1);
	this.collapsibleItems.forEach(function(item){
		item[functionName].apply(item,args);
	});
};
/**
 * A set of DisplayStacks under a header in the BlockPalette that can expand or collapse when selected
 * @param {string} name - THe name to show in the header
 * @param {string} id - The id of this item
 * @param {CollapsibleSet} collapsibleSet - The set this item is a member of
 * @param {Element} group - The group this item should add itself to
 * @constructor
 */
function CollapsibleItem(name, id, collapsibleSet, group) {
	const CI = CollapsibleItem;
	this.x = 0;
	this.name = name;
	this.id = id;
	this.set = collapsibleSet;
	this.group = GuiElements.create.group(0, 0, group);
	// This group is where the Blocks are added.  It is right below the header and is added/removed to expand/collapse
	this.innerGroup = GuiElements.create.group(0, CI.hitboxHeight);
	this.collapsed = true;
	this.suggestedCollapse = true;
	this.createLabel();

	this.prepareToFill();
}

CollapsibleItem.setConstants = function() {
	const CI = CollapsibleItem;
	CI.hitboxHeight = 30;
	CI.hitboxWidth = BlockPalette.width;

	CI.labelFont = BlockPalette.labelFont;
	CI.labelColor = BlockPalette.labelColor;

	CI.triBoxWidth = CI.hitboxHeight;
	CI.triangleWidth = 10;
	CI.triangleHeight = 5;
};

/**
 * Creates the header above the blocks, which includes a triangle, a label, and a hit box around both
 */
CollapsibleItem.prototype.createLabel = function() {
	const CI = CollapsibleItem;

	this.triE = GuiElements.create.path();
	GuiElements.update.color(this.triE, CI.labelColor);
	this.updateTriangle();

	const labelY = (CI.hitboxHeight + CI.labelFont.charHeight) / 2;
	this.label = GuiElements.draw.text(CI.triBoxWidth, labelY, this.name, CI.labelFont, CI.labelColor);
	this.hitboxE = GuiElements.draw.rect(0, 0, CI.hitboxWidth, CI.hitboxHeight, CI.labelColor);
	GuiElements.update.opacity(this.hitboxE, 0);
	this.group.appendChild(this.label);
	this.group.appendChild(this.triE);
	this.group.appendChild(this.hitboxE);

	TouchReceiver.addListenersCollapsibleItem(this.hitboxE, this);
};

/**
 * Changes the path of the triangle to be horizontal/vertical depending on the state of the item
 */
CollapsibleItem.prototype.updateTriangle = function() {
	let vertical = !this.collapsed;
	const CI = CollapsibleItem;
	let pointX;
	let pointY;
	if (!vertical) {
		pointX = (CI.triBoxWidth + CI.triangleHeight) / 2;
		pointY = CI.hitboxHeight / 2;
	} else {
		pointX = CI.triBoxWidth / 2;
		pointY = (CI.hitboxHeight + CI.triangleHeight) / 2;
	}
	return GuiElements.update.triangleFromPoint(this.triE, pointX, pointY, CI.triangleWidth, -CI.triangleHeight, vertical);
};

/**
 * prepares the item to be filled with Blocks
 */
CollapsibleItem.prototype.prepareToFill = function() {
	this.currentBlockX = BlockPalette.mainHMargin;
	this.currentBlockY = BlockPalette.mainVMargin;
	this.blocks = [];
	this.displayStacks = [];
	this.lastHadStud = false;
	this.finalized = false;
};

/**
 * Marks this category as no longer being filled
 */
CollapsibleItem.prototype.finalize = function() {
	DebugOptions.assert(!this.finalized);
	this.finalized = true;
	this.innerHeight = this.currentBlockY;
	this.updateWidth();
};

/**
 * Add a Block with the specified name
 * @param {string} blockName
 */
CollapsibleItem.prototype.addBlockByName = function(blockName) {
	DebugOptions.assert(!this.finalized);
	const block = new window[blockName](this.currentBlockX, this.currentBlockY);
	this.addBlock(block);
};

/**
 * Add a Block that has already been created
 * @param {Block} block
 */
CollapsibleItem.prototype.addBlock = function(block) {
	DebugOptions.assert(!this.finalized);
	this.blocks.push(block);
	if (this.lastHadStud && !block.topOpen) {
		this.currentBlockY += BlockGraphics.command.bumpDepth;
		block.move(this.currentBlockX, this.currentBlockY);
	}
	if (block.hasHat) {
		this.currentBlockY += BlockGraphics.hat.hatHEstimate;
		block.move(this.currentBlockX, this.currentBlockY);
	}
	const displayStack = new DisplayStack(block, this.innerGroup, this);
	this.displayStacks.push(displayStack);
	this.currentBlockY += displayStack.firstBlock.height;
	this.currentBlockY += BlockPalette.blockMargin;
	this.lastHadStud = block.bottomOpen;
};

/**
 * Adds space between Blocks to denote sections
 */
CollapsibleItem.prototype.addSpace = function() {
	DebugOptions.assert(!this.finalized);
	this.currentBlockY += BlockPalette.sectionMargin;
};

/**
 * Removes some of the space at the bottom so the height measurement is correct
 */
CollapsibleItem.prototype.trimBottom = function() {
	DebugOptions.assert(!this.finalized);
	if (this.lastHadStud) {
		this.currentBlockY += BlockGraphics.command.bumpDepth;
	}
	this.currentBlockY -= BlockPalette.blockMargin;
	this.currentBlockY += BlockPalette.mainVMargin;
};

/**
 * Updates the dimensions and alignment of the CollapsibleItem
 * @param {number} newY - The y coord the item should have when done
 * @return {number} - The height of the item, so the next item knows where to go
 */
CollapsibleItem.prototype.updateDimAlign = function(newY) {
	this.y = newY;
	GuiElements.move.group(this.group, this.x, this.y);
	return this.getHeight();
};

/**
 * Retrieves the width of the item, given its current collapsed/expanded state
 * @return {number}
 */
CollapsibleItem.prototype.getWidth = function() {
	if (this.collapsed) {
		return 0;
	} else {
		return this.innerWidth;
	}
};

/**
 * Retrieves the height of the item, given its current collapsed/expanded state
 * @return {number}
 */
CollapsibleItem.prototype.getHeight = function() {
	const CI = CollapsibleItem;
	if (this.collapsed) {
		return CI.hitboxHeight;
	} else {
		return CI.hitboxHeight + this.innerHeight;
	}
};

/**
 * Computes and stores the width of the item
 */
CollapsibleItem.prototype.computeWidth = function() {
	let currentWidth = 0;
	for (let i = 0; i < this.blocks.length; i++) {
		const blockW = this.blocks[i].width;
		if (blockW > currentWidth) {
			currentWidth = blockW;
		}
	}
	this.innerWidth = currentWidth;
};

/**
 * Hides the Blocks below the header and tells the set to update its dimensions
 */
CollapsibleItem.prototype.collapse = function() {
	if (!this.collapsed) {
		this.collapsed = true;
		this.innerGroup.remove();
		this.updateTriangle();
		this.set.updateDimAlign();
	}
};

/**
 * Shows the Blocks below the header and tells the set to update its dimensions
 */
CollapsibleItem.prototype.expand = function() {
	if (this.collapsed) {
		this.collapsed = false;
		this.group.appendChild(this.innerGroup);
		this.updateTriangle();
		this.set.updateDimAlign();
	}
};

/**
 * Computes and stores the width of the item and tells the set to update its width
 */
CollapsibleItem.prototype.updateWidth = function() {
	this.computeWidth();
	this.set.updateWidth();
};

/* Converts between coordinates relative to the item and coordinates relative to the screen */
/**
 * @param {number} x
 * @return {number}
 */
CollapsibleItem.prototype.relToAbsX = function(x) {
	const CI = CollapsibleItem;
	return this.set.category.relToAbsX(x + this.x);
};
/**
 * @param {number} y
 * @return {number}
 */
CollapsibleItem.prototype.relToAbsY = function(y) {
	const CI = CollapsibleItem;
	return this.set.category.relToAbsY(y + this.y + CI.hitboxHeight);
};
/**
 * @param {number} x
 * @return {number}
 */
CollapsibleItem.prototype.absToRelX = function(x) {
	const CI = CollapsibleItem;
	return this.set.category.absToRelX(x) - this.x;
};
/**
 * @param {number} y
 * @return {number}
 */
CollapsibleItem.prototype.absToRelY = function(y) {
	const CI = CollapsibleItem;
	return this.set.category.absToRelY(y) - this.y - CI.hitboxHeight;
};

/**
 * Removes the item from the SVG
 */
CollapsibleItem.prototype.remove = function() {
	this.group.remove();
};

/**
 * Toggles the item's expand/collapse state
 */
CollapsibleItem.prototype.toggle = function() {
	if (this.collapsed) {
		this.expand();
	} else {
		this.collapse();
	}
};

/**
 * Prompts the item to set its expand/collapse state if it matches the id and the user has not overridden the suggested
 * state
 * @param {string} id - The id of the relevant item
 * @param {boolean} collapsed - Whether the suggested state is collapsed or expanded
 */
CollapsibleItem.prototype.setSuggestedCollapse = function(id, collapsed) {
	if (id !== this.id) return;
	/* We only change the state if the current state matches the previous suggested state.  That way if the user,
	 * for example, manually collapses the item, then connects 3 devices, it won't expand each time.
	 */
	if (collapsed !== this.suggestedCollapse) {
		this.suggestedCollapse = collapsed;
		if (collapsed) {
			this.collapse();
		} else {
			this.expand();
		}
	}
};

/* Passes messages to DisplayStacks */
CollapsibleItem.prototype.passRecursivelyDown = function(message) {
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);
};
CollapsibleItem.prototype.passRecursively = function(functionName) {
	const args = Array.prototype.slice.call(arguments, 1);
	this.displayStacks.forEach(function(stack) {
		stack[functionName].apply(stack, args);
	});
};
/**
 * A key UI element that creates a button.  Buttons can trigger a function when they are pressed/released and
 * can contain an icon, image, text, or combination.  They are drawn as soon as the constructor is called, and
 * can ten have text and callbacks added on.
 * 
 * @param {number} x - The x coord the button should appear at
 * @param {number} y - The y coord the button should appear at
 * @param {number} width - The width of the button
 * @param {number} height - The height of the button
 * @param {Element} [parent] - The group the button should append itself to
 * @constructor
 */
function Button(x, y, width, height, parent) {
	DebugOptions.validateNumbers(x, y, width, height);
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.parentGroup = parent;
	this.group = GuiElements.create.group(x, y, parent);
	this.buildBg();
	this.pressed = false;
	this.enabled = true;
	this.hasText = false;
	this.hasIcon = false;
	this.hasImage = false;
	this.textInverts = false;   // Whether the text inverts color when the button is pressed
	this.iconInverts = false;   // Whether the icon inverts color when the button is pressed
	this.callback = null;   // The function to call when the button is pressed
	this.delayedCallback = null;   // The function to call when the button is released
	this.toggles = false;   // Whether the button should stick in the pressed state until tapped again
	this.unToggleFunction = null;   // The function to call when the button is tapped to make is stop being pressed
	this.longTouchFunction = null;   // The function to call when the button is long pressed
	this.disabledTapCallback = null;   // Called when the user taps a disabled function
	this.toggled = false;   // Whether the button is currently stuck in the pressed state (only if it toggles)
	this.partOfOverlay = null;   // The overlay the button is a part of (if any)
	this.scrollable = false;   // Whether the button is part of something that scrolls and shouldn't prevent scrolling
}

Button.setGraphics = function() {
	Button.bg = Colors.darkGray;
	Button.foreground = Colors.white;
	// "highlight" = color when pressed
	Button.highlightBg = Colors.white;
	Button.highlightFore = Colors.darkGray;
	Button.disabledBg = Colors.darkGray;
	Button.disabledFore = Colors.black;

	// The suggested margin between adjacent margins
	Button.defaultMargin = 5;

	// The suggested font for the forground of buttons
	Button.defaultFont = Font.uiFont(16);

	Button.defaultIconH = 15;
	Button.defaultSideMargin = 10;
};

/**
 * Creates the rectangle that is the background of the button
 */
Button.prototype.buildBg = function() {
	this.bgRect = GuiElements.draw.rect(0, 0, this.width, this.height, Button.bg);
	this.group.appendChild(this.bgRect);
	TouchReceiver.addListenersBN(this.bgRect, this);
};

/**
 * Adds text to the button
 * @param {string} text - The text to add
 * @param {Font} [font] - The font to use (defaultFont if unspecified)
 */
Button.prototype.addText = function(text, font) {
	DebugOptions.validateNonNull(text);
	this.removeContent();
	if (font == null) {
		font = Button.defaultFont;
	}
	this.textInverts = true;

	this.textE = GuiElements.draw.text(0, 0, "", font, Button.foreground);
	GuiElements.update.textLimitWidth(this.textE, text, this.width);
	this.group.appendChild(this.textE);
	
	// Text is centered
	const textW = GuiElements.measure.textWidth(this.textE);
	const textX = (this.width - textW) / 2;
	const textY = (this.height + font.charHeight) / 2;
	GuiElements.move.text(this.textE, textX, textY);
	this.hasText = true;
	TouchReceiver.addListenersBN(this.textE, this);
};

/**
 * Adds an icon to the button
 * @param {object} pathId - Entry from VectorPaths
 * @param {number} height - The height the icon should have in the button
 */
Button.prototype.addIcon = function(pathId, height) {
	if (height == null) {
		height = Button.defaultIconH;
	}
	this.removeContent();
	this.hasIcon = true;
	this.iconInverts = true;
	// Icon is centered vertiacally and horizontally.
	const iconW = VectorIcon.computeWidth(pathId, height);
	const iconX = (this.width - iconW) / 2;
	const iconY = (this.height - height) / 2;
	this.icon = new VectorIcon(iconX, iconY, pathId, Button.foreground, height, this.group);
	TouchReceiver.addListenersBN(this.icon.pathE, this);
};

/**
 * Adds an icon and text to the button, with the icon to the left of the text separated by the specified sideMargin,
 * in the center of the button
 * @param {object} pathId - Entry from VectorPaths
 * @param {number|null} [iconHeight] - The height the icon should have in the button
 * @param {number|null} [sideMargin] - The space between the icon and the text
 * @param {string} text - The text to show
 * @param {Font|null} [font] - The font to use
 * @param {string|null} [color=null] - Color in hex, or null if text inverts and uses foreground color
 */
Button.prototype.addCenteredTextAndIcon = function(pathId, iconHeight, sideMargin, text, font, color) {
	this.removeContent();
	if (color == null) {
		color = Button.foreground;
		this.textInverts = true;
		this.iconInverts = true;
	}
	if (font == null) {
		font = Button.defaultFont;
	}
	if (iconHeight == null) {
		iconHeight = Button.defaultIconH;
	}
	if (sideMargin == null) {
		sideMargin = Button.defaultSideMargin;
	}
	this.hasIcon = true;
	this.hasText = true;

	const iconW = VectorIcon.computeWidth(pathId, iconHeight);
	this.textE = GuiElements.draw.text(0, 0, "", font, color);
	GuiElements.update.textLimitWidth(this.textE, text, this.width - iconW - sideMargin);
	this.group.appendChild(this.textE);
	const textW = GuiElements.measure.textWidth(this.textE);
	const totalW = textW + iconW + sideMargin;
	const iconX = (this.width - totalW) / 2;
	const iconY = (this.height - iconHeight) / 2;
	const textX = iconX + iconW + sideMargin;
	const textY = (this.height + font.charHeight) / 2;
	GuiElements.move.text(this.textE, textX, textY);
	TouchReceiver.addListenersBN(this.textE, this);
	this.icon = new VectorIcon(iconX, iconY, pathId, color, iconHeight, this.group);
	TouchReceiver.addListenersBN(this.icon.pathE, this);
};

/**
 * Adds an icon and text to the button, with the icon aligned to the left/right and the text centered.
 *
 * @param {object} pathId - Entry from VectorPaths
 * @param {number|null} [iconHeight] - The height the icon should have in the button
 * @param {string} text - The text to show
 * @param {Font|null} [font] - The font to use
 * @param {string|null} [color=null] - Color in hex, or null if text inverts and uses foreground color
 * @param {string|null} [iconColor=null] - Color in hex, or null if icon inverts and uses foreground color
 * @param {boolean} leftSide - Whether the icon should be aligned to the left or right of the button
 * @param {boolean} shiftCenter - Whether the text should be aligned to the center of the remaining space or
 *                                the center of the entire button
 */
Button.prototype.addSideTextAndIcon = function(pathId, iconHeight, text, font, color, iconColor, leftSide, shiftCenter) {
	this.removeContent();
	if (color == null) {
		color = this.currentForeground();
		this.textInverts = true;
	}
	if (iconColor == null) {
		iconColor = this.currentForeground();
		this.iconInverts = true;
	}
	if (font == null) {
		font = Button.defaultFont;
	}
	if (iconHeight == null) {
		iconHeight = Button.defaultIconH;
	}
	if (leftSide == null) {
		leftSide = true;
	}
	if (shiftCenter == null) {
		shiftCenter = true;
	}
	this.hasIcon = true;
	this.hasText = true;

	/* Margin between icon and side of button is equal to vertical margin */
	const sideMargin = (this.height - iconHeight) / 2;
	const iconW = VectorIcon.computeWidth(pathId, iconHeight);
	this.textE = GuiElements.draw.text(0, 0, "", font, color);
	/* Text must leave space for icon, margin between icon and text, and margins for both sides */
	const textMaxW = this.width - iconW - sideMargin * 3;
	GuiElements.update.textLimitWidth(this.textE, text, textMaxW);
	this.group.appendChild(this.textE);
	const textW = GuiElements.measure.textWidth(this.textE);

	let iconX;
	if (leftSide) {
		iconX = sideMargin;
	} else {
		iconX = this.width - iconW - sideMargin;
	}
	const iconY = (this.height - iconHeight) / 2;

	let textX;
	if (!shiftCenter) {
		textX = (this.width - textW) / 2;
	} else if (leftSide) {
		textX = (iconX + iconW + this.width - textW) / 2;
	} else {
		textX = (this.width - textW - iconW - sideMargin) / 2;
	}

	if (leftSide) {
		textX = Math.max(textX, iconX + iconW + sideMargin);
	} else {
		textX = Math.min(textX, iconX - textW - sideMargin);
	}

	const textY = (this.height + font.charHeight) / 2;
	GuiElements.move.text(this.textE, textX, textY);
	TouchReceiver.addListenersBN(this.textE, this);
	this.icon = new VectorIcon(iconX, iconY, pathId, iconColor, iconHeight, this.group);
	TouchReceiver.addListenersBN(this.icon.pathE, this);
};

/**
 * Adds an image to the button.  Use of images is discouraged since they can take time to load.  No images are used
 * as of right now.
 * @param {object} imageData - has entries for width, height, lightName, darkName.
 * @param {number} height - The height the image should have
 */
Button.prototype.addImage = function(imageData, height) {
	this.removeContent();
	const imageW = imageData.width / imageData.height * height;
	const imageX = (this.width - imageW) / 2;
	const imageY = (this.height - height) / 2;
	this.imageE = GuiElements.draw.image(imageData.lightName, imageX, imageY, imageW, height, this.group);
	this.imageData = imageData;
	this.hasImage = true;
	TouchReceiver.addListenersBN(this.imageE, this);
};

/**
 * Adds a colored icon to the button that does not invert when the icon is tapped
 * TODO: combine with addIcon using a nullable parameter for color
 * @param {object} pathId - Entry from VectorPaths
 * @param {number} height - The height of the icon
 * @param {string} color - Color in hex
 */
Button.prototype.addColorIcon = function(pathId, height, color) {
	this.removeContent();
	this.hasIcon = true;
	this.iconInverts = false;
	const iconW = VectorIcon.computeWidth(pathId, height);
	const iconX = (this.width - iconW) / 2;
	const iconY = (this.height - height) / 2;
	this.icon = new VectorIcon(iconX, iconY, pathId, color, height, this.group);
	TouchReceiver.addListenersBN(this.icon.pathE, this);
};

/**
 * Removes all icons/images/text in the button so it can be replaced
 */
Button.prototype.removeContent = function() {
	if (this.hasIcon) {
		this.icon.remove();
	}
	if (this.hasImage) {
		this.imageE.remove();
	}
	if (this.hasText) {
		this.textE.remove();
	}
};

/**
 * Sets a function to call when the button is interacted with
 * @param {function} callback
 * @param {boolean} delay - Whether the function should be called when the Button is released vs tapped
 */
Button.prototype.setCallbackFunction = function(callback, delay) {
	if (delay) {
		this.delayedCallback = callback;
	} else {
		this.callback = callback;
	}
};

/**
 * Sets the function to call when the button is untoggled and enables toggling
 * @param {function} callback
 */
Button.prototype.setUnToggleFunction = function(callback) {
	this.unToggleFunction = callback;
	this.toggles = true;
};

/**
 * Sets a function to call when the button is long touched
 * @param {function} callback
 */
Button.prototype.setLongTouchFunction = function(callback) {
	this.longTouchFunction = callback;
};

Button.prototype.setDisabledTabFunction = function(callback) {
	this.disabledTapCallback = callback;
};

/**
 * Disables the button so it cannot be interacted with
 */
Button.prototype.disable = function() {
	if (this.enabled) {
		this.enabled = false;
		this.pressed = false;
		this.bgRect.setAttributeNS(null, "fill", Button.disabledBg);
		if (this.hasText && this.textInverts) {
			this.textE.setAttributeNS(null, "fill", Button.disabledFore);
		}
		if (this.hasIcon && this.iconInverts) {
			this.icon.setColor(Button.disabledFore);
		}
	}
};

/**
 * Enables the button so it is interactive again
 */
Button.prototype.enable = function() {
	if (!this.enabled) {
		this.enabled = true;
		this.pressed = false;
		this.setColor(false);
	}
};

/**
 * Presses the button
 */
Button.prototype.press = function() {
	if (!this.pressed) {
		this.pressed = true;
		if (!this.enabled) return;
		this.setColor(true);
		if (this.callback != null) {
			this.callback();
		}
	}
};

/**
 * Releases the Button
 */
Button.prototype.release = function() {
	if (this.pressed) {
		this.pressed = false;
		if (!this.enabled) {
			if (this.disabledTapCallback != null) {
				this.disabledTapCallback();
			}
			return;
		}
		if (!this.toggles || this.toggled) {
			this.setColor(false);
		}
		if (this.toggles && this.toggled) {
			this.toggled = false;
			this.unToggleFunction();
		} else {
			if (this.delayedCallback != null) {
				this.delayedCallback();
			}
			if (this.toggles && !this.toggled) {
				this.toggled = true;
			}
		}
	}
};

/**
 * Removes the Button's visual highlight without triggering any actions
 */
Button.prototype.interrupt = function() {
	if (this.pressed && !this.toggles) {
		this.pressed = false;
		if (!this.enabled) return;
		this.setColor(false);
	}
};

/**
 * Tells the button to exit the toggled state
 */
Button.prototype.unToggle = function() {
	if (this.enabled && this.toggled) {
		this.setColor(false);
	}
	this.toggled = false;
	this.pressed = false;
};

/**
 * Runs the long touch function
 * @return {boolean} - whether the long touch function is non-null
 */
Button.prototype.longTouch = function() {
	if (this.longTouchFunction != null) {
		this.longTouchFunction();
		return true;
	}
	return false;
};

/**
 * Removes the Button (supposed to be permanent)
 */
Button.prototype.remove = function() {
	this.group.remove();
};

/**
 * Hides the button temporarily
 */
Button.prototype.hide = function() {
	this.group.remove();
};

/**
 * Makes the Button visible again
 */
Button.prototype.show = function() {
	this.parentGroup.appendChild(this.group);
};

/**
 * Moves the Button to the specified location
 * @param {number} x
 * @param {number} y
 */
Button.prototype.move = function(x, y) {
	this.x = x;
	this.y = y;
	GuiElements.move.group(this.group, this.x, this.y);
};

/**
 * Sets the color of the button and foreground to match the pressed/released state
 * @param {boolean} isPressed - Whether the button is pressed
 */
Button.prototype.setColor = function(isPressed) {
	if (isPressed) {
		this.bgRect.setAttributeNS(null, "fill", Button.highlightBg);
		if (this.hasText && this.textInverts) {
			this.textE.setAttributeNS(null, "fill", Button.highlightFore);
		}
		if (this.hasIcon && this.iconInverts) {
			this.icon.setColor(Button.highlightFore);
		}
		if (this.hasImage) {
			GuiElements.update.image(this.imageE, this.imageData.darkName);
		}
	} else {
		this.bgRect.setAttributeNS(null, "fill", Button.bg);
		if (this.hasText && this.textInverts) {
			this.textE.setAttributeNS(null, "fill", Button.foreground);
		}
		if (this.hasIcon && this.iconInverts) {
			this.icon.setColor(Button.foreground);
		}
		if (this.hasImage) {
			GuiElements.update.image(this.imageE, this.imageData.lightName);
		}
	}
};

/**
 * Marks that the Button is part of something that scrolls so it doesn't stop scrolling when it is tapped
 * (using preventDefault in TouchReceiver)
 */
Button.prototype.makeScrollable = function() {
	this.scrollable = true;
};

/**
 * Retrieves the current foreground color to use, based on the Button's state
 * @return {*}
 */
Button.prototype.currentForeground = function() {
	if (!this.enabled) {
		return Button.disabledFore;
	} else if (this.pressed) {
		return Button.highlightFore;
	} else {
		return Button.foreground;
	}
};

/**
 * Marks that the Button is part of the specified overlay so it doesn't close it when tapped
 * @param {Overlay} overlay
 */
Button.prototype.markAsOverlayPart = function(overlay) {
	this.partOfOverlay = overlay;
};

/**
 * Removes the marking that the Button is part of an overlay
 */
Button.prototype.unmarkAsOverlayPart = function() {
	this.partOfOverlay = null;
};
/**
 * A button with an arrow that shows/hides something.  Currently, this is just used for showing/hiding the palette on
 * small screens.  The button is not created until build() is called
 * @param {number} x - The x coord where the button should show up
 * @param {number} y - The y coord where the button should show up
 * @param {number} width - The width the button should have
 * @param {number} height - The height the button should have
 * @param {Element} parent - The group the button should be added to
 * @param {number} iconH - The height the icon should have
 * @constructor
 */
function ShowHideButton(x, y, width, height, parent, iconH) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.parent = parent;
	this.iconH = iconH * 0.75; // The arrow icon should actually be smaller than most other icons
	this.showFn = null;
	this.hideFn = null;
}

/**
 * The show/hide button is actually two buttons that change when one is tapped.  This function creates both of them
 * @param {boolean} isShowing - Whether the button should start in the "showing" state
 */
ShowHideButton.prototype.build = function(isShowing) {
	this.showBn = new Button(this.x, this.y, this.width, this.height, this.parent);
	this.showBn.addIcon(VectorPaths.show, this.iconH);
	this.hideBn = new Button(this.x, this.y, this.width, this.height, this.parent);
	this.hideBn.addIcon(VectorPaths.hide, this.iconH);

	// The callback functions are called when the buttons are pressed, but the button changes icon when released
	this.showBn.setCallbackFunction(this.showFn, false);
	this.hideBn.setCallbackFunction(this.hideFn, false);

	// Function to switch to the "hidden" mode
	let toggle1 = function() {
		this.showBn.hide();
		this.hideBn.show();
	}.bind(this);
	this.showBn.setCallbackFunction(toggle1, true);
	this.showBn.interrupt = function() {
		if (this.enabled && this.pressed) {
			this.pressed = false;
			this.setColor(false);
			toggle1();
		}
	};

	// Function to switch to the "showing" mode
	let toggle2 = function() {
		this.showBn.show();
		this.hideBn.hide();
	}.bind(this);
	this.hideBn.setCallbackFunction(toggle2, true);
	this.hideBn.interrupt = function() {
		if (this.enabled && this.pressed) {
			this.pressed = false;
			this.setColor(false);
			toggle2();
		}
	};

	if (isShowing) {
		this.showBn.hide();
	} else {
		this.hideBn.hide();
	}
};

/**
 * Sets the functions to call to show/hide the associated item
 * @param {function} showFn
 * @param {function} hideFn
 */
ShowHideButton.prototype.setCallbackFunctions = function(showFn, hideFn) {
	this.showFn = showFn;
	this.hideFn = hideFn;
};

/**
 * Removes the show/hide button
 */
ShowHideButton.prototype.remove = function() {
	this.showBn.remove();
	this.hideBn.remove();
};


/**
 * A small colored circle that indicates the status of a robot or group of robots according to a statusProvider
 * which must have setStatusListener and getStatus functions
 * @param {number} x - The x coord of the light
 * @param {number} centerY - The y coord of the center of the light
 * @param {Element} parent - The group this light should add itself to
 * @param {*} statusProvider - Any object with the functions setStatusListener and getStatus
 * @constructor
 */
function DeviceStatusLight(x, centerY, parent, statusProvider) {
	const DSL = DeviceStatusLight;
	this.cx = x + DSL.radius;
	this.cy = centerY;
	this.parentGroup = parent;
	this.circleE = this.generateCircle();
	this.statusProvider = statusProvider;
	// Tells the statusProvider to call updateStatus any time its status changes
	this.statusProvider.setStatusListener(this.updateStatus.bind(this));
	// Updates this light to match the current status of the provider
	this.updateStatus(statusProvider.getStatus());
}

DeviceStatusLight.setConstants = function() {
	const DSL = DeviceStatusLight;
	DSL.greenColor = "#0f0";
	DSL.redColor = "#f00";
	DSL.yellowColor = "#ff0";
	DSL.startColor = Colors.black;
	DSL.offColor = Colors.darkGray;
	DSL.radius = 6;
	DSL.updateInterval = 300;
};

/**
 * Draws the circle for the light
 */
DeviceStatusLight.prototype.generateCircle = function() {
	let DSL = DeviceStatusLight;
	return GuiElements.draw.circle(this.cx, this.cy, DSL.radius, DSL.startColor, this.parentGroup);
};

/**
 * Updates the color of the circle to correspond with the provided status
 * @param {DeviceManager.statuses} status
 */
DeviceStatusLight.prototype.updateStatus = function(status) {
	const DSL = DeviceStatusLight;
	let color = null;
	const statuses = DeviceManager.statuses;
	if (status === statuses.connected) {
		color = DSL.greenColor;
	} else if (status === statuses.oldFirmware) {
		color = DSL.yellowColor;
	} else if (status === statuses.incompatibleFirmware || status === statuses.disconnected) {
		color = DSL.redColor;
	} else {
		color = DSL.offColor;
	}
	GuiElements.update.color(this.circleE, color);
};

/**
 * Removes the light
 */
DeviceStatusLight.prototype.remove = function() {
	this.circleE.remove();
};
/* Overlay is an abstract class representing UI elements that appear over other elements and should disappear when other
 * elements are tapped.  Only one overlay of each type can exist on the screen at once. */
function Overlay(type){
	this.type = type;
}

/* Initializes the static elements of the class */
Overlay.setStatics = function(){
	/* Keeps track of open overlays */
	Overlay.openOverlays = new Set();
	/** @enum {number} */
	Overlay.types = {
		inputPad: 1,
		resultBubble: 2,
		menu: 3,
		connectionList: 4
	};
};

/**
 * All overlays have a close function, called when an overlay of the same type is opened for the user taps outside the
 * overlay
 */
Overlay.prototype.close = function() {
	DebugOptions.markAbstract();
};

/**
 * Adds the overlay to the list of open overlays and closes other overlay of the same type
 */
Overlay.prototype.addOverlayAndCloseOthers = function(){
	Overlay.closeOverlaysOfType(this.type);
	Overlay.addOverlay(this);
};

/**
 * @param {Overlay} overlay - Adds an overlay to the set of open overlays
 */
Overlay.addOverlay = function(overlay){
	if(!Overlay.openOverlays.has(overlay)) {
		Overlay.openOverlays.add(overlay);
	}
};

/**
 * @param {Overlay} overlay - Removes an overlay from the set of open overlays
 */
Overlay.removeOverlay = function(overlay){
	if(Overlay.openOverlays.has(overlay)) {
		Overlay.openOverlays.delete(overlay);
	}
};

/**
 * Closes all open overlays
 */
Overlay.closeOverlays = function(){
	Overlay.openOverlays.forEach(function(overlay){
		overlay.close();
	});
};

/**
 * Closes all open overlays except the provided overlay
 * @param {Overlay} overlay
 */
Overlay.closeOverlaysExcept = function(overlay){
	Overlay.openOverlays.forEach(function(currentOverlay){
		if(currentOverlay !== overlay) {
			currentOverlay.close();
		}
	});
};

/**
 * Closes all overlays except those of the specified type
 * @param {Overlay.types} type
 */
Overlay.closeOverlaysOfType = function(type){
	Overlay.openOverlays.forEach(function(currentOverlay){
		if(currentOverlay.type === type) {
			currentOverlay.close();
		}
	});
};
/**
 * Completely unrelated to the TabManager and Tab classes.  The TabRow provides UI for a row of tabs, which when
 * when selected call a callback function.  They are used in the ConnectMultipleDialog and OpenDialog.  A TabRow
 * is created through the constructor and Tabs are added with addTab.  show() causes the tabs to be built
 * @param {number} x - The x coord of where the TabRow should be drawn
 * @param {number} y - The y coord of where the TabRow should be drawn
 * @param {number} width - The width of the space available to the TabRow
 * @param {number} height - The height of the space available to the TabRow
 * @param {Element} parent - The group the RabRow should add itself to
 * @param {number|null} [initialTab] - The index of the tab to select first.  If null, no tab will appear selected
 * @constructor
 */
function TabRow(x, y, width, height, parent, initialTab) {
	if (initialTab == null) {
		initialTab = null;
	}
	this.tabList = [];
	this.x = x;
	this.y = y;
	this.parent = parent;
	this.width = width;
	this.height = height;
	this.callbackFn = null;
	this.selectedTab = initialTab;
	this.partOfOverlay = null;
}

TabRow.setConstants = function() {
	const TR = TabRow;
	TR.slantW = 5;
	TR.deselectedColor = Colors.darkGray;
	TR.selectedColor = Colors.black;
	TR.foregroundColor = Colors.white;

	TR.font = Font.uiFont(16).bold();

	TR.closeHeight = 30;
	TR.closeMargin = 9;
};

/**
 * Builds the tabs and shows the UI
 */
TabRow.prototype.show = function() {
	this.group = GuiElements.create.group(this.x, this.y, this.parent);
	this.createTabs();
	if (this.selectedTab != null) {
		this.visuallySelectTab(this.selectedTab);
	}
};

/**
 * Adds a tab to the list of tabs to be built
 * @param {string} text - The label to put on the tab
 * @param {*} id - The id of the tab.  Sent to the callback function when a tab is selected
 * @param {function|null} [closeFn] - The function to call when this tab is closed.  If provided, a close button will
 *                                    be drawn on the Tab
 */
TabRow.prototype.addTab = function(text, id, closeFn) {
	let entry = {};
	entry.text = text;
	entry.id = id;
	entry.closeFn = closeFn;
	this.tabList.push(entry);
};

/**
 * Renders the tabs and close buttons according to the labList
 */
TabRow.prototype.createTabs = function() {
	let tabCount = this.tabList.length;
	let tabWidth = this.width / tabCount;
	this.tabEList = [];
	this.tabList.forEach(function(entry, index) {
		const tabX = index * tabWidth;
		const hasClose = entry.closeFn != null;
		this.tabEList.push(this.createTab(index, entry.text, tabWidth, tabX, hasClose));
		if (hasClose) {
			this.createClose(tabWidth, tabX, entry.closeFn);
		}
	}.bind(this));
};

/**
 * Creates a tab with the specified label and width
 * @param {number} index - The index of the tab, used to add the correct listeners to the tab
 * @param {string} text - The text to place on the top of the tab
 * @param {number} width - The width of the tab
 * @param {number} x - The x coord of the tab
 * @param {boolean} hasClose - Whether space should be reserved for a close button
 */
TabRow.prototype.createTab = function(index, text, width, x, hasClose) {
	const TR = TabRow;

	let textMaxWidth = width - 2 * TR.slantW;
	const closeSpace = 2 * TR.closeMargin + TR.closeHeight;
	if (hasClose) {
		textMaxWidth = width - closeSpace - TR.slantW;
	}
	let tabE = GuiElements.draw.trapezoid(x, 0, width, this.height, TR.slantW, TR.deselectedColor);
	this.group.appendChild(tabE);
	let textE = GuiElements.draw.text(0, 0, "", TR.font, TR.foregroundColor);
	GuiElements.update.textLimitWidth(textE, text, textMaxWidth);

	let textW = GuiElements.measure.textWidth(textE);
	let textX = x + (width - textW) / 2;
	if (hasClose) {
		textX = Math.min(textX, x + width - textW - closeSpace);
	}
	let textY = (this.height + TR.font.charHeight) / 2;
	GuiElements.move.text(textE, textX, textY);

	TouchReceiver.addListenersTabRow(textE, this, index);
	TouchReceiver.addListenersTabRow(tabE, this, index);
	this.group.appendChild(textE);
	return tabE;
};

/**
 * Creates a button to close the tab
 * @param {number} tabX - The x coord of the tab
 * @param {number} tabW - The width of the tab
 * @param {function} closeFn - The function to call when the close button is tapped
 */
TabRow.prototype.createClose = function(tabX, tabW, closeFn) {
	const TR = TabRow;
	const cx = tabX + tabW - TR.closeMargin - TR.closeHeight / 2;
	const cy = this.height / 2;
	const closeBn = new CloseButton(cx, cy, TR.closeHeight, closeFn, this.group);
};

/**
 * Makes the tab appear selected and calls the callbackFn with the id of the selected tab.
 * @param index
 */
TabRow.prototype.selectTab = function(index) {
	if (index !== this.selectTab) {
		this.selectedTab = index;
		this.visuallySelectTab(index);   // TODO: make this also deselect the selected tab
		if (this.callbackFn != null) this.callbackFn(this.tabList[index].id);
	}
};

/**
 * Makes a tab appear selected
 * @param {number} index - The tab to select
 */
TabRow.prototype.visuallySelectTab = function(index) {
	let TR = TabRow;
	let tabE = this.tabEList[index];
	GuiElements.update.color(tabE, TR.selectedColor);
};

/**
 * Registers a callback function for when tabs are selected.  The function will be called with the id of the selected
 * tab
 * @param {function} callback - type (type of id) -> ()
 */
TabRow.prototype.setCallbackFunction = function(callback) {
	this.callbackFn = callback;
};

/**
 * Notes that the TabRow is a member of the provided overlay and shouldn't close it.
 * @param {Overlay} overlay
 */
TabRow.prototype.markAsOverlayPart = function(overlay) {
	this.partOfOverlay = overlay;
};
/**
 * A round button with an x that calls the specified function when tapped
 * @param {number} cx - The x coord of the center of the button
 * @param {number} cy - The y coord of the center of the button
 * @param {number} height - The height of the button (diameter)
 * @param {function} callbackFn - The function to call when the button is tapped
 * @param {Element} group - The SVG group to add the button to
 * @constructor
 */
function CloseButton(cx, cy, height, callbackFn, group){
	const CB = CloseButton;
	this.pressed = false;
	this.group = group;
	this.circleE = GuiElements.draw.circle(cx, cy, height / 2, CB.bg, this.group);
	const iconH = height * CB.iconHMult;
	this.icon = new VectorIcon(cx - iconH / 2, cy - iconH / 2, VectorPaths.letterX, CB.foreground, iconH, this.group);
	TouchReceiver.addListenersBN(this.icon.pathE,this);
	TouchReceiver.addListenersBN(this.circleE,this);
	this.callbackFn = callbackFn;
}

CloseButton.setGraphics=function(){
	const CB = CloseButton;
	CB.bg = Button.bg;
	CB.foreground = Button.foreground;
	CB.highlightBg = Button.highlightBg;
	CB.highlightFore = Button.highlightFore;
	CB.iconHMult = 0.5;
};

/**
 * Makes the button appear to be pressed
 */
CloseButton.prototype.press=function(){
	if(!this.pressed){
		this.pressed=true;
		this.setColor(true);
	}
};

/**
 * Makes the button appear to be released and calls the callback
 */
CloseButton.prototype.release=function(){
	if(this.pressed){
		this.pressed = false;
		this.setColor(false);
		this.callbackFn();
	}
};

/**
 * Makes the function appear to be released without triggering the callback (for when a dialog is shown)
 */
CloseButton.prototype.interrupt=function(){
	if(this.pressed){
		this.pressed = false;
		this.setColor(false);
	}
};

/**
 * Marks this button as a member of the specified overlay so it doesn't close it
 * @param {Overlay} overlay
 */
CloseButton.prototype.markAsOverlayPart = function(overlay){
	this.partOfOverlay = overlay;
};

/**
 * Sets the color of the button to match its pressed/not pressed state
 * @param {boolean} isPressed - Whether the button is pressed
 */
CloseButton.prototype.setColor = function(isPressed) {
	const CB = CloseButton;
	if (isPressed) {
		this.icon.setColor(CB.highlightFore);
		GuiElements.update.color(this.circleE, CB.highlightBg);
	} else {
		this.icon.setColor(CB.foreground);
		GuiElements.update.color(this.circleE, CB.bg);
	}
};
/**
 * An abstract class representing a way of inputting data into an EditableSlot.  Each EditableSlot can make an
 * InputSystem when it is told to edit(), which it provides with its slotShape, initial data, and functions to
 * call when editing is complete.
 * Some InputSystems require additional information, which is provided through the subclass of the constructor
 * @constructor
 */
function InputSystem(){
	this.visible = false;   // Whether the system is showing
	this.closed = false;   // Once closed, the system cannot be opened again (only shown once)
	this.cancelled = false;   // Whether the system set a value or was cancelled (for dialogs)
}

/**
 * Shows the InputSystem when the Slot is edited
 * @param {EditableSlotShape} slotShape - The slotShape of the Slot
 * @param {function} updateFn - type (Data, string) -> (), called with Data and displayText to change how the Slot looks
 * @param {function} finishFn - type (Data) -> (), called to finish editing and sets the value to Data
 * @param {Data} data - The initial Data in the Slot
 */
InputSystem.prototype.show = function(slotShape, updateFn, finishFn, data){
	DebugOptions.assert(!this.visible);
	DebugOptions.assert(!this.closed);
	this.visible = true;
	this.slotShape = slotShape;
	this.updateFn = updateFn;
	this.finishFn = finishFn;
	this.currentData = data;
};

/**
 * Closes the InputSystem and calls the finishFn to end the editing
 */
InputSystem.prototype.close = function(){
	if(this.closed) return;
	this.closed = true;
	this.visible = false;
	this.finishFn(this.currentData, this.cancelled);
};
/**
 * A dialog used to edit the value of the Slot
 * @param {string} textSummary - The textSummary of the Slot
 * @param {boolean} acceptsEmptyString - Whether the empty string is considered valid for this Slot
 * @constructor
 */
function InputDialog(textSummary, acceptsEmptyString) {
	InputSystem.call(this);
	this.textSummary = textSummary;
	this.acceptsEmptyString = acceptsEmptyString;
}

/**
 * Shows a dialog and sets the value of the Slot to whatever the user enters
 * @inheritDoc
 * @param {EditableSlotShape} slotShape
 * @param {function} updateFn
 * @param {function} finishFn
 * @param {Data} data
 */
InputDialog.prototype.show = function(slotShape, updateFn, finishFn, data) {
	InputSystem.prototype.show.call(this, slotShape, updateFn, finishFn, data);
	const oldVal = data.asString().getValue();
	// Only prefill if the data is a string.  Otherwise, display it grayed out in the background.
	const shouldPrefill = data.type === Data.types.string;
	DialogManager.showPromptDialog("Edit text", this.textSummary, oldVal, shouldPrefill, function(cancelled, response) {
		if (!cancelled && (response !== "" || this.acceptsEmptyString)) {
			// Set the data
			this.currentData = new StringData(response);
			this.cancelled = false;
		} else {
			// Mark as cancelled
			this.cancelled = true;
		}
		InputSystem.prototype.close.call(this);
	}.bind(this));
};
/**
 * An InputSystem for editing NumSlots and DropSlots, provides a set of controls (InputWidgets) in an OverlayBubble
 * which edit the Data in the Slot.
 * The InputPad is flexible as it holds a stack of varying "widgets" as determined by the Slot that constructs it.
 * Widgets are added before the InputPad is shown using addWidget.  Right now, SelectPadWidgets and NumPadWidgets
 * are the main entry mechanisms, but more widgets could be added in the future (for example, a sliders or knobs)
 *
 * The coordinates of the bubble are provided as parameters
 * @param {number} x1
 * @param {number} x2
 * @param {number} y1
 * @param {number} y2
 * @constructor
 */
function InputPad(x1, x2, y1, y2) {
	InputSystem.call(this);
	this.widgets = [];
	const coords = this.coords = {};
	coords.x1 = x1;
	coords.x2 = x2;
	coords.y1 = y1;
	coords.y2 = y2;
}
InputPad.prototype = Object.create(InputSystem.prototype);
InputPad.prototype.constructor = InputPad;

InputPad.setConstants = function() {
	const IP = InputPad;
	IP.background = Colors.black;
	IP.margin = Button.defaultMargin;
	IP.width = 160;
};

/**
 * Adds a Widget to the InputPad.  The Widget and pad will be constructed when show() is called
 * @param {InputWidget} widget - The Widget to add to the InputPad
 */
InputPad.prototype.addWidget = function(widget) {
	this.widgets.push(widget);
};

/**
 * Builds the InputPad and Widgets
 * @inheritDoc
 * @param {EditableSlotShape} slotShape
 * @param {function} updateFn
 * @param {function} finishFn
 * @param {Data} data
 */
InputPad.prototype.show = function(slotShape, updateFn, finishFn, data) {
	InputSystem.prototype.show.call(this, slotShape, updateFn, finishFn, data);
	const IP = InputPad;
	this.group = GuiElements.create.group(0, 0);
	this.updateDim();
	const type = Overlay.types.inputPad;
	const layer = GuiElements.layers.inputPad;
	const coords = this.coords;
	this.bubbleOverlay = new BubbleOverlay(type, IP.background, IP.margin, this.group, this, layer);
	this.bubbleOverlay.display(coords.x1, coords.x2, coords.y1, coords.y2, this.width, this.height);
	this.showWidgets(this.bubbleOverlay);
};

/**
 * Computes the dimensions of the InputPad and its widgets, storing them in this.width and this.height
 */
InputPad.prototype.updateDim = function() {
	const IP = InputPad;
	let height = 0;
	this.widgets.forEach(function(widget) {
		// Some widgets have adjustable heights (like SelectPads)
		if (widget.fixedHeight()) {
			// Fixed-height widgets have their height computed and stored
			widget.updateDim();
			height += widget.height;
		}
		height += IP.margin;
	});
	height -= IP.margin;
	height = Math.max(height, 0);
	const maxHeight = GuiElements.height - 2 * IP.margin;
	// The remaining available screen space is computed and allocated to adjustable-height widgets
	// TODO: currently this code only works if there is at most one adjustable-height widget
	let allocH = (maxHeight - height);
	this.widgets.forEach(function(widget) {
		if (!widget.fixedHeight()) {
			// Gives all the remaining space to this widget
			widget.setMaxHeight(allocH);
			widget.updateDim();
			// The widget might not use all the space, and only the space it does use is added
			height += widget.height;
		}
	});
	// Store the final results
	this.height = height;
	this.width = IP.width;
};

/**
 * Builds the widgets at the correct locations, assuming updateDim was already called.
 * @param {BubbleOverlay} overlay
 */
InputPad.prototype.showWidgets = function(overlay) {
	const IP = InputPad;
	let y = 0;
	for (let i = 0; i < this.widgets.length; i++) {
		this.widgets[i].show(0, y, this.group, overlay, this.slotShape, this.updateEdit.bind(this),
			this.finishEdit.bind(this), this.currentData);
		y += this.widgets[i].height + IP.margin;
	}
};

/**
 * Closes the pad and all its widgets
 * @inheritDoc
 */
InputPad.prototype.close = function() {
	if (this.closed) return;
	InputSystem.prototype.close.call(this);
	this.widgets.forEach(function(widget) {
		widget.close();
	});
	this.bubbleOverlay.close();
};

/**
 * Function called by Widgets to update Slot
 * @param {Data} newData - The Data to store in the Slot
 * @param {string} text - The text to display in the Slot
 */
InputPad.prototype.updateEdit = function(newData, text) {
	this.updateFn(newData, text);
	this.currentData = newData;
};

/**
 * Function called by widgets to finish editing Slot
 * @param {Data} newData - The Data to save to the Slot
 */
InputPad.prototype.finishEdit = function(newData) {
	this.currentData = newData;
	this.close();
};
/**
 * A pad of an InputPad which can edit the Dat stored in the Slot.  InputWidget is an abstract class and each Widget
 * is responsible for drawing its own graphics and controlling the data in the Slot being edited.  The Widget is only
 * built when show() is called.
 * @constructor
 */
function InputWidget() {
	DebugOptions.markAbstract();
}

/**
 * Builds and displays the InputWidget, providing functions to call to update the Slot being edited
 * @param {number} x - The x coord where the InputWidget should appear
 * @param {number} y - The y coord where the InputWidget should appear
 * @param {Element} parentGroup - The SVG group the elements of the widget should be added to
 * @param {BubbleOverlay} overlay - The overlay of the InputPad containing the widget. Used for getting relToAbs coords
 * @param {EditableSlotShape} slotShape - The SlotShape of the Slot being edited
 * @param {function} updateFn - type (Data, string) -> (), to call to update the Data of the InputPad
 * @param {function} finishFn - type (Data) -> (), to call to finish editing the Slot
 * @param {Data} data - The initial Data stored in the Slot
 */
InputWidget.prototype.show = function(x, y, parentGroup, overlay, slotShape, updateFn, finishFn, data) {
	this.x = x;
	this.y = y;
	this.slotShape = slotShape;
	this.updateFn = updateFn;
	this.finishFn = finishFn;
	this.overlay = overlay;
};

/**
 * Called by the InputPad to compute the size of the Widget.  Results stored in this.width and this.height
 */
InputWidget.prototype.updateDim = function() {
	DebugOptions.markAbstract();
};

/**
 * Hides the InputWidget and performs and cleanup needed
 */
InputWidget.prototype.close = function() {

};

/**
 * Returns whether this InputWidget is a fixed height (rather than adjusting based on content and available space)
 * @return {boolean}
 */
InputWidget.prototype.fixedHeight = function() {
	return true;
};

/**
 * Used to assign a maximum height to an adjustable-height widget
 * @param {number} height
 */
InputWidget.prototype.setMaxHeight = function(height) {

};
/**
 * Displays centered text in an InputPad
 * @param {string} text - The text to display
 * @constructor
 */
InputWidget.Label = function(text) {
	this.text = text;
};
InputWidget.Label.prototype = Object.create(InputWidget.prototype);
InputWidget.Label.prototype.constructor = InputWidget.Label;

InputWidget.Label.setConstants = function() {
	const L = InputWidget.Label;
	L.font = Font.uiFont(16).bold();
	L.margin = 2;
	L.color = Colors.white;
};

/**
 * @inheritDoc
 * @param {number} x
 * @param {number} y
 * @param {Element} parentGroup
 */
InputWidget.Label.prototype.show = function(x, y, parentGroup) {
	const L = InputWidget.Label;
	this.textE = GuiElements.draw.text(x, y, "", L.font, L.color);
	GuiElements.update.textLimitWidth(this.textE, this.text, InputPad.width);
	const textW = GuiElements.measure.textWidth(this.textE);
	const textX = InputPad.width / 2 - textW / 2;
	const textY = y + L.font.charHeight + L.margin;
	GuiElements.move.text(this.textE, textX, textY);
	parentGroup.appendChild(this.textE);
};

/**
 * Computes the height of the label
 */
InputWidget.Label.prototype.updateDim = function() {
	const L = InputWidget.Label;
	this.height = L.font.charHeight + 2 * L.margin;
	this.width = L.maxWidth;
};
/**
 * Used for entering numbers into Slots.  Utilizes a DisplayNum to determine how the number changes as keys are pressed
 * @param {boolean} positive - Whether the +/- key should be disabled
 * @param {boolean} integer - Whether the decimal point key should be disabled
 * @constructor
 */
InputWidget.NumPad = function(positive, integer) {
	this.positive = positive;
	this.integer = integer;
};
InputWidget.NumPad.prototype = Object.create(InputWidget.prototype);
InputWidget.NumPad.prototype.constructor = InputWidget.NumPad;

InputWidget.NumPad.setConstants = function() {
	const NP = InputWidget.NumPad;
	NP.bnMargin = InputPad.margin;
	NP.bnWidth = (InputPad.width - NP.bnMargin * 2) / 3;
	NP.bnHeight = 40;
	NP.longBnW = (InputPad.width - NP.bnMargin) / 2;
	NP.font = Font.uiFont(34).bold();
	NP.plusMinusH = 22;
	NP.bsIconH = 25;
	NP.okIconH = NP.bsIconH;
};

/**
 * @inheritDoc
 * @param {number} x
 * @param {number} y
 * @param {Element} parentGroup
 * @param {BubbleOverlay} overlay
 * @param {EditableSlotShape} slotShape
 * @param {function} updateFn
 * @param {function} finishFn
 * @param {Data} data
 */
InputWidget.NumPad.prototype.show = function(x, y, parentGroup, overlay, slotShape, updateFn, finishFn, data) {
	InputWidget.prototype.show.call(this, x, y, parentGroup, overlay, slotShape, updateFn, finishFn, data);
	this.group = GuiElements.create.group(x, y, parentGroup);
	this.displayNum = new DisplayNum(data);
	this.makeBns();
	/* The data in the Slot starts out gray to indicate that it will be deleted on modification. THe number 0 is not
	 * grayed since there's nothing to delete. */
	this.grayOutUnlessZero();
};

/**
 * @inheritDoc
 * @param {number} x
 * @param {number} y
 */
InputWidget.NumPad.prototype.updateDim = function(x, y) {
	const NP = InputWidget.NumPad;
	this.height = NP.bnHeight * 5 + NP.bnMargin * 4;
	this.width = InputPad.width;
};

/**
 * Grays out the Slot to indicate that it will be deleted on modification, unless it is 0, in which case there is
 * nothing to modify
 */
InputWidget.NumPad.prototype.grayOutUnlessZero = function() {
	const data = this.displayNum.getData();
	if (this.displayNum.isNum || data.getValue() !== 0) {
		this.slotShape.grayOutValue();
	}
};

/**
 * Generates the buttons for the NumPad
 */
InputWidget.NumPad.prototype.makeBns = function() {
	const NP = InputWidget.NumPad;
	let currentNum;
	let xPos = 0;
	let yPos = 0;
	for (let i = 0; i < 3; i++) {
		xPos = 0;
		for (let j = 0; j < 3; j++) {
			currentNum = 7 - i * 3 + j;
			this.makeNumBn(xPos, yPos, currentNum);
			xPos += NP.bnMargin;
			xPos += NP.bnWidth;
		}
		yPos += NP.bnMargin;
		yPos += NP.bnHeight;
	}
	this.makeNumBn(NP.bnMargin + NP.bnWidth, NP.bnMargin * 3 + NP.bnHeight * 3, 0);
	this.makePlusMinusBn(0, NP.bnMargin * 3 + NP.bnHeight * 3);
	this.makeDecimalBn(NP.bnMargin * 2 + NP.bnWidth * 2, NP.bnMargin * 3 + NP.bnHeight * 3);
	this.bsButton = this.makeBsBn(0, NP.bnMargin * 4 + NP.bnHeight * 4);
	this.okButton = this.makeOkBn(NP.bnMargin + NP.longBnW, NP.bnMargin * 4 + NP.bnHeight * 4);
};

/**
 * Generates a button that contains text (like a number, +/- button, or decimal point)
 * @param {number} x - The x coord of the button
 * @param {number} y - The y coord of the button
 * @param {string} text - The string to show on the button
 * @param {function} callbackFn - The function to call as the button is pressed
 * @return {Button}
 */
InputWidget.NumPad.prototype.makeTextButton = function(x, y, text, callbackFn) {
	const NP = InputWidget.NumPad;
	let button = new Button(x, y, NP.bnWidth, NP.bnHeight, this.group);
	button.addText(text, NP.font);
	button.setCallbackFunction(callbackFn, false);
	button.markAsOverlayPart(this.overlay);
	return button;
};

/**
 * Generates a button for a number
 * @param {number} x - The y coord of the button
 * @param {number} y - The x coord of the Button
 * @param {number} num - The number the button will display and append to the DisplayNum
 * @return {Button}
 */
InputWidget.NumPad.prototype.makeNumBn = function(x, y, num) {
	return this.makeTextButton(x, y, num + "", function() {
		this.numPressed(num)
	}.bind(this));
};

/**
 * Generates the +/- button that switches the sign of the DisplayNum
 * @param {number} x - The x coord of the button
 * @param {number} y - The y coord of the button
 * @return {Button}
 */
InputWidget.NumPad.prototype.makePlusMinusBn = function(x, y) {
	let button = this.makeTextButton(x, y, String.fromCharCode(177), this.plusMinusPressed.bind(this));
	if (this.positive) button.disable();
	return button;
};

/**
 * Generates the decimal point button
 * @param {number} x - The x coord of the button
 * @param {number} y - The y coord of the button
 * @return {Button}
 */
InputWidget.NumPad.prototype.makeDecimalBn = function(x, y) {
	let button = this.makeTextButton(x, y, ".", this.decimalPressed.bind(this));
	if (this.integer) button.disable();
	return button;
};

/**
 * Generates the Undo/Backspace button
 * @param {number} x - The x coord of the button
 * @param {number} y - The y coord of the button
 * @return {Button}
 */
InputWidget.NumPad.prototype.makeBsBn = function(x, y) {
	const NP = InputWidget.NumPad;
	let button = new Button(x, y, NP.longBnW, NP.bnHeight, this.group);
	button.addIcon(VectorPaths.backspace, NP.bsIconH);
	button.setCallbackFunction(this.bsPressed.bind(this), false);
	button.setCallbackFunction(this.bsReleased.bind(this), true);
	button.markAsOverlayPart(this.overlay);
	return button;
};

/**
 * Generates the check mark button that finishes the edit
 * @param {number} x - The x coord of the button
 * @param {number} y - The y coord of the button
 * @return {Button}
 */
InputWidget.NumPad.prototype.makeOkBn = function(x, y) {
	const NP = InputWidget.NumPad;
	let button = new Button(x, y, NP.longBnW, NP.bnHeight, this.group);
	button.addIcon(VectorPaths.checkmark, NP.okIconH);
	button.setCallbackFunction(this.okPressed.bind(this), true);
	button.markAsOverlayPart(this.overlay);
	return button;
};

/**
 * Adds the number to the end of the DisplayNum, or deletes the current data if it is gray
 * @param {number} num - The number 0-9 to append
 */
InputWidget.NumPad.prototype.numPressed = function(num) {
	this.removeUndo();
	this.deleteIfGray();
	this.displayNum.addDigit(num + "");
	this.sendUpdate();
};

/**
 * Changes the sign of the DisplayNum, or deletes the current Data if it is gray
 */
InputWidget.NumPad.prototype.plusMinusPressed = function() {
	this.removeUndo();
	this.deleteIfGray();
	this.displayNum.switchSign();
	this.sendUpdate();
};

/**
 * Appends a decimal point to the DisplayNum, or deletes the current data if it is gray
 */
InputWidget.NumPad.prototype.decimalPressed = function() {
	this.removeUndo();
	this.deleteIfGray();
	this.displayNum.addDecimalPoint();
	this.sendUpdate();
};

/**
 * If the current data is gray, deletes the current Data and replaces the backspace button with an undo button
 */
InputWidget.NumPad.prototype.deleteIfGray = function() {
	if (this.slotShape.isGray) {
		this.showUndo();
		this.displayNum = new DisplayNum(new NumData(0));
		this.slotShape.unGrayOutValue();
		this.sendUpdate();
	}
};

/**
 * Changes the backspace button to an undo button and saves the current data so it can be restored on undo
 */
InputWidget.NumPad.prototype.showUndo = function() {
	if (!this.undoAvailable) {
		this.undoAvailable = true;
		this.undoData = this.displayNum.getData();
		this.updateBsIcon();
	}
};

/**
 * Changes the undo button to a backspace icon
 */
InputWidget.NumPad.prototype.removeUndo = function() {
	this.removeUndoDelayed();
	this.updateBsIcon();
};

/**
 * Clears undo data and sets undo to unavailable
 */
InputWidget.NumPad.prototype.removeUndoDelayed = function() {
	if (this.undoAvailable) {
		this.undoAvailable = false;
		this.undoData = null;
	}
};

/**
 * Changes the icon of the backspace button to match its current state (backspace/undo)
 */
InputWidget.NumPad.prototype.updateBsIcon = function() {
	const NP = InputWidget.NumPad;
	if (this.undoAvailable !== this.undoVisible) {
		if (this.undoAvailable) {
			this.bsButton.addIcon(VectorPaths.undo, NP.bsIconH);
			this.undoVisible = true;
		} else {
			this.bsButton.addIcon(VectorPaths.backspace, NP.bsIconH);
			this.undoVisible = false;
		}
	}
};

/**
 * Restores the stored undo data and replaces the undo button with a backspace button
 */
InputWidget.NumPad.prototype.undo = function() {
	const NP = InputWidget.NumPad;
	if (this.undoAvailable) {
		this.displayNum = new DisplayNum(this.undoData);
		this.removeUndoDelayed();
		this.slotShape.grayOutValue();
		this.sendUpdate();
	}
};

/**
 * The backspace button's icon is only changed when it is released, not when it is pressed
 */
InputWidget.NumPad.prototype.bsReleased = function() {
	this.updateBsIcon();
};

/**
 * Triggers a backspace or undo action depending on the current state
 */
InputWidget.NumPad.prototype.bsPressed = function() {
	if (this.undoAvailable) {
		this.undo();
	} else {
		this.removeUndoDelayed();
		this.slotShape.unGrayOutValue();
		if (!this.displayNum.isNum) {
			this.displayNum = new DisplayNum(new NumData(0));
		}
		this.displayNum.backspace();
		this.sendUpdate();
	}
};

/**
 * Saves the data to the slot
 */
InputWidget.NumPad.prototype.okPressed = function() {
	this.finishFn(this.displayNum.getData());
};

/**
 * Updates the Slot's appearance to reflect the current edits
 */
InputWidget.NumPad.prototype.sendUpdate = function() {
	this.updateFn(this.displayNum.getData(), this.displayNum.getString());
};
/**
 * Handles displaying numbers entered using the NumPadWidget.  Properties of the number are divided into a number of
 * fields to make modification easier and, avoid rounding errors, and allow for trailing 0s.  They are recombined into
 * Data when getData() is called, and getString() gets the text to display while editing.
 * @param {Data|NumData} initialData - The Data to initially store. If anything other than NumData, the Data will be
 *                                     cleared when any modification occurs.
 * @constructor
 */
function DisplayNum(initialData) {
	// Whether the the Data is currently NumData. If not, it will be replaced on modification.
	this.isNum = initialData.type === Data.types.num;
	if (!this.isNum) {
		// If the Data is not NumData it is simply stored as is.
		this.data = initialData;
		return;
	}
	// NumData is broken across multiple fields.
	// A boolean tracks if the number is negative
	this.isNegative = (initialData.getValue() < 0);
	// A positive string representation of the number, without scientific notation
	const asStringData = initialData.asPositiveString();
	const parts = asStringData.getValue().split(".");
	// The integer part is everything before the decimal point, stored as a string
	this.integerPart = parts[0];
	if (this.integerPart === "") {
		this.integerPart = "0";
	}
	// The decimal part is everything after the decimal point, also as a string (which allows for trailing 0s
	// Storing data as a string prevents loss of precision while editing
	this.decimalPart = "";
	/* Stores whether there is a decimal point following the integerPart.  Always true if the length of the
	 * decimalPart is greater than 0. */
	this.hasDecimalPoint = (parts.length > 1);
	if (this.hasDecimalPoint) {
		this.decimalPart = parts[1];
	}
}

/**
 * Removes the last digit of NumData
 */
DisplayNum.prototype.backspace = function() {
	// Non-NumData is not modified
	if (!this.isNum) return;
	if (this.hasDecimalPoint && this.decimalPart !== "") {
		// If there is a decimal part, cut off the last digit
		const newL = this.decimalPart.length - 1;
		this.decimalPart = this.decimalPart.substring(0, newL);
	} else if (this.hasDecimalPoint) {
		// If there's a decimal point but no decimalPart, remove the point
		this.hasDecimalPoint = false;
	} else if (this.integerPart.length > 1) {
		// If there's an integer part that's longer than 1 digit, cut off the last digit
		const newL = this.integerPart.length - 1;
		this.integerPart = this.integerPart.substring(0, newL);
	} else if (this.integerPart !== "0") {
		// If there's just one digit and it isn't 0, make the number 0.
		this.integerPart = "0";
	} else if (this.isNegative) {
		// If only a "-0" is left, change it to just "0".
		this.isNegative = false;
	}
};

/**
 * Inverts the sign of the number
 */
DisplayNum.prototype.switchSign = function() {
	if (!this.isNum) return;
	this.isNegative = !this.isNegative;
};

/**
 * Adds a decimal point, if possible
 */
DisplayNum.prototype.addDecimalPoint = function() {
	if (!this.isNum) return;
	if (!this.hasDecimalPoint) {
		this.hasDecimalPoint = true;
		this.decimalPart = "";
	}
};

/**
 * Adds the provided digit to the end of number
 * @param {string} digit - ["0","1"..."9"], a length-1 string representing a digit
 */
DisplayNum.prototype.addDigit = function(digit) { //Digit is a string
	if (!this.isNum) return;
	if (this.hasDecimalPoint) {
		// Only up to 5 decimal places can be added to avoid floating-point weirdness
		if (this.decimalPart.length < 5) {
			this.decimalPart += digit;
		}
	} else if (this.integerPart !== "0") {
		// Only up to 10 digits can be added to the integerPart
		if (this.integerPart.length < 10) {
			this.integerPart += digit;
		}
	} else if (digit !== "0") {
		this.integerPart = digit;
	}
};

/**
 * Converts the DisplayNum into a string to display
 * @return {string|null} - The string or null if the default string for the Data should be used
 */
DisplayNum.prototype.getString = function() {
	if (!this.isNum) {
		return null;
	}
	let rVal = "";
	if (this.isNegative) {
		rVal += "-";
	}
	rVal += this.integerPart;
	if (this.hasDecimalPoint) {
		rVal += ".";
		rVal += this.decimalPart;
	}
	return rVal;
};

/**
 * Converts the DisplayNum into Data to be saved into the Slot
 * @return {Data}
 */
DisplayNum.prototype.getData = function() {
	if (!this.isNum) {
		return this.data;
	}
	let rVal = parseInt(this.integerPart, 10);
	if (this.hasDecimalPoint && this.decimalPart.length > 0) {
		let decPart = parseInt(this.decimalPart, 10);
		decPart /= Math.pow(10, this.decimalPart.length);
		rVal += decPart;
	}
	if (this.isNegative) {
		rVal = 0 - rVal;
	}
	return new NumData(rVal);
};
/**
 * Created by Tom on 7/3/2017.
 */
InputWidget.SelectPad = function(){
	this.optionsList = [];
	this.maxHeight = null;
};
InputWidget.SelectPad.prototype = Object.create(InputWidget);
InputWidget.SelectPad.constructor = InputWidget.SelectPad;
InputWidget.SelectPad.prototype.show = function(x, y, parentGroup, overlay, slotShape, updateFn, finishFn, data){
	InputWidget.prototype.show.call(this, x, y, parentGroup, overlay, slotShape, updateFn, finishFn, data);
	const layer = GuiElements.layers.frontScroll;
	this.menuBnList = new SmoothMenuBnList(this, parentGroup, x, y, InputPad.width, layer);
	this.optionsList.forEach(function(option){
		this.menuBnList.addOption(option.text, option.callbackFn);
	}.bind(this));
	DebugOptions.assert(this.maxHeight != null);
	this.menuBnList.markAsOverlayPart(overlay);
	this.menuBnList.setMaxHeight(this.maxHeight);
	this.menuBnList.show();
};
InputWidget.SelectPad.prototype.updateDim = function(){
	DebugOptions.assert(this.maxHeight !== null);
	this.height = SmoothMenuBnList.previewHeight(this.optionsList.length, this.maxHeight);
	this.width = InputPad.innerWidth;
};
InputWidget.SelectPad.prototype.fixedHeight = function(){
	return false;
};
InputWidget.SelectPad.prototype.setMaxHeight = function(height){
	this.maxHeight = height;
};
InputWidget.SelectPad.prototype.addOption = function(data, text) {
	if(text == null){
		text = data.asString().getValue();
	}
	const option = {};
	option.text = text;
	const me = this;
	option.callbackFn = function(){
		me.finishFn(data);
	};
	this.optionsList.push(option);
};
InputWidget.SelectPad.prototype.addAction = function(text, callbackFn){
	const option = {};
	option.text = text;
	const me = this;
	option.callbackFn = function(){
		callbackFn(me.actionCallback.bind(me));
	};
	this.optionsList.push(option);
};
InputWidget.SelectPad.prototype.actionCallback = function(data, shouldClose){
	if(data != null){
		this.updateFn(data);
	}
	if(shouldClose){
		this.finishFn();
	}
};
InputWidget.SelectPad.prototype.isEmpty = function(){
	return this.optionsList.length === 0;
};
InputWidget.SelectPad.prototype.close = function(){
	this.menuBnList.hide();
};
InputWidget.SelectPad.prototype.relToAbsX = function(x){
	return this.overlay.relToAbsX(this.x);
};
InputWidget.SelectPad.prototype.relToAbsY = function(y){
	return this.overlay.relToAbsY(this.y);
};
InputWidget.SelectPad.prototype.getAbsX = function(){
	return this.relToAbsX(0);
};
InputWidget.SelectPad.prototype.getAbsY = function(){
	return this.relToAbsY(0);
};
/**
 * An InputSystem used for selecting a Sound from a list.  Provides buttons to preview sounds before selecting them.
 * @param {number} x1
 * @param {number} x2
 * @param {number} y1
 * @param {number} y2
 * @param {boolean} isRecording - Whether recordings rather than effects should be selected from
 * @constructor
 */
function SoundInputPad(x1, x2, y1, y2, isRecording) {
	InputSystem.call(this);
	const coords = this.coords = {};
	coords.x1 = x1;
	coords.x2 = x2;
	coords.y1 = y1;
	coords.y2 = y2;
	this.isRecording = isRecording;
}
SoundInputPad.prototype = Object.create(InputSystem.prototype);
SoundInputPad.prototype.constructor = InputSystem;

SoundInputPad.setConstants = function() {
	const SIP = SoundInputPad;
	SIP.margin = InputPad.margin;
	SIP.rowHeight = SmoothMenuBnList.bnHeight;
	SIP.width = 300;
	SIP.playBnWidth = RowDialog.smallBnWidth;
	SIP.mainBnWidth = SIP.width - SIP.playBnWidth - SIP.margin;
	SIP.iconH = RowDialog.iconH;
	SIP.background = Colors.black;
};

/**
 * @inheritDoc
 * @param {EditableSlotShape} slotShape
 * @param {function} updateFn
 * @param {function} finishFn
 * @param {Data} data
 */
SoundInputPad.prototype.show = function(slotShape, updateFn, finishFn, data) {
	InputSystem.prototype.show.call(this, slotShape, updateFn, finishFn, data);
	const SIP = SoundInputPad;

	// Make a group for everything
	this.group = GuiElements.create.group(0, 0);

	// Compute dimensions
	this.updateDim();

	// Create the BubbleOverlay for this pad
	const bubbleGroup = GuiElements.create.group(0, 0);
	const type = Overlay.types.inputPad;
	const layer = GuiElements.layers.inputPad;
	this.bubbleOverlay = new BubbleOverlay(type, SIP.background, SIP.margin, bubbleGroup, this, layer);
	const coords = this.coords;
	this.bubbleOverlay.display(coords.x1, coords.x2, coords.y1, coords.y2, this.width, this.height);

	// Get the coords of the pad
	const absX = this.bubbleOverlay.relToAbsX(0);
	const absY = this.bubbleOverlay.relToAbsY(0);

	// Generate content
	this.createRows();

	// Put it all in a scrollBox
	const scrollLayer = GuiElements.layers.frontScroll;
	this.smoothScrollBox = new SmoothScrollBox(this.group, scrollLayer, absX, absY, this.width, this.height, this.width,
		this.innerHeight, this.bubbleOverlay);
	this.smoothScrollBox.show();
};

/**
 * Computes the dimensions of the pad, incorporating the screen height and number of entries
 */
SoundInputPad.prototype.updateDim = function() {
	const SIP = SoundInputPad;
	const maxHeight = GuiElements.height - SIP.margin * 2;
	// The number of recordings is retrieved from a cache
	const soundCount = Sound.getSoundList(this.isRecording).length;
	let desiredHeight = (SIP.rowHeight + SIP.margin) * soundCount - SIP.margin;
	if (this.isRecording) {
		desiredHeight += SIP.margin + SIP.rowHeight;
	}
	desiredHeight = Math.max(0, desiredHeight);
	this.height = Math.min(desiredHeight, maxHeight);
	this.innerHeight = desiredHeight;
	this.width = SIP.width;
};

/**
 * Creates the content of the SoundInputPad
 */
SoundInputPad.prototype.createRows = function() {
	const SIP = SoundInputPad;
	let y = 0;
	Sound.getSoundList(this.isRecording).forEach(function(sound) {
		this.createRow(sound, y);
		y += SIP.margin + SIP.rowHeight;
	}.bind(this));
	if (this.isRecording) {
		this.createRecordBn(0, y, SIP.width);
	}
};

/**
 * Creates the row for the provided Sound
 * @param {Sound} sound
 * @param {number} y
 */
SoundInputPad.prototype.createRow = function(sound, y) {
	const SIP = SoundInputPad;
	this.createMainBn(sound, 0, y, SIP.mainBnWidth, SIP.rowHeight, this.group);
	this.createPlayBn(sound, SIP.margin + SIP.mainBnWidth, y, SIP.playBnWidth);
};

/**
 * Creates a "Record sounds" option included at the end of recording SoundInputPads
 * @param {number} x
 * @param {number} y
 * @param {number} width
 */
SoundInputPad.prototype.createRecordBn = function(x, y, width) {
	const SIP = SoundInputPad;
	const button = new Button(x, y, width, SIP.rowHeight, this.group);
	button.addText("Record sounds");
	button.markAsOverlayPart(this.bubbleOverlay);
	button.setCallbackFunction(function() {
		RecordingDialog.showDialog();
		this.close();
	}.bind(this), true);
	button.makeScrollable();
};

/**
 * Creates the main button for the Sound, which selects the sound from the list
 * @param {Sound} sound
 * @param {number} x
 * @param {number} y
 * @param {number} width
 */
SoundInputPad.prototype.createMainBn = function(sound, x, y, width) {
	const SIP = SoundInputPad;
	const button = new Button(x, y, width, SIP.rowHeight, this.group);
	button.addText(sound.name);
	button.markAsOverlayPart(this.bubbleOverlay);
	button.setCallbackFunction(function() {
		this.currentData = new SelectionData(sound.name, sound.id);
		this.close();
	}.bind(this), true);
	button.makeScrollable();
};

/**
 * Creates a play/stop button for previewing a sound
 * @param {Sound} sound
 * @param {number} x
 * @param {number} y
 * @param {number} width
 */
SoundInputPad.prototype.createPlayBn = function(sound, x, y, width) {
	const SIP = SoundInputPad;
	const button = new Button(x, y, width, SIP.rowHeight, this.group);
	// Store the state of the Button
	const mem = {};
	mem.playing = false;
	button.addIcon(VectorPaths.play, SIP.iconH);
	button.markAsOverlayPart(this.bubbleOverlay);
	const stoppedPlaying = function() {
		mem.playing = false;
		button.addIcon(VectorPaths.play, SIP.iconH);
	};
	button.setCallbackFunction(function() {
		// When tapped, the state of the button determines is sounds should be stopped or played
		if (mem.playing) {
			stoppedPlaying();
			Sound.stopAllSounds();
		} else {
			mem.playing = true;
			button.addIcon(VectorPaths.square, SIP.iconH);
			Sound.playAndStopPrev(sound.id, this.isRecording, null, stoppedPlaying, stoppedPlaying);
		}
	}.bind(this), true);
	button.makeScrollable();
};

/**
 * Closes the SoundInputPad.
 * @inheritDoc
 */
SoundInputPad.prototype.close = function() {
	if (this.closed) return;
	InputSystem.prototype.close.call(this);
	this.smoothScrollBox.hide();
	this.bubbleOverlay.close();
	Sound.stopAllSounds();
};
/**
 * A BubbleOverlay is a type of Overlay that places its content in a speech bubble shaped background that always
 * is on screen.  The bubble appears above, below, left, or right of a rectangular region specified in the display()
 * function.  The InputPad for editing Slots uses a BubbleOverlay.
 *
 * @param {Overlay.types} overlayType - The type of overlay (to prevent two overlays of the same type)
 * @param {string} color - Color of the bubble in hex
 * @param {number} margin - The size of the margin around the content
 * @param {Element} innerGroup - The group with content to put in the overlay
 * @param {*} parent - The object owning the BubbleOverlay. Must implement a close() function
 * @param {Element} [layer] - The layer from GuiElements to insert the overlay into. layers.overlay is default
 * @constructor
 */
function BubbleOverlay(overlayType, color, margin, innerGroup, parent, layer) {
	if (layer == null) {
		layer = GuiElements.layers.overlay;
	}
	Overlay.call(this, overlayType);
	this.x = 0;
	this.y = 0;
	this.bgColor = color;
	this.margin = margin;
	this.innerGroup = innerGroup;
	this.parent = parent;
	this.layerG = layer;
	this.visible = false;
	this.buildBubble();
}
BubbleOverlay.prototype = Object.create(Overlay.prototype);
BubbleOverlay.prototype.constructor = BubbleOverlay;

BubbleOverlay.setGraphics = function() {
	BubbleOverlay.triangleW = 15;
	BubbleOverlay.triangleH = 7;
	BubbleOverlay.minW = 25;
	BubbleOverlay.overlap = 1;
};

/**
 * Creates the groups and graphics for the bubble
 */
BubbleOverlay.prototype.buildBubble = function() {
	this.buildGroups();
	this.makeBg();
};

/**
 * Creates a group for the bubble, a group for the background, and places the innerGroup in the bubble's group
 */
BubbleOverlay.prototype.buildGroups = function() {
	this.group = GuiElements.create.group(0, 0);
	TouchReceiver.addListenersOverlayPart(this.group);
	this.bgGroup = GuiElements.create.group(0, 0, this.group);
	this.group.appendChild(this.innerGroup);
	GuiElements.move.group(this.innerGroup, this.margin, this.margin);
};

/**
 * Makes a rectangle and triangle for the background.  Position is not important yet.
 */
BubbleOverlay.prototype.makeBg = function() {
	this.bgRect = GuiElements.create.rect(this.bgGroup);
	GuiElements.update.color(this.bgRect, this.bgColor);
	this.triangle = GuiElements.create.path(this.bgGroup);
	GuiElements.update.color(this.triangle, this.bgColor);
};

/**
 * Makes the bubble visible, assuming it was already displayed.
 */
BubbleOverlay.prototype.show = function() {
	if (!this.visible) {
		this.layerG.appendChild(this.group);
		this.visible = true;
		this.addOverlayAndCloseOthers();
	}
};

/**
 * Makes the bubble invisible.
 */
BubbleOverlay.prototype.hide = function() {
	if (this.visible) {
		this.group.remove();
		this.visible = false;
		Overlay.removeOverlay(this);
	}
};

/**
 * Closes the bubble and tells its parent to close
 */
BubbleOverlay.prototype.close = function() {
	this.hide();
	this.parent.close();
};

/**
 * Builds the bubble and makes it visible with its point on the boundry of the specified rectangle
 * @param {number} x1 - x coord of top left point of rectangle
 * @param {number} x2 - x coord of bottom right point of rectangle
 * @param {number} y1 - y coord of top left point of rectangle
 * @param {number} y2 - y coord of bottom right point of rectangle
 * @param {number} innerWidth - The width of the content of the bubble
 * @param {number} innerHeight - The height of the content of the bubble
 */
BubbleOverlay.prototype.display = function(x1, x2, y1, y2, innerWidth, innerHeight) {
	DebugOptions.validateNumbers(x1, x2, y1, y2, innerWidth, innerHeight);
	const BO = BubbleOverlay;

	/* Compute dimensions of the bubble */
	let width = innerWidth + 2 * this.margin;
	if (width < BO.minW) {
		width = BO.minW;
	}
	const height = innerHeight + 2 * this.margin;

	/* Center the content in the bubble */
	GuiElements.move.group(this.innerGroup, (width - innerWidth) / 2, (height - innerHeight) / 2);

	/* Compute dimension depending on orientation */
	const longW = width + BO.triangleH;
	const longH = height + BO.triangleH;

	/* Determine how much content is cut off if the bubble goes in each direction */
	const attemptB = Math.max(0, y2 + longH - GuiElements.height);
	const attemptT = Math.max(0, longH - y1);
	const attemptR = Math.max(0, x2 + longW - GuiElements.width);
	const attemptL = Math.max(0, longW - x1);

	/* Find the amount of content cut off using the best attempt */
	const min = Math.min(attemptT, attemptB, attemptL, attemptR);

	/* The vertical direction is used if the top or bottom attempts were the best */
	const vertical = attemptT <= min || attemptB <= min;

	/* To be determined */
	let topLeftX = NaN;   // The x coord of the background rect
	let topLeftY = NaN;   // The y coord of the background rect
	let x = NaN;   // The x coord of the point of the triangle
	let y = NaN;   // The y coord of the point of the triangle
	let triangleDir = 1;   // 1 or -1
	if (vertical) {
		x = (x1 + x2) / 2;
		// Find the best x for the background rect
		topLeftX = this.fitLocationToRange(x, width, GuiElements.width);
		if (attemptB <= min) {
			topLeftY = y2 + BO.triangleH;
			y = y2;
		} else {
			topLeftY = y1 - longH;
			y = y1;
			triangleDir = -1;
		}
	} else {
		y = (y1 + y2) / 2;
		// Find the best y for the background rect
		topLeftY = this.fitLocationToRange(y, height, GuiElements.height);
		if (attemptL <= min) {
			topLeftX = x1 - longW;
			x = x1;
			triangleDir = -1;
		} else {
			topLeftX = x2 + BO.triangleH;
			x = x2;
		}
	}

	// Convert the triangle's coords from abs to rel coords
	const triX = x - topLeftX;
	const triY = y - topLeftY;
	const triH = (BO.triangleH + BO.overlap) * triangleDir;
	this.x = topLeftX;
	this.y = topLeftY;
	GuiElements.move.group(this.group, topLeftX, topLeftY);

	// Move the elements using the results
	GuiElements.update.triangleFromPoint(this.triangle, triX, triY, BO.triangleW, triH, vertical);
	GuiElements.update.rect(this.bgRect, 0, 0, width, height);
	this.show();
};
/**
 * Finds the best x coord for an object the specified width that would like to be centered at the specified center
 * but needs to fit in the specified range
 * By symmetry, also works for y coords with height
 * @param {number} center - The x coord the object would like to be centered at
 * @param {number} width - The width of the object
 * @param {number} range - The width of the space the object needs to fit within
 * @return {number} - The x coord the object should have
 */
BubbleOverlay.prototype.fitLocationToRange = function(center, width, range) {
	let res = center - width / 2;   // The object would like this x coord
	if (width > range) {
		// The object is bigger than the range, so we make it extend beyond both sides equally
		// result:   --[----]--
		res = (range - width) / 2;
	} else if (res < 0) {
		// The object would like to be to the left of the range, so we align it to the left
		// object wants:   --[--      ]
		// result:    [----    ]
		res = 0;
	} else if (res + width > range) {
		// The object would like to be to the right of the range, so we align it to the right
		// object wants:   [      --]--
		// result:    [    ----]
		res = range - width;
	}
	return res;
};

/* Convert between rel and abs coords */
/**
 * @param {number} x
 * @return {number}
 */
BubbleOverlay.prototype.relToAbsX = function(x) {
	return x + this.x + this.margin;
};
/**
 * @param {number} y
 * @return {number}
 */
BubbleOverlay.prototype.relToAbsY = function(y) {
	return y + this.y + this.margin;
};
/**
 * A bubble-shaped element that holds text containing the result of executing a block that was tapped.
 * Becomes visible as soon as it is constructed.
 * @param {number} leftX - left boundary of the Block
 * @param {number} rightX - right boundary of the Block
 * @param {number} upperY - top boundary of the Block
 * @param {number} lowerY - bottom boundary of the Block
 * @param {string} text - The text to show in the bubble
 * @param {boolean} [error=false] - Whether the bubble should be formatted as an error
 * @constructor
 */
function ResultBubble(leftX, rightX, upperY, lowerY, text, error) {
	const RB = ResultBubble;
	if (error == null) {
		error = false;
	}
	let fontColor = RB.fontColor;
	let bgColor = RB.bgColor;
	if (error) {
		fontColor = RB.errorFontColor;
		bgColor = RB.errorBgColor;
	}
	const height = RB.font.charHeight;
	const textE = GuiElements.draw.text(0, height, text, RB.font, fontColor);
	GuiElements.update.textLimitWidth(textE, text, GuiElements.width - RB.hMargin * 2);
	const width = GuiElements.measure.textWidth(textE);
	const group = GuiElements.create.group(0, 0);
	group.appendChild(textE);
	let layer = GuiElements.layers.resultBubble;
	let overlayType = Overlay.types.resultBubble;
	this.bubbleOverlay = new BubbleOverlay(overlayType, bgColor, RB.margin, group, this, layer);
	this.bubbleOverlay.display(leftX, rightX, upperY, lowerY, width, height);
}

ResultBubble.setConstants = function() {
	const RB = ResultBubble;
	RB.fontColor = Colors.black;
	RB.errorFontColor = Colors.white;
	RB.bgColor = Colors.white;
	RB.errorBgColor = "#c00000";
	RB.font = Font.uiFont(16);
	RB.margin = 4;
	/*RB.lifetime=3000;*/
	RB.hMargin = 20;
};

/**
 * Hides the result
 */
ResultBubble.prototype.close = function() {
	this.bubbleOverlay.hide();
};

/**
 * Displays a ResultBubble below a block
 * @param {string} value - The message to display
 * @param {number} x - The x coord of the Block
 * @param {number} y - The y coord of the Block
 * @param {number} width - The width of the Block
 * @param {number} height - The height of the Block
 * @param {boolean} [error=false] - Whether the bubble should be formatted as an error
 */
ResultBubble.displayValue = function(value, x, y, width, height, error) {
	if (error == null) {
		error = false;
	}
	const leftX = x;
	const rightX = x + width;
	const upperY = y;
	const lowerY = y + height;
	new ResultBubble(leftX, rightX, upperY, lowerY, value, error);
};
/**
 * Creates a UI element that is in a div layer and contains a scrollDiv with the content from the group.  The group
 * can change size, as long as it calls updateDims with the new innerHeight and innerWidth.
 * The scrollbox is one of the few components to use regular HTML (in this case a scrollable div).  This allows for
 * smoother scrolling
 *
 * Unfortunately, iOS tries to scroll the entire website if the SmoothScrollBox is at the minimum/maximum scrolling
 * position vertically.  To prevent the entire webapp from scrolling, the body is set to position:fixed, but the
 * iPad still tries to scroll it, which has no visual affect but locks the focus on the body until the user stops
 * touching the screen for 2 secs or so (preventing them from scrolling the actual SmoothScrollBox).  To stop this,
 * a timer regularly checks if the box is scrolled to an extreme position and moves it 1 pixel to compensate.  This
 * behaviour is registered with TouchReceiver.createScrollFixTimer()
 *
 * The smoothScrollBox must use actual screen coordinates. Unlike other parts of the SVG it can't ignore the present
 * zoom level (as most relToAbs functions do), and thus uses GuiElements.relToAbs to account for the zoom and get
 * real absolute coords, rather than the fake abs coords provided in the constructor (which ignore the zoom level)
 *
 * @param {Element} group - The group the scrollBox should put inside the svg inside the div
 * @param {Element} layer - The layer the (outer div) the scrollDiv should be added to
 * @param {number} absX - The x screen coord the scrollDiv should appear at
 * @param {number} absY - The y screen coord the scrollDiv should appear at
 * @param {number} width - The width the div containing the content should have
 * @param {number} height - The height the div containing the content should have
 * @param {number} innerWidth - The width of the content within the div.  If larger, the div will scroll
 * @param {number} innerHeight - The height of the content within the div.  If larger, the div will scroll
 * @param {Overlay|null} [partOfOverlay=null] - The Overlay this SmoothScrollBox is a part of, or null if N/A
 * @constructor
 */
function SmoothScrollBox(group, layer, absX, absY, width, height, innerWidth, innerHeight, partOfOverlay) {
	if (partOfOverlay == null) {
		partOfOverlay = null;
	}
	DebugOptions.validateNonNull(group, layer);
	DebugOptions.validateNumbers(width, height, innerWidth, innerHeight);
	this.x = absX;
	this.y = absY;
	this.width = width;
	this.height = height;
	this.innerWidth = innerWidth;
	this.innerHeight = innerHeight;
	this.layer = layer;
	this.scrollDiv = GuiElements.create.scrollDiv();
	TouchReceiver.addListenersScrollBox(this.scrollDiv, this);
	this.contentSvg = GuiElements.create.svg(this.scrollDiv);
	this.contentGroup = GuiElements.create.group(0, 0, this.contentSvg);
	this.contentGroup.appendChild(group);
	this.scrollStatus = {};
	this.fixScrollTimer = TouchReceiver.createScrollFixTimer(this.scrollDiv, this.scrollStatus);
	this.visible = false;
	this.currentZoom = GuiElements.zoomFactor;
	this.partOfOverlay = partOfOverlay;
}

/**
 * Recomputes the sizes and positions of the SmoothScrollBox
 */
SmoothScrollBox.prototype.updateScrollSet = function() {
	if (this.visible) {
		let realX = GuiElements.relToAbsX(this.x);
		let realY = GuiElements.relToAbsY(this.y);

		GuiElements.update.smoothScrollSet(this.scrollDiv, this.contentSvg, this.contentGroup, realX, realY, this.width,
			this.height, this.innerWidth, this.innerHeight);
	}
};

/**
 * Captures the scroll position, calls updateScrollSet, and restores the scroll position
 */
SmoothScrollBox.prototype.updateZoom = function() {
	const currentScrollX = this.getScrollX();
	const currentScrollY = this.getScrollY();
	this.currentZoom = GuiElements.zoomFactor;
	this.updateScrollSet();
	this.setScrollX(currentScrollX);
	this.setScrollY(currentScrollY);
};

/**
 * Changes the dimensions of the content inside the SmoothScrollBox
 * @param {number} innerWidth - The new width of the content
 * @param {number} innerHeight - The new height of the content
 */
SmoothScrollBox.prototype.setContentDims = function(innerWidth, innerHeight) {
	this.innerHeight = innerHeight;
	this.innerWidth = innerWidth;
	this.updateScrollSet();
};

/**
 * Changes the dimensions of the outside of the SmoothScrollBox
 * @param {number} width
 * @param {number} height
 */
SmoothScrollBox.prototype.setDims = function(width, height) {
	this.width = width;
	this.height = height;
	this.updateScrollSet();
};

/**
 * Changes the position of the SmoothScrollBox
 * @param {number} absX
 * @param {number} absY
 */
SmoothScrollBox.prototype.move = function(absX, absY) {
	this.x = absX;
	this.y = absY;
	this.updateScrollSet();
};

/**
 * Makes the SmoothScrollBox visible
 */
SmoothScrollBox.prototype.show = function() {
	if (!this.visible) {
		this.visible = true;
		this.layer.appendChild(this.scrollDiv);
		this.fixScrollTimer = TouchReceiver.createScrollFixTimer(this.scrollDiv);
		this.updateScrollSet();
		TouchReceiver.setInitialScrollFix(this.scrollDiv);
	}
};

/**
 * Hides the SmoothScrollBox
 */
SmoothScrollBox.prototype.hide = function() {
	if (this.visible) {
		this.visible = false;
		this.layer.removeChild(this.scrollDiv);
		if (this.fixScrollTimer != null) {
			window.clearInterval(this.fixScrollTimer);
		}
	}
};

/* Convert between coords inside the group in the SmoothScrollBox and screen coords */
/**
 * @param {number} x
 * @return {number}
 */
SmoothScrollBox.prototype.relToAbsX = function(x) {
	return x - this.scrollDiv.scrollLeft / this.currentZoom + this.x;
};
/**
 * @param {number} y
 * @return {number}
 */
SmoothScrollBox.prototype.relToAbsY = function(y) {
	return y - this.scrollDiv.scrollTop / this.currentZoom + this.y;
};
/**
 * @param {number} x
 * @return {number}
 */
SmoothScrollBox.prototype.absToRelX = function(x) {
	return x + this.scrollDiv.scrollLeft * this.currentZoom - this.x;
};
/**
 * @param {number} y
 * @return {number}
 */
SmoothScrollBox.prototype.absToRelY = function(y) {
	return y + this.scrollDiv.scrollTop * this.currentZoom - this.y;
};

/* Get/set the scroll amount in various directions */
/**
 * @return {number}
 */
SmoothScrollBox.prototype.getScrollY = function() {
	if (!this.visible) return 0;
	return this.scrollDiv.scrollTop / this.currentZoom;
};
/**
 * @return {number}
 */
SmoothScrollBox.prototype.getScrollX = function() {
	if (!this.visible) return 0;
	return this.scrollDiv.scrollLeft / this.currentZoom;
};
/**
 * @param {number} x
 */
SmoothScrollBox.prototype.setScrollX = function(x) {
	this.scrollDiv.scrollLeft = x * this.currentZoom;
	TouchReceiver.setInitialScrollFix(this.scrollDiv);
};
/**
 * @param {number} y
 */
SmoothScrollBox.prototype.setScrollY = function(y) {
	this.scrollDiv.scrollTop = y * this.currentZoom;
	TouchReceiver.setInitialScrollFix(this.scrollDiv);
};

/**
 * Determines whether the scrollBox is currently being scrolled
 * @return {boolean}
 */
SmoothScrollBox.prototype.isMoving = function() {
	return !this.scrollStatus.still;
};
/**
 * A stack of buttons which become scrollable if thee isn't enough screen space.  Is not build until show() is called.
 * Options should be added through addOption before show() is called.  setMaxHeight can also be called to cause the
 * list to scroll if the maximum height is exceeded.
 * TODO: use SmoothScrollBox instead of manually implementing scrolling
 *
 * @param parent - Some UI object that implements relToAbsX and relToAbsY
 * TODO: remove parentGroup as it is not used
 * @param {Element} parentGroup - The group the SmoothMenuBnList should add itself to
 * @param {number} x - The rel x coord the list should appear at
 * @param {number} y - The rel y coord the list should appear at
 * @param {number} [width] - The width the list should have.  If null, computed on the fly to match longest entry
 * @param {Element} [layer] - The layer the list should place the scrollDiv on. frontScroll used by default
 * @constructor
 */
function SmoothMenuBnList(parent, parentGroup, x, y, width, layer) {
	if (layer == null) {
		layer = GuiElements.layers.frontScroll;
	}
	this.x = x;
	this.y = y;
	this.width = width;
	if (width == null) {
		this.width = null;
	}
	// computed later
	this.height = 0;
	// Store constants TODO: not really necessary
	this.bnHeight = SmoothMenuBnList.bnHeight;
	this.bnMargin = Button.defaultMargin;
	this.bnsGenerated = false;
	// Prepare list to store options.
	/** @type {Array<object>} - An array of objects with properties like text, func, and addTextFn */
	this.options = [];
	/** @type {null|Array<object>} */
	this.bns = null;

	// Build the scroll box but not the buttons
	this.build();
	this.parentGroup = parentGroup;
	this.parent = parent;
	this.layer = layer;

	this.visible = false;
	// May be set later with markAsOverlayPart
	this.partOfOverlay = null;
	this.internalHeight = 0;
	// optionally set with setMaxHeight()
	this.maxHeight = null;
	// Tracks whether the list is scrolling
	this.scrollStatus = {};
	this.scrollable = false;
}

SmoothMenuBnList.setGraphics = function() {
	const SMBL = SmoothMenuBnList;
	SMBL.bnHeight = 34;
	SMBL.bnHMargin = 10; //only used when width not specified.
	SMBL.minWidth = 40;
};

/**
 * Build the parts necessary to make a scrollable list, but not the buttons
 */
SmoothMenuBnList.prototype.build = function() {
	this.scrollDiv = GuiElements.create.scrollDiv();
	TouchReceiver.addListenersSmoothMenuBnListScrollRect(this.scrollDiv, this);
	this.svg = GuiElements.create.svg(this.scrollDiv);
	this.zoomG = GuiElements.create.group(0, 0, this.svg);
};

/**
 * Configures the SmoothMenuBnList to scroll if a certain height is exceeded
 * @param {number} maxHeight
 */
SmoothMenuBnList.prototype.setMaxHeight = function(maxHeight) {
	this.maxHeight = maxHeight;
};

/**
 * Adds an option to the SmoothMenuBnList
 * @param {string} text - The text to display on the Button.  Not used if addTextFn is defined
 * @param {function|null} func - type () -> (), the function to call when the option is selected
 * @param {function|null} [addTextFn] - type (Button) -> (), formats the button for this option
 */
SmoothMenuBnList.prototype.addOption = function(text, func, addTextFn) {
	if (func == null) {
		func = null;
	}
	if (addTextFn == null) {
		addTextFn = null;
	}

	this.bnsGenerated = false;
	const option = {};
	option.func = func;
	option.text = text;
	option.addTextFn = addTextFn;
	this.options.push(option);
};

/**
 * Builds the buttons and shows the list on the screen
 */
SmoothMenuBnList.prototype.show = function() {
	this.generateBns();
	if (!this.visible) {
		this.visible = true;
		this.layer.appendChild(this.scrollDiv);
		this.updatePosition();
		// See SmoothScrollBox for an explaination of why this is necessary
		this.fixScrollTimer = TouchReceiver.createScrollFixTimer(this.scrollDiv, this.scrollStatus);
		TouchReceiver.setInitialScrollFix(this.scrollDiv);
	}
};

/**
 * Hides the list so it can be shown again
 */
SmoothMenuBnList.prototype.hide = function() {
	if (this.visible) {
		this.visible = false;
		this.layer.removeChild(this.scrollDiv);
		if (this.fixScrollTimer != null) {
			window.clearInterval(this.fixScrollTimer);
		}
	}
};

/**
 * Creates the buttons for the list
 */
SmoothMenuBnList.prototype.generateBns = function() {
	// The width is computed and stored in this.width
	this.computeWidth();
	if (!this.bnsGenerated) {
		this.clearBnsArray();
		let currentY = 0;
		let count = this.options.length;
		for (let i = 0; i < count; i++) {
			this.bns.push(this.generateBn(0, currentY, this.width, this.options[i]));
			currentY += this.bnHeight + this.bnMargin;
		}
		currentY -= this.bnMargin;
		this.internalHeight = currentY;
		if (count === 0) {
			this.internalHeight = 0;
		}
		this.height = this.internalHeight;
		if (this.maxHeight != null) {
			this.height = Math.min(this.internalHeight, this.maxHeight);
		}
		this.scrollable = this.height !== this.internalHeight;
		this.bnsGenerated = true;
		this.updatePosition();
	}
};

/**
 * If the width is not set yet, computes the width of the longest button and stores it in this.width
 */
SmoothMenuBnList.prototype.computeWidth = function() {
	if (this.width == null) {
		const columns = 1;
		const MBL = SmoothMenuBnList;
		let longestW = 0;
		for (let i = 0; i < this.options.length; i++) {
			const string = this.options[i].text;
			const currentW = GuiElements.measure.stringWidth(string, Button.defaultFont);
			if (currentW > longestW) {
				longestW = currentW;
			}
		}
		this.width = columns * longestW + columns * 2 * MBL.bnHMargin + (columns - 1) * this.bnMargin;
		if (this.width < MBL.minWidth) {
			this.width = MBL.minWidth;
		}
	}
};

/**
 * Returns whether the list is empty
 * @return {boolean}
 */
SmoothMenuBnList.prototype.isEmpty = function() {
	return this.options.length === 0;
};

/**
 * Removes all the buttons currently in the list
 */
SmoothMenuBnList.prototype.clearBnsArray = function() {
	if (this.bns != null) {
		for (let i = 0; i < this.bns.length; i++) {
			this.bns[i].remove();
		}
	}
	this.bns = [];
};

/**
 * Creates a button for the provided option
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {object} option - Object with fields for func, text, and/or addTextFn
 * @return {Button}
 */
SmoothMenuBnList.prototype.generateBn = function(x, y, width, option) {
	const bn = new Button(x, y, width, this.bnHeight, this.zoomG);
	bn.setCallbackFunction(option.func, true);
	if (option.addTextFn != null) {
		// Provides flexibility to format the button
		option.addTextFn(bn);
	} else {
		bn.addText(option.text);
	}
	bn.partOfOverlay = this.partOfOverlay;
	bn.makeScrollable();
	return bn;
};

/**
 * Recomputes the location of the list and moves it
 */
SmoothMenuBnList.prototype.updatePosition = function() {
	if (this.visible) {
		let realX = this.parent.relToAbsX(this.x);
		let realY = this.parent.relToAbsY(this.y);
		// SmoothMenuBnLists need real absolute coords that account for the zoom level
		realX = GuiElements.relToAbsX(realX);
		realY = GuiElements.relToAbsY(realY);

		GuiElements.update.smoothScrollSet(this.scrollDiv, this.svg, this.zoomG, realX, realY, this.width,
			this.height, this.width, this.internalHeight);
	}
};

/**
 * Recomputes location
 */
SmoothMenuBnList.prototype.updateZoom = function() {
	this.updatePosition();
};

/**
 * Returns the current scroll position in the menu
 * @return {number}
 */
SmoothMenuBnList.prototype.getScroll = function() {
	if (!this.visible) return 0;
	return this.scrollDiv.scrollTop;
};

/**
 * Sets the current scroll position in the menu
 * @param {number} scrollTop
 */
SmoothMenuBnList.prototype.setScroll = function(scrollTop) {
	if (!this.visible) return;
	scrollTop = Math.max(0, scrollTop);
	const height = parseInt(window.getComputedStyle(this.scrollDiv).getPropertyValue('height'), 10);
	scrollTop = Math.min(this.scrollDiv.scrollHeight - height, scrollTop);
	this.scrollDiv.scrollTop = scrollTop;
};

/**
 * Tells this list it is part of an overlay, so its buttons don't close that overlay
 * @param {Overlay} overlay - The overlay this list is a part of
 */
SmoothMenuBnList.prototype.markAsOverlayPart = function(overlay) {
	this.partOfOverlay = overlay;
};

/**
 * Determines whether the list is currently being scrolled
 * @return {boolean}
 */
SmoothMenuBnList.prototype.isScrolling = function() {
	if (!this.visible) return false;
	return !this.scrollStatus.still;
};

/**
 * Determines the height the list will have when built
 * @return {number}
 */
SmoothMenuBnList.prototype.previewHeight = function() {
	let height = (this.bnHeight + this.bnMargin) * this.options.length - this.bnMargin;
	height = Math.max(height, 0);
	if (this.maxHeight != null) {
		height = Math.min(height, this.maxHeight);
	}
	return height;
};

/**
 * Determines the width the list will have and stores it, then returns it
 * @return {number}
 */
SmoothMenuBnList.prototype.previewWidth = function() {
	this.computeWidth();
	return this.width;
};

/**
 * Determines the height of a list with the specified number of items
 * @param {number} count
 * @param {number} [maxHeight]
 * @return {number}
 */
SmoothMenuBnList.previewHeight = function(count, maxHeight) {
	let height = (SmoothMenuBnList.bnHeight + Button.defaultMargin) * count - Button.defaultMargin;
	height = Math.max(height, 0);
	if (maxHeight != null) {
		height = Math.min(height, maxHeight);
	}
	return height;
};
/**
 * Abstract class that represents a menu displayed when a Button in the TitleBar is tapped.  The Menu requires a button
 * to attach to, which it automatically configures the callbacks for.  Subclasses override the loadOptions function
 * which is called every time the Menu is open and should call addOption() to determine which options to show. If the
 * width of the menu is unspecified, it will be set to default
 *
 * @param {Button} button - The Button the Menu should attach to
 * @param {number} [width] - The width of the Menu
 * @constructor
 */
function Menu(button, width) {
	if (width == null) {
		width = Menu.defaultWidth;
	}
	// Menus are a type of Overlay
	Overlay.call(this, Overlay.types.menu);
	DebugOptions.validateNumbers(width);
	this.width = width;
	// The position of the menu is determined by the button
	this.x = button.x;
	this.y = button.y + button.height;
	this.group = GuiElements.create.group(this.x, this.y);
	TouchReceiver.addListenersOverlayPart(this.group);
	this.bgRect = GuiElements.create.rect(this.group);
	GuiElements.update.color(this.bgRect, Menu.bgColor);
	this.menuBnList = null;
	this.visible = false;

	// Configure callbacks
	button.setCallbackFunction(this.open.bind(this), false);
	button.setUnToggleFunction(this.close.bind(this));

	this.button = button;

	/* The alternateFn is specified using addAlternateFn() and is called if previewOpen returns false */
	this.alternateFn = null;
	this.scheduleAlternate = false;
}
Menu.prototype = Object.create(Overlay.prototype);
Menu.prototype.constructor = Menu;

Menu.setGraphics = function() {
	Menu.defaultWidth = 170;
	Menu.bnMargin = Button.defaultMargin;
	Menu.bgColor = Colors.black;
};

/**
 * Recomputes the Menu's location based on the location of the Button
 */
Menu.prototype.move = function() {
	this.x = this.button.x;
	this.y = this.button.y + this.button.height;
	GuiElements.move.group(this.group, this.x, this.y);
	if (this.menuBnList != null) {
		this.menuBnList.updatePosition();
	}
};

/**
 * Generates the SmoothMenuBnList for the Menu
 */
Menu.prototype.createMenuBnList = function() {
	if (this.menuBnList != null) {
		this.menuBnList.hide();
	}
	const bnM = Menu.bnMargin;
	this.menuBnList = new SmoothMenuBnList(this, this.group, bnM, bnM, this.width);
	this.menuBnList.markAsOverlayPart(this);
	const maxH = GuiElements.height - this.y - Menu.bnMargin * 2;
	this.menuBnList.setMaxHeight(maxH);
};

/**
 * Adds an option to the menu.  Should be called within the loadOptions function
 * @param {string} text - The text to display the option
 * @param {function} func - type () -> (), the function to call when the option is tapped
 * @param {boolean} [close=true] - Whether the Menu should close or remain open when the option is selected
 * @param {function} [addTextFn] - type (Button) -> (), the function to call on the button to add the text.
 *                                 If provided, no text will be added to the button; rather the function is expected
 *                                 to do all formatting.
 */
Menu.prototype.addOption = function(text, func, close, addTextFn) {
	if (addTextFn == null) {
		addTextFn = null;
	}
	if (close == null) {
		close = true;
	}
	this.menuBnList.addOption(text, function() {
		if (close) {
			this.close();
		}
		if (func != null) {
			func.call(this);
		}
	}.bind(this), addTextFn);
};

/**
 * Creates the buttons and background of the menu
 */
Menu.prototype.buildMenu = function() {
	const mBL = this.menuBnList;
	mBL.generateBns();
	GuiElements.update.rect(this.bgRect, 0, 0, mBL.width + 2 * Menu.bnMargin, mBL.height + 2 * Menu.bnMargin);
};

/**
 * Determines whether the Menu should open or the alternate function should be run.  The alternate function is run after
 * the user releases the button, so it must be scheduled, not run immediately.
 * @return {boolean}
 */
Menu.prototype.previewOpen = function() {
	// By default, the Menu always opens.  But subclasses like the DeviceMenu override this method
	return true;
};

/**
 * Abstract function that is called when the Menu opens to populate the options.  Calls addOption for each option
 */
Menu.prototype.loadOptions = function() {
	DebugOptions.markAbstract();
};
Menu.prototype.open = function() {
	if (!this.visible) {
		if (this.previewOpen()) {
			this.createMenuBnList();
			this.loadOptions();
			this.buildMenu();
			GuiElements.layers.overlay.appendChild(this.group);
			this.menuBnList.show();
			this.visible = true;
			this.addOverlayAndCloseOthers();
			this.button.markAsOverlayPart(this);
			this.scheduleAlternate = false;
		} else {
			this.button.toggled = true;
			this.scheduleAlternate = true;
		}
	}
};

/**
 * closes the Menu
 * @inheritDoc
 */
Menu.prototype.close = function() {
	if (this.visible) {
		this.hide();
		this.button.unToggle();
		this.button.unmarkAsOverlayPart();
	} else if (this.scheduleAlternate) {
		this.scheduleAlternate = false;
		this.alternateFn();
	}
};

/**
 * hides the Menu
 * @inheritDoc
 */
Menu.prototype.hide = function() {
	this.group.remove();
	this.menuBnList.hide();
	this.visible = false;
	Overlay.removeOverlay(this);
};

/**
 * Sets a function which is called when previewOpen returns false
 * @param {function} alternateFn - type () -> ()
 */
Menu.prototype.addAlternateFn = function(alternateFn) {
	this.alternateFn = alternateFn;
};

/**
 * @param {number} x
 * @return {number}
 */
Menu.prototype.relToAbsX = function(x) {
	return x + this.x;
};
/**
 * @param {number} y
 * @return {number}
 */
Menu.prototype.relToAbsY = function(y) {
	return y + this.y;
};

/**
 * Resizes and repositions the menu
 */
Menu.prototype.updateZoom = function() {
	if (this.menuBnList != null) {
		this.menuBnList.updateZoom();
	}
};
/**
 * Deprecated class that used to be used as a file menu
 * @param {Button} button
 * @constructor
 */
function FileMenu(button) {
	Menu.call(this, button);
}
FileMenu.prototype = Object.create(Menu.prototype);
FileMenu.prototype.constructor = FileMenu;
FileMenu.prototype.loadOptions = function() {
	this.addOption("New", function() {
		let request = new HttpRequestBuilder("data/createNewFile");
		HtmlServer.sendRequestWithCallback(request.toString());
	});
	this.addOption("Open", OpenDialog.showDialog);
	this.addOption("Duplicate", SaveManager.userDuplicate);
	this.addOption("Rename", SaveManager.userRename);
	this.addOption("Delete", SaveManager.userDelete);
	this.addOption("Share", SaveManager.userExport);
	this.addOption("OpenFromCloud", function() {
		let request = new HttpRequestBuilder("data/showCloudPicker");
		HtmlServer.sendRequestWithCallback(request.toString());
	});
	//this.addOption("Debug", this.optionEnableDebug);
	if (GuiElements.isKindle) {
		this.addOption("Exit", this.optionExit);
	}
};
FileMenu.prototype.optionNew = function() {
	SaveManager.new();
};
FileMenu.prototype.optionEnableDebug = function() {
	TitleBar.enableDebug();
};
FileMenu.prototype.optionExit = function() {
	SaveManager.checkPromptSave(function() {
		HtmlServer.sendRequest("tablet/exit");
	});
};
/**
 * A menu which is only enabled when testing (as determined by DebugOptions) which provides options for debugging
 * @param {Button} button
 * @constructor
 */
function DebugMenu(button) {
	Menu.call(this, button, 130);
	// Used for storing the last request issued using the debug menu so it can be prefilled
	this.lastRequest = "";
	this.lastResponse = "";
}
DebugMenu.prototype = Object.create(Menu.prototype);
DebugMenu.prototype.constructor = DebugMenu;

/**
 * @inheritDoc
 */
DebugMenu.prototype.loadOptions = function() {
	// Turns on logging (printing to the debug span) if disabled
	this.addOption("Enable logging", DebugOptions.enableLogging);
	// Provides a dialog to load a file by pasting in XML
	this.addOption("Load file", this.loadFile);
	// Shows the XML for the current file in a new tab
	this.addOption("Download file", this.downloadFile);
	// Hides the debug menu
	this.addOption("Hide Debug", this.disableDebug);
	// Displays the version of the frontend, as set in version.js
	this.addOption("Version", this.optionVersion);
	// Sends the specified request to the backend
	this.addOption("Send request", this.optionSendRequest);
	// Creates fake robots in the connection menus for testing
	this.addOption("Allow virtual Robots", DebugOptions.enableVirtualDevices);
	// Clears the debug span
	this.addOption("Clear log", this.optionClearLog);
	// Tests throwing an error in the JS
	this.addOption("Throw error", function() {
		throw new UserException("test error");
	});
	// Prevents the JS from shutting off when there is an error
	this.addOption("Stop error locking", DebugOptions.stopErrorLocking);
};

DebugMenu.prototype.disableDebug = function() {
	GuiElements.alert("");
	DebugOptions.enabled = false;
	TitleBar.hideDebug();
}

/**
 * Provides a dialog to paste XML into so is can be loaded as a file
 */
DebugMenu.prototype.loadFile = function() {
	DialogManager.showPromptDialog("Load File", "Paste file contents", "", true, function(cancelled, resp) {
		if (!cancelled) {
			SaveManager.backendOpen("Pasted file", resp, true);
		}
	});
};

/**
 * Opens the XML for the current file in a new tab
 */
DebugMenu.prototype.downloadFile = function() {
	const xml = XmlWriter.docToText(CodeManager.createXml());
	const url = "data:text/plain," + HtmlServer.encodeHtml(xml);
	window.open(url, '_blank');
};

/**
 * Prints the version of the frontend as stored in Version.js
 */
DebugMenu.prototype.optionVersion = function() {
	GuiElements.alert("Version: " + GuiElements.appVersion);
};

/**
 * Clears the debug log
 */
DebugMenu.prototype.optionClearLog = function() {
	GuiElements.alert("");
};

/**
 * Provides a dialog for sending requests to the backend
 */
DebugMenu.prototype.optionSendRequest = function() {
	let message = this.lastResponse;
	if (this.lastResponse === "") {
		message = "Request: http://localhost:22179/[...]"
	}
	const me = this;
	DialogManager.showPromptDialog("Send request", message, this.lastRequest, true, function(cancel, request) {
		if (!cancel && (request !== "" || me.lastRequest !== "")) {
			if (request === "") {
				request = me.lastRequest;
			}
			me.lastRequest = request;
			HtmlServer.sendRequestWithCallback(request, function(resp) {
				me.lastResponse = "Response: \"" + resp + "\"";
				me.optionSendRequest();
			}, function() {
				me.lastResponse = "Error sending request";
				me.optionSendRequest();
			});
		} else {
			me.lastResponse = "";
		}
	}, function() {
		me.lastResponse = "";
	});
};
/**
 * Deprecated menu that used to control zoom.  Replaced with SettingsMenu
 * @param {Button} button
 * @constructor
 */
function ViewMenu(button) {
	Menu.call(this, button);
}
ViewMenu.prototype = Object.create(Menu.prototype);
ViewMenu.prototype.constructor = ViewMenu;
ViewMenu.prototype.loadOptions = function() {
	this.addOption("Zoom in", this.optionZoomIn, false);
	this.addOption("Zoom out", this.optionZoomOut, false);
	this.addOption("Reset zoom", this.optionResetZoom, true);
};
ViewMenu.prototype.optionZoomIn = function() {
	GuiElements.zoomMultiple += GuiElements.zoomAmount;
	GuiElements.zoomMultiple = Math.min(GuiElements.zoomMultiple, GuiElements.maxZoomMult);
	GuiElements.updateZoom();
};
ViewMenu.prototype.optionZoomOut = function() {
	GuiElements.zoomMultiple -= GuiElements.zoomAmount;
	GuiElements.zoomMultiple = Math.max(GuiElements.zoomMultiple, GuiElements.minZoomMult);
	GuiElements.updateZoom();
};
ViewMenu.prototype.optionResetZoom = function() {
	GuiElements.zoomMultiple = 1;
	GuiElements.updateZoom();
};
/**
 * Provides a menu for adjusting the zoom and other settings
 * @param {Button} button
 * @constructor
 */
function SettingsMenu(button) {
	Menu.call(this, button);
}
SettingsMenu.prototype = Object.create(Menu.prototype);
SettingsMenu.prototype.constructor = SettingsMenu;

/**
 * @inheritDoc
 */
SettingsMenu.prototype.loadOptions = function() {
	// Used to have icons, but they didn't work two well and have been disabled
	this.addOption("Zoom in", this.optionZoomIn, false); //, VectorPaths.zoomIn);
	this.addOption("Zoom out", this.optionZoomOut, false); //, VectorPaths.zoomOut);
	this.addOption("Reset zoom", this.optionResetZoom, true); //, VectorPaths.resetZoom);
	if (SettingsManager.enableSnapNoise.getValue() === "true") {
		this.addOption("Disable snap noise", this.disableSnapping, true); //, VectorPaths.volumeMute);
	} else {
		this.addOption("Enable snap noise", this.enableSnapping, true); //, VectorPaths.volumeUp);
	}
	if (this.showAdvanced) {
		this.addOption("Send debug log", this.optionSendDebugLog, true);
		this.addOption("Show debug menu", this.enableDebug, true);
	}
};

/**
 * Increases the zoom level and updates the UI
 */
SettingsMenu.prototype.optionZoomIn = function() {
	SettingsManager.zoom.writeValue(GuiElements.zoomMultiple + GuiElements.zoomAmount);
	GuiElements.zoomMultiple = SettingsManager.zoom.getValue();
	GuiElements.updateZoom();
};

/**
 * Decreases the zoom level and updates the UI
 */
SettingsMenu.prototype.optionZoomOut = function() {
	SettingsManager.zoom.writeValue(GuiElements.zoomMultiple - GuiElements.zoomAmount);
	GuiElements.zoomMultiple = SettingsManager.zoom.getValue();
	GuiElements.updateZoom();
};

/**
 * Sets the zoom level back to default
 */
SettingsMenu.prototype.optionResetZoom = function() {
	SettingsManager.zoom.writeValue(1);
	GuiElements.zoomMultiple = SettingsManager.zoom.getValue();
	GuiElements.updateZoom();
};

/**
 * Enables the sound on Block snap
 */
SettingsMenu.prototype.enableSnapping = function() {
	SettingsManager.enableSnapNoise.writeValue("true");
};

/**
 * Disables the sound on Block snap
 */
SettingsMenu.prototype.disableSnapping = function() {
	SettingsManager.enableSnapNoise.writeValue("false");
};

/**
 * Tells the backend to send the current debug log
 */
SettingsMenu.prototype.optionSendDebugLog = function() {
	const request = new HttpRequestBuilder("debug/shareLog");
	HtmlServer.sendRequestWithCallback(request.toString());
};

/**
 * Shows the SettingsMenu and stores whether it should show with advanced options
 * @param {boolean} [showAdvanced=false]
 */
SettingsMenu.prototype.open = function(showAdvanced) {
	if (showAdvanced == null) {
		showAdvanced = false;
	}
	this.showAdvanced = showAdvanced;
	Menu.prototype.open.call(this);
};

/**
 * Re-opens the menu (if it is open) with advanced options visible)
 */
SettingsMenu.prototype.reloadAdvanced = function() {
	if (this.visible) {
		this.hide();
		this.open(true);
		if (this.button.toggled) {
			this.button.pressed = false;
		}
	}
};

SettingsMenu.prototype.enableDebug = function() {
	DebugOptions.enabled = true;
	TitleBar.enableDebug();
}
/**
 * A menu which displays information about the connected device and provides options to connect to/disconnect from
 * devices
 * @param {Button} button
 * @constructor
 */
function DeviceMenu(button) {
	Menu.call(this, button, DeviceMenu.width);
	this.addAlternateFn(function() {
		// If more than one device is connected, the connect multiple dialog is used instead
		ConnectMultipleDialog.showDialog();
	});
}
DeviceMenu.prototype = Object.create(Menu.prototype);
DeviceMenu.prototype.constructor = ViewMenu;

DeviceMenu.setGraphics = function() {
	DeviceMenu.width = 150;
	DeviceMenu.maxDeviceNameChars = 8;
};

/**
 * @inheritDoc
 */
DeviceMenu.prototype.loadOptions = function() {
	let connectedClass = null;
	Device.getTypeList().forEach(function(deviceClass) {
		/* The menu only shows up if no more than 1 device is connected. So if a DeviceManager has at least one device
		 * is it the connectedClass */
		if (deviceClass.getManager().getDeviceCount() > 0) {
			connectedClass = deviceClass;
		}
	});
	if (connectedClass != null) {
		// If there is a device connected, we add an option to display firmware info about the device
		this.addDeviceOption(connectedClass);
		// And we add an option to disconnect from it.
		this.addOption("Disconnect " + connectedClass.getDeviceTypeName(false, DeviceMenu.maxDeviceNameChars), function() {
			connectedClass.getManager().removeAllDevices();
		});
	} else {
		// If no devices are connected, we add an option to connect to each type of device
        /*
        this.addOption("Connect Device", function() {
            (new DiscoverDialog(deviceClass)).show();
        });


		Device.getTypeList().forEach(function(deviceClass) {
		    let deviceTypeName = deviceClass.getDeviceTypeName(false, DeviceMenu.maxDeviceNameChars);
		    if ((deviceTypeName) === "HB"){
			    this.addOption("Connect Device", function() {
				    (new DiscoverDialog(DeviceWithPorts)).show();
			    });
			}
		}, this);
        */

        Device.getTypeList().forEach(function(deviceClass) {
        	this.addOption("Connect " + deviceClass.getDeviceTypeName(false, DeviceMenu.maxDeviceNameChars), function() {
        		(new DiscoverDialog(deviceClass)).show();
        	});
        }, this);


	}
	// Regardless, we provide an option to connect to every type of device
	this.addOption("Connect Multiple", ConnectMultipleDialog.showDialog);
};

/**
 * Adds an option for getting firmware info about the currently connected device.  The option includes a yellow/red
 * warning icon if firmware is out of date
 * @param connectedClass - Subclass of Device
 */
DeviceMenu.prototype.addDeviceOption = function(connectedClass) {
	const device = connectedClass.getManager().getDevice(0);
	const status = device.getFirmwareStatus();
	const statuses = Device.firmwareStatuses;
	let icon = null;
	let color = null;
	if (status === statuses.old) {
		// If the firmware is old but usable, a yellow icon is used
		icon = VectorPaths.warning;
		color = DeviceStatusLight.yellowColor;
	} else if (status === statuses.incompatible) {
		// If the firmware is not usable, a red icon is used
		icon = VectorPaths.warning;
		color = DeviceStatusLight.redColor;
	}
	this.addOption("", device.showFirmwareInfo.bind(device), false, this.createAddIconToBnFn(icon, device.name, color));
};

/**
 * Determines whether multiple devices are connected, in which case the connect multiple dialog should be opened
 * @inheritDoc
 * @return {boolean}
 */
DeviceMenu.prototype.previewOpen = function() {
	let connectionCount = 0;
	Device.getTypeList().forEach(function(deviceClass) {
		connectionCount += deviceClass.getManager().getDeviceCount();
	});
	return (connectionCount <= 1);
};

/**
 * Creates a function to format a button based on the provided options
 * @param {string} [pathId] - Object from VectorPaths to use as an icon on the side of the button
 * @param {string} text - Test to place on the button
 * @param {string} [color] - The color of the icon in hex (not needed if no icon will be added)
 * @return {function} - type (Button) -> (), a function to format the provided button with the specified icon and text
 */
DeviceMenu.prototype.createAddIconToBnFn = function(pathId, text, color) {
	if (pathId == null) {
		return function(bn) {
			bn.addText(text);
		}
	}
	return function(bn) {
		bn.addSideTextAndIcon(pathId, null, text, null, null, null, null, null, color, true, false);
	}
};
/**
 * An menu that appears when a BLock is long pressed. Provides options to delete or duplicate the block.
 * Also used to give a rename option to variables and lists
 *
 * @param {Block} block
 * @param {number} x - The x coord the menu should appear at
 * @param {number} y - The y coord the menu should appear at
 * @constructor
 */
function BlockContextMenu(block, x, y) {
	this.block = block;
	this.x = x;
	this.y = y;
	this.showMenu();
}

BlockContextMenu.setGraphics = function() {
	const BCM = BlockContextMenu;
	BCM.bnMargin = Button.defaultMargin;
	BCM.bgColor = Colors.black;
	BCM.blockShift = 20;
};

/**
 * Renders the menu
 */
BlockContextMenu.prototype.showMenu = function() {
	const BCM = BlockContextMenu;
	this.group = GuiElements.create.group(0, 0);

	let layer = GuiElements.layers.inputPad;
	let overlayType = Overlay.types.inputPad;
	this.bubbleOverlay = new BubbleOverlay(overlayType, BCM.bgColor, BCM.bnMargin, this.group, this, layer);
	this.menuBnList = new SmoothMenuBnList(this.bubbleOverlay, this.group, 0, 0);
	this.menuBnList.markAsOverlayPart(this.bubbleOverlay);
	this.addOptions();
	const height = this.menuBnList.previewHeight();
	const width = this.menuBnList.previewWidth();
	this.bubbleOverlay.display(this.x, this.x, this.y, this.y, this.menuBnList.width, height);
	this.menuBnList.show();
};

/**
 * Adds options to the menu based on the stack the menu is for.
 */
BlockContextMenu.prototype.addOptions = function() {
	// TODO: This information should probably be passed in by the constructor, not figured out by the ContextMenu
	if (this.block.stack.isDisplayStack) {
		if (this.block.constructor === B_Variable) {

			this.menuBnList.addOption("Rename", function() {
				this.block.renameVar();
				this.close();
			}.bind(this));

			this.menuBnList.addOption("Delete", function() {
				this.block.deleteVar();
				this.close();
			}.bind(this));

		}
		if (this.block.constructor === B_List) {

			this.menuBnList.addOption("Rename", function() {
				this.block.renameLi();
				this.close();
			}.bind(this));

			this.menuBnList.addOption("Delete", function() {
				this.block.deleteLi();
				this.close();
			}.bind(this));

		}
	} else {

		this.menuBnList.addOption("Duplicate", function() {
			this.duplicate();
		}.bind(this));

		this.menuBnList.addOption("Delete", function() {
			// Delete the stack and add it to the UndoManager
			UndoManager.deleteStack(this.block.unsnap());
			this.close();
		}.bind(this));

	}
};

/**
 * Duplicates this menu's Block and all blocks below it.
 */
BlockContextMenu.prototype.duplicate = function() {
	const BCM = BlockContextMenu;
	const newX = this.block.getAbsX() + BCM.blockShift;
	const newY = this.block.getAbsY() + BCM.blockShift;
	const blockCopy = this.block.duplicate(newX, newY);
	const tab = this.block.stack.tab;
	const copyStack = new BlockStack(blockCopy, tab);
	//copyStack.updateDim();
	this.close();
};

/**
 * Closes the menu
 */
BlockContextMenu.prototype.close = function() {
	this.block = null;
	this.bubbleOverlay.hide();
	this.menuBnList.hide();
};
/**
 * A VectorIcon controls an SVG path element. It draws the information for the path from VectorPaths.js and rescales
 * the path appropriately.
 * @param {number} x - The x coord of the path
 * @param {number} y - The y coord of the path
 * @param {object} pathId - The object from VectorPaths containing the information about the path to draw
 * @param {string} color - Color in hex
 * @param {number} height - The height the path should be.  Width is computed from this
 * @param {Element} parent - An SVG group element the path should go inside
 * @constructor
 */
function VectorIcon(x, y, pathId, color, height, parent) {
	this.x = x;
	this.y = y;
	this.color = color;
	this.height = height;
	this.pathId = pathId;
	this.parent = parent;
	this.pathE = null;
	this.draw();
}

/**
 * Static function used to preview the width of a VectorIcon before it is drawn
 * @param {object} pathId - An object from VectorPaths
 * @param {number} height - The height to use for the previewed path
 * @return {number} - The width the icon would have, if created
 */
VectorIcon.computeWidth = function(pathId, height) {
	const scale = height / pathId.height;
	return scale * pathId.width;
};

/**
 * Creates the SVG pathE and the group to contain it
 */
VectorIcon.prototype.draw = function() {
	this.scale = this.height / this.pathId.height;
	this.width = this.scale * this.pathId.width;
	this.group = GuiElements.create.group(this.x, this.y, this.parent);
	this.group.setAttributeNS(null, "transform", "translate(" + this.x + "," + this.y + ") scale(" + this.scale + ")");
	this.pathE = GuiElements.create.path(this.group);
	this.pathE.setAttributeNS(null, "d", this.pathId.path);
	this.pathE.setAttributeNS(null, "fill", this.color);
	this.group.appendChild(this.pathE);
};

/**
 * Changes the color of the icon
 * @param {string} color - color in hex
 */
VectorIcon.prototype.setColor = function(color) {
	this.color = color;
	this.pathE.setAttributeNS(null, "fill", this.color);
};

/**
 * Moves the icon to the specified coordinates
 * @param {number} x
 * @param{number} y
 */
VectorIcon.prototype.move = function(x, y) {
	this.x = x;
	this.y = y;
	this.group.setAttributeNS(null, "transform", "translate(" + this.x + "," + this.y + ") scale(" + this.scale + ")");
};

/* Deletes the icon and removes the path from its parent group. */
VectorIcon.prototype.remove = function() {
	this.pathE.remove();
};
/**
 * Static class in charge of indicating where the blocks being dragged will snap to when dropped.  It has a single
 * white (or black if Blocks are running) path element which it moves around and reshapes
 */
function Highlighter() {
	Highlighter.path = Highlighter.createPath();
	Highlighter.visible = false;
}

/**
 * Creates a path object for the highlighter
 * @return {Element}
 */
Highlighter.createPath = function() {
	const bG = BlockGraphics.highlight;
	const path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
	path.setAttributeNS(null, "stroke", bG.strokeC);
	path.setAttributeNS(null, "stroke-width", bG.strokeW);
	path.setAttributeNS(null, "fill", "none");
	return path;
};

/**
 * Highlights a Block/Slot based on the provided information
 * @param {number} x - The x coord the highlighter should appear at
 * @param {number} y - The y coord the highlighter should appear at
 * @param {number} width - The width the highlighter should have (for slots)
 * @param {number} height - The height the highlighter should have (for slots)
 * @param {number} type - The type of path according to the BlockGraphics type system
 * @param {boolean} isSlot - Whether the thing being highlighted is a Slot
 * @param {boolean} isGlowing - Whether the thing being highlighted already has a white outline (since it is running)
 *                              and should therefore by highlighted in black
 */
Highlighter.highlight = function(x, y, width, height, type, isSlot, isGlowing) {
	const myX = CodeManager.dragAbsToRelX(x);
	const myY = CodeManager.dragAbsToRelX(y);
	const pathD = BlockGraphics.buildPath.highlight(myX, myY, width, height, type, isSlot);
	Highlighter.path.setAttributeNS(null, "d", pathD);
	if (!Highlighter.visible) {
		GuiElements.layers.highlight.appendChild(Highlighter.path);
		Highlighter.visible = true;
	}
	const bG = BlockGraphics.highlight;
	if (isGlowing != null && isGlowing) {
		Highlighter.path.setAttributeNS(null, "stroke", bG.strokeDarkC);
	} else {
		Highlighter.path.setAttributeNS(null, "stroke", bG.strokeC);
	}
};

/**
 * Removes the highlighter from view
 */
Highlighter.hide = function() {
	if (Highlighter.visible) {
		Highlighter.path.remove();
		Highlighter.visible = false;
	}
};
/**
 * Manages three DisplayBoxes on the bottom of the screen.  DisplayBoxes are triggered by the display block and
 * which box is shown depends on the position parameter of the block
 */
function DisplayBoxManager(){
	const DBM = DisplayBoxManager;
	DBM.boxes = [];
	// Create 3 boxes
	for(let i = 0; i < 3; i++) {
		DBM.boxes[i] = new DisplayBox(i);
	}
	// Build each box
	DBM.build();
}

/**
 * Builds all the Manager's boxes
 */
DisplayBoxManager.build = function(){
	const DBM = DisplayBoxManager;
	DBM.boxes.forEach(function(box){
		box.build();
	});
};

/**
 * Makes the specified DisplayBox display the message
 * @param {string} message - The message to display
 * @param {string} positionString - "position#", The position of the box, as a string
 */
DisplayBoxManager.displayText = function(message, positionString) {
	const DBM = DisplayBoxManager;
	if(positionString === "position1") {
		DBM.boxes[0].displayText(message);
	} else if(positionString === "position2") {
		DBM.boxes[1].displayText(message);
	} else if(positionString === "position3") {
		DBM.boxes[2].displayText(message);
	} else {
		// Invalid data stored in slot
		DebugOptions.assert(false);
	}
};

/**
 * Hides all DisplayBoxes (when one is tapped)
 */
DisplayBoxManager.hide = function(){
	const DBM = DisplayBoxManager;
	DBM.boxes.forEach(function(box){
		box.hide();
	});
};

/**
 * Resizes all DisplayBoxes
 */
DisplayBoxManager.updateZoom = function(){
	DisplayBox.updateZoom();
	DisplayBoxManager.boxes.forEach(function(box){
		box.updateZoom();
	})
};
/**
 * Displays text in a large, white box at the bottom of the screen.  Triggered by display Block.  No SVG elements
 * are created until build() is called.
 * @param {number} position - A 0-indexed number indicating the position of the DisplayBox on the screen
 * @constructor
 */
function DisplayBox(position) {
	this.position = position;
	this.visible = false;
	this.layer = GuiElements.layers.display;
}

DisplayBox.setGraphics = function() {
	const DB = DisplayBox;
	DB.bgColor = Colors.white;
	DB.fontColor = Colors.black;
	DB.font = Font.uiFont(35);
	DB.screenMargin = 60;
	DB.rectH = 50;
	DB.margin = 10;
	DB.rectX = DB.screenMargin;
	DB.rectW = GuiElements.width - 2 * DB.screenMargin;
};

/**
 * Builds the elements of the box
 */
DisplayBox.prototype.build = function() {
	const DB = DisplayBox;
	this.rectY = this.getRectY();
	this.rectE = GuiElements.draw.rect(DB.rectX, this.rectY, DB.rectW, DB.rectH, DB.bgColor);
	this.textE = GuiElements.draw.text(0, 0, "", DB.font, DB.fontColor);
	TouchReceiver.addListenersDisplayBox(this.rectE);
	TouchReceiver.addListenersDisplayBox(this.textE);
};

/**
 * Computes the y-cord of the box based on the position and constants
 * @return {number}
 */
DisplayBox.prototype.getRectY = function() {
	const DB = DisplayBox;
	const fromBottom = 2 - this.position;
	return GuiElements.height - (DB.rectH + DB.margin) * fromBottom - DB.rectH - DB.screenMargin;
};

/**
 * Resets the graphics
 */
DisplayBox.updateZoom = function() {
	DisplayBox.setGraphics();
};

/**
 * Resizes the box
 */
DisplayBox.prototype.updateZoom = function() {
	const DB = DisplayBox;
	this.rectY = this.getRectY();
	const textW = GuiElements.measure.textWidth(this.textE);
	const textX = DB.rectX + DB.rectW / 2 - textW / 2;
	const textY = this.rectY + DB.rectH / 2 + DB.font.charHeight / 2;
	GuiElements.move.text(this.textE, textX, textY);
	GuiElements.update.rect(this.rectE, DB.rectX, this.rectY, DB.rectW, DB.rectH);
};

/**
 * Sets the text of the box
 * @param {string} text - The text to show
 */
DisplayBox.prototype.displayText = function(text) {
	const DB = DisplayBox;
	GuiElements.update.textLimitWidth(this.textE, text, DB.rectW);
	const textW = GuiElements.measure.textWidth(this.textE);
	const textX = DB.rectX + DB.rectW / 2 - textW / 2;
	const textY = this.rectY + DB.rectH / 2 + DB.font.charHeight / 2;
	GuiElements.move.text(this.textE, textX, textY);
	this.show();
};

/**
 * Make the DisplayBox visible
 */
DisplayBox.prototype.show = function() {
	if (!this.visible) {
		this.layer.appendChild(this.rectE);
		this.layer.appendChild(this.textE);
		this.visible = true;
	}
};

/**
 * Hides the DisplayBox
 */
DisplayBox.prototype.hide = function() {
	if (this.visible) {
		this.textE.remove();
		this.rectE.remove();
		this.visible = false;
	}
};


/**
 * CodeManager is a static class that controls block execution. It also moves the BlockStack that the user is dragging,
 * keeps track of variables/lists, and passes messages to Blocks/Stacks/Slots/Tabs
 */
function CodeManager() {
	const move = CodeManager.move;   // shorthand
	move.moving = false;   // Is there a BlockStack that is currently moving?
	move.stack = null;   // Reference to BlockStack that is currently moving.
	move.offsetX = 0;   // The difference between the BlockStack's x and the touch x.
	move.offsetY = 0;   // The difference between the BlockStack's y and the touch y.
	move.touchX = 0;   // The x coord of the user's finger.
	move.touchY = 0;   // The y coord of the user's finger.
	move.topX = 0;   // The top-left corner's x coord of the BlockStack being moved.
	move.topY = 0;   // The top-left corner's y-coord of the BlockStack being moved.
	move.bottomX = 0;   // The bottom-right corner
	move.bottomY = 0;
	move.startedFromPalette = false;   // Whether the block being dragged originated from the BLockPalette
	// The return type of the BlockStack. (none unless it is a reporter, predicate, etc.)
	move.returnType = null;
	// Stores information used when determine which slot is closest to the moving stack.
	CodeManager.fit = {};

	CodeManager.variableList = [];   // A list of all the variables the user has created
	CodeManager.listList = [];   // A list of all the lists the user has created
	CodeManager.broadcastList = [];   // A list of broadcast messages in use.

	CodeManager.isRunning = false;   // Are at least some Blocks currently executing?

	CodeManager.updateTimer = null;   // A timer which tells executing Blocks to update.
	CodeManager.updateInterval = 10;   // How quickly does the update timer fire (in ms)?

	// Stores the answer to the "ask" block. When the app first opens, the answer is an empty string.
	CodeManager.answer = new StringData("");
	CodeManager.message = new StringData("");   // Stores the broadcast message.

	CodeManager.sound = {};   // Store data for sound playback
	CodeManager.sound.tempo = 60;   // Default tempo is 60 bpm for sound blocks.
	CodeManager.sound.volume = 50;   // Default volume if 50%.

	CodeManager.timerForSensingBlock = new Date().getTime();   // Initialize the timer to the current time.

	// Track creation and modified times for the current file
	// TODO: move this into SaveManager
	CodeManager.modifiedTime = new Date().getTime();
	CodeManager.createdTime = new Date().getTime();
}

/* CodeManager.move contains function to start, stop, and update the movement of a BlockStack.
 * These functions are called by the TouchReceiver class when the user drags a BlockStack. */
CodeManager.move = {};

/**
 * Picks up a Block so that it can be moved.  Stores necessary information in CodeManager.move.
 * Transfers the BlockStack into the drag layer above other blocks.
 * @param {Block} block - The block the user dragged.
 * @param {number} x - The x coord of the user's finger.
 * @param {number} y - The y coord of the user's finger.
 */
CodeManager.move.start = function(block, x, y) {
	const move = CodeManager.move;   // shorthand
	if (!move.moving) {   // Only start moving the Block if no other Blocks are moving.
		Overlay.closeOverlays();   // Close any visible overlays.
		move.moving = true;   // Record that a Block is now moving.
		/* Disconnect the Block from its current BlockStack to form a new BlockStack 
		containing only the Block and the Blocks below it. */
		const stack = block.unsnap();
		stack.fly();   // Make the new BlockStack fly (moves it into the drag layer).
		move.bottomX = stack.relToAbsX(stack.dim.rw);   // Store the BlockStack's dimensions.
		move.bottomY = stack.relToAbsY(stack.dim.rh);
		move.returnType = stack.returnType;   // Store the BlockStack's return type.
		move.startedFromPalette = BlockPalette.isStackOverPalette(x, y);

		// Store other information about how the BlockStack can connect to other Blocks.
		move.bottomOpen = stack.getLastBlock().bottomOpen;
		move.topOpen = stack.firstBlock.topOpen;
		move.returnsValue = stack.firstBlock.returnsValue;

		move.touchX = x;   // Store coords
		move.touchY = y;
		move.offsetX = stack.getAbsX() - x;   // Store offset.
		move.offsetY = stack.getAbsY() - y;
		move.stack = stack;   // Store stack.
	}
};

/**
 * Updates the position of the currently moving BlockStack.
 * Also highlights the slot that fits it best (if any).
 * @param {number} x - The x coord of the user's finger.
 * @param {number} y - The y coord of the user's finger.
 */
CodeManager.move.update = function(x, y) {
	const move = CodeManager.move;   // shorthand
	if (move.moving) {   // Only update if a BlockStack is currently moving.
		move.touchX = x;
		move.touchY = y;
		move.topX = move.offsetX + x;
		move.topY = move.offsetY + y;
		move.bottomX = move.stack.relToAbsX(move.stack.dim.rw);
		move.bottomY = move.stack.relToAbsY(move.stack.dim.rh);
		// Move the BlockStack to the correct location.
		move.stack.move(CodeManager.dragAbsToRelX(move.topX), CodeManager.dragAbsToRelY(move.topY));
		// If the BlockStack overlaps with the BlockPalette then no slots are highlighted.
		if (BlockPalette.isStackOverPalette(move.touchX, move.touchY)) {
			Highlighter.hide();   // Hide any existing highlight.
			if (!move.startedFromPalette) {
				BlockPalette.showTrash();
			}
		} else {
			BlockPalette.hideTrash();
			// The slot which fits it best (if any) will be stored in CodeManager.fit.bestFit.
			CodeManager.findBestFit();
			if (CodeManager.fit.found) {
				CodeManager.fit.bestFit.highlight();   // If such a slot exists, highlight it.
			} else {
				Highlighter.hide();   // If not, hide any existing highlight.
			}
		}
	}
};

/**
 * Drops the BlockStack that is currently moving and connects it to the Slot/Block that fits it.
 */
CodeManager.move.end = function() {
	const move = CodeManager.move;   // shorthand
	const fit = CodeManager.fit;   // shorthand
	if (move.moving) {   // Only run if a BlockStack is currently moving.
		move.topX = move.offsetX + move.touchX;
		move.topY = move.offsetY + move.touchY;
		move.bottomX = move.stack.relToAbsX(move.stack.dim.rw);
		move.bottomY = move.stack.relToAbsY(move.stack.dim.rh);
		// If the BlockStack overlaps with the BlockPalette, delete it.
		if (BlockPalette.isStackOverPalette(move.touchX, move.touchY)) {
			if (move.startedFromPalette) {
				move.stack.remove();
			} else {
				UndoManager.deleteStack(move.stack);
				SaveManager.markEdited();
			}
		} else {
			// The Block/Slot which fits it best (if any) will be stored in CodeManager.fit.bestFit.
			CodeManager.findBestFit();
			if (fit.found) {
				// Snap is onto the Block/Slot that fits it best.
				fit.bestFit.snap(move.stack.firstBlock);
				Sound.playSnap();
			} else {
				// If it is not going to be snapped or deleted, simply drop it onto the current tab.
				move.stack.land();
				move.stack.updateDim();   // Fix! this line of code might not be needed.
			}
			SaveManager.markEdited();
		}
		Highlighter.hide();   // Hide any existing highlight.
		move.moving = false;   // There are now no moving BlockStacks.
		BlockPalette.hideTrash();
	}
};

/**
 * Drops the BlockStack where it is without attaching it to anything or deleting it.
 */
CodeManager.move.interrupt = function() {
	const move = CodeManager.move;   // shorthand
	if (move.moving) {   // Only run if a BlockStack is currently moving.
		move.topX = move.offsetX + move.touchX;
		move.topY = move.offsetY + move.touchY;
		move.stack.land();
		move.stack.updateDim();   // Fix! this line of code might not be needed.
		Highlighter.hide();   // Hide any existing highlight.
		move.moving = false;   // There are now no moving BlockStacks.
	}
};

/**
 * Returns a boolean indicating if a point falls within a rectangular region.
 * Useful for determining which Blocks a moving BlockStack can connect to.
 * @param {number} x1 - The x coord of the point.
 * @param {number} y1 - The y coord of the point.
 * @param {number} xR - The x coord of the top-left corner of the region.
 * @param {number} yR - The y coord of the top-left corner of the region.
 * @param {number} width - The width of the region.
 * @param {number} height - The height of the region.
 * @return {boolean} - Is the point within the region?
 */
CodeManager.move.pInRange = function(x1, y1, xR, yR, width, height) {
	// Checks to see if the point is on the correct side of all four sides of the rectangular region.
	return (x1 >= xR && x1 <= xR + width && y1 >= yR && y1 <= yR + height);
};

/**
 * Returns a boolean indicating if two rectangular regions overlap.
 * Useful for determining which Slots a moving BlockStack can connect to.
 * @param {number} x1 - The x coord of the top-left corner of the first region.
 * @param {number} y1 - The y coord of the top-left corner of the first region.
 * @param {number} width1 - The width of the first region.
 * @param {number} height1 - The height of the first region.
 * @param {number} x2 - The x coord of the top-left corner of the second region.
 * @param {number} y2 - The y coord of the top-left corner of the second region.
 * @param {number} width2 - The width of the second region.
 * @param {number} height2 - The height of the second region.
 * @return {boolean} - Do the rectangular regions overlap?
 */
CodeManager.move.rInRange = function(x1, y1, width1, height1, x2, y2, width2, height2) {
	// These conditions check that there are no vertical or horizontal gaps between the regions.
	// Is the right side of region 1 to the right of the left side of region 2?
	const xBigEnough = x1 + width1 >= x2;
	// Is the bottom side of region 1 below the top side of region 2?
	const yBigEnough = y1 + height1 >= y2;
	// Is the left side of region 1 to the left of the right side of region 2?
	const xSmallEnough = x1 <= x2 + width2;
	// Is the top side of region 1 above the bottom side of region 2?
	const ySmallEnough = y1 <= y2 + height2;
	// If it passes all 4 checks, the regions overlap.
	return xBigEnough && yBigEnough && xSmallEnough && ySmallEnough;
};

/**
 * Recursively searches for the Block/Slot that best fits the moving BlockStack.
 * All results are stored in CodeManager.fit.  Nothing is returned.
 */
CodeManager.findBestFit = function() {
	const fit = CodeManager.fit;   // shorthand
	fit.found = false;   // Have any matching slot/block been found?
	fit.bestFit = null;   // Slot/Block that is closest to the item?
	fit.dist = 0;   // How far is the best candidate from the ideal location?
	TabManager.activeTab.findBestFit();   // Begins the recursive calls.
};


/**
 * Recursively updates any Blocks that are currently executing.
 * Stops the update timer if all Blocks are finished.
 */
CodeManager.updateRun = function() {
	const CM = CodeManager;
	if (!TabManager.updateRun().isRunning()) {   // A recursive call.  Returns true if any Blocks are running.
		CM.stopUpdateTimer();   // If no Blocks are running, stop the update timer.
	}
};

/**
 * Recursively stops all Block execution.
 */
CodeManager.stop = function() {
	Device.stopAll();   // Stop any motors and LEDs on the devices
	TabManager.stop();   // Recursive call.
	CodeManager.stopUpdateTimer();   // Stop the update timer.
	DisplayBoxManager.hide();   // Hide any messages being displayed.
	Sound.stopAllSounds() // Stops all sounds and tones
	// Note: Tones are not allowed to be async, so they 
	// must be stopped manually
};

/**
 * Stops the update timer for block execution
 */
CodeManager.stopUpdateTimer = function() {
	if (CodeManager.isRunning) {   // If the timer is currently running...
		//...Stop the timer.
		CodeManager.updateTimer = window.clearInterval(CodeManager.updateTimer);
		CodeManager.isRunning = false;
	}
};

/**
 * Starts the update timer.  When it fires, the timer will call the CodeManager.updateRun function.
 */
CodeManager.startUpdateTimer = function() {
	if (!CodeManager.isRunning) {   // If the timer is not running...
		//...Start the timer.
		CodeManager.updateTimer = self.setInterval(DebugOptions.safeFunc(CodeManager.updateRun), CodeManager.updateInterval);
		CodeManager.isRunning = true;
	}
};

/**
 * Prevents too many Http commands from building up.
 * @return {boolean} - Whether a broadcast Block should run now or wait
 */
CodeManager.checkBroadcastDelay = function() {
	return HtmlServer.unansweredCount < HtmlServer.unansweredCap;
};


/**
 * Adds the Variable to CodeManager's list of variables
 * @param {Variable} variable
 */
CodeManager.addVariable = function(variable) {
	CodeManager.variableList.push(variable);
};

/**
 * Removes the Variable from CodeManager's list of variables
 * @param {Variable} variable
 */
CodeManager.removeVariable = function(variable) {
	const index = CodeManager.variableList.indexOf(variable);
	CodeManager.variableList.splice(index, 1);
};

/**
 * Requests the user to name a variable and then creates it
 * @param {function} [callbackCreate] - type (Variable) -> (), called if the user completes variable creation
 * @param {function} [callbackCancel] - type () -> (), called if the user cancels variable creation
 */
CodeManager.newVariable = function(callbackCreate, callbackCancel) {
	DialogManager.showPromptDialog("Create variable", "Enter variable name", "", true, function(cancelled, result) {
		if (!cancelled && CodeManager.checkVarName(result)) {
			result = result.trim();
			const variable = new Variable(result);
			SaveManager.markEdited();
			BlockPalette.getCategory("variables").refreshGroup();
			if (callbackCreate != null) callbackCreate(variable);
		} else {
			if (callbackCancel != null) callbackCancel();
		}
	});
};

/**
 * Checks if the name is a valid name for a new variable
 * @param {string} name
 * @return {boolean} - false if the name is empty or already in use
 */
CodeManager.checkVarName = function(name) {
	name = name.trim();
	if (name.length > 0) {
		const variables = CodeManager.variableList;
		for (let i = 0; i < variables.length; i++) {
			if (variables[i].getName() === name) {
				return false;
			}
		}
		return true;
	}
	return false;
};

/**
 * Finds a variable by name
 * @param {string} name - The name of the variable to find
 * @return {Variable|null} - The variable or null if it can't be found
 */
CodeManager.findVar = function(name) {
	const variables = CodeManager.variableList;
	for (let i = 0; i < variables.length; i++) {
		if (variables[i].getName() === name) {
			return variables[i];
		}
	}
	return null;
};

/**
 * Adds the List to the list of Lists
 * @param {List} list
 */
CodeManager.addList = function(list) {
	CodeManager.listList.push(list);
};

/**
 * Removes the list from the list of Lists
 * @param {List} list
 */
CodeManager.removeList = function(list) {
	const index = CodeManager.listList.indexOf(list);
	CodeManager.listList.splice(index, 1);
};

/**
 * Prompts the user to create a new list
 * @param {function} callbackCreate - type (List) -> (), called if the user completes list creation
 * @param {function} callbackCancel - type () -> (), called if the user cancels list creation
 */
CodeManager.newList = function(callbackCreate, callbackCancel) {
	DialogManager.showPromptDialog("Create list", "Enter list name", "", true, function(cancelled, result) {
		if (!cancelled && CodeManager.checkListName(result)) {
			result = result.trim();
			const list = new List(result);
			SaveManager.markEdited();
			BlockPalette.getCategory("variables").refreshGroup();
			if (callbackCreate != null) callbackCreate(list);
		} else {
			if (callbackCancel != null) callbackCancel();
		}
	});
};

/**
 * Checks if a name is valid for a new List
 * @param {string} name
 * @return {boolean} - false if the name is empty or in use
 */
CodeManager.checkListName = function(name) {
	name = name.trim();
	if (name.length > 0) {
		const lists = CodeManager.listList;
		for (let i = 0; i < lists.length; i++) {
			if (lists[i].getName() === name) {
				return false;
			}
		}
		return true;
	}
	return false;
};

/**
 * Finds a List by name
 * @param {string} name
 * @return {List|null} - The List or null if it can't be found
 */
CodeManager.findList = function(name) {
	const lists = CodeManager.listList;
	for (let i = 0; i < lists.length; i++) {
		if (lists[i].getName() === name) {
			return lists[i];
		}
	}
	return null;
};

/**
 * Tells Blocks that a variable's name has changed
 * @param {Variable} variable
 */
CodeManager.renameVariable = function(variable) {
	TabManager.renameVariable(variable);
	BlockPalette.getCategory("variables").refreshGroup();
	SaveManager.markEdited();
};

/**
 * Tells Blocks that a variable has been deleted
 * @param {Variable} variable
 */
CodeManager.deleteVariable = function(variable) {
	TabManager.deleteVariable(variable);
	BlockPalette.getCategory("variables").refreshGroup();
	SaveManager.markEdited();
};

/**
 * Tells Blocks that a List has been renamed
 * @param {List} list
 */
CodeManager.renameList = function(list) {
	TabManager.renameList(list);
	BlockPalette.getCategory("variables").refreshGroup();
	SaveManager.markEdited();
};

/**
 * Tells Blocks that a List has been deleted
 * @param {List} list
 */
CodeManager.deleteList = function(list) {
	TabManager.deleteList(list);
	BlockPalette.getCategory("variables").refreshGroup();
	SaveManager.markEdited();
};

/**
 * Recursively checks if a variable is ever used. Determines whether a prompt will be shown if the user tries
 * to delete it.
 * @param {Variable} variable
 * @return {boolean}
 */
CodeManager.checkVariableUsed = function(variable) {
	return TabManager.checkVariableUsed(variable);
};

/**
 * Recursively checks if a list is ever used.
 * @param {List} list
 * @return {boolean}
 */
CodeManager.checkListUsed = function(list) {
	return TabManager.checkListUsed(list);
};


/**
 * Recursively tells Blocks that a recording's name has changed
 * @param {string} oldName
 * @param {string} newName
 */
CodeManager.renameRecording = function(oldName, newName) {
	CodeManager.passRecursivelyDown("renameRecording", true, oldName, newName);
	SaveManager.markEdited();
};

/**
 * Recursively tells Blocks that a recording has been deleted
 * @param {string} recording
 */
CodeManager.deleteRecording = function(recording) {
	CodeManager.passRecursivelyDown("deleteRecording", true, recording);
	SaveManager.markEdited();
};


/**
 * Checks if the message is original
 * @param {string} message - The message to test
 * @return {boolean} - false if that message is already a message in CodeManager.broadcastList
 * TODO: Just use a set instead of a list for CodeManager.broadcastList
 */
CodeManager.checkBroadcastMessage = function(message) {
	const messages = CodeManager.broadcastList;
	for (let i = 0; i < messages.length; i++) {
		if (messages[i] === message) {
			return false;
		}
	}
	return true;
};

/**
 * Adds a message to the list of messages if it has not already been added
 * @param {string} message
 */
CodeManager.addBroadcastMessage = function(message) {
	if (CodeManager.checkBroadcastMessage(message)) {
		CodeManager.broadcastList.push(message);
	}
};

/**
 * Recursively tells children to populate the broadcastList
 */
CodeManager.updateAvailableMessages = function() {
	CodeManager.broadcastList = [];
	TabManager.updateAvailableMessages();
};

/**
 * Recursively tells Blocks that a certain message has been broadcast
 * @param {string} message
 */
CodeManager.eventBroadcast = function(message) {
	TabManager.eventBroadcast(message);
};

/**
 * Recursively checks if a certain broadcast message is still running.
 * @param {string} message
 * @return {boolean}
 */
CodeManager.checkBroadcastRunning = function(message) {
	return TabManager.checkBroadcastRunning(message);
};

/**
 * Recursively passes on the message that the flag button was tapped.
 */
CodeManager.eventFlagClicked = function() {
	TabManager.eventFlagClicked();
};


/**
 * Tells DeviceDropSlots or a certain type to hide their drop downs and just use labels
 * @param deviceClass - subclass of Device, type of slots affected
 */
CodeManager.hideDeviceDropDowns = function(deviceClass) {
	CodeManager.passRecursivelyDown("hideDeviceDropDowns", true, deviceClass);
};

/**
 * Tells DeviceDropSlots or a certain type to show their drop downs
 * @param deviceClass - subclass of Device, type of slots affected
 */
CodeManager.showDeviceDropDowns = function(deviceClass) {
	CodeManager.passRecursivelyDown("showDeviceDropDowns", true, deviceClass);
};

/**
 * Recursively funds the largest selected value of any DeviceDropSlot of a certain type
 * @param deviceClass - subclass of Device, type of slots affected
 * @return {number}
 */
CodeManager.countDevicesInUse = function(deviceClass) {
	return TabManager.countDevicesInUse(deviceClass);
};


/**
 * Recursively tells Blocks to become active/inactive based on the sensors that are available
 */
CodeManager.updateAvailableSensors = function() {
	TabManager.passRecursivelyDown("updateAvailableSensors");
	BlockPalette.passRecursivelyDown("updateAvailableSensors");
};

/**
 * Recursively tells Blocks to become active/inactive based on the devices that are connected
 */
CodeManager.updateConnectionStatus = function() {
	CodeManager.passRecursivelyDown("updateConnectionStatus", true);
};


/**
 * Converts beats to milliseconds using the current tempo
 * @param {number} beats
 * @return {number}
 */
CodeManager.beatsToMs = function(beats) {
	const tempo = CodeManager.sound.tempo;
	const res = beats / tempo * 60 * 1000;
	if (isNaN(res) || !isFinite(res)) {
		return 0;
	}
	return res;
};

/**
 * Sets the tempo, if it is valid.
 * @param {number} newTempo
 */
CodeManager.setSoundTempo = function(newTempo) {
	if (isFinite(newTempo) && !isNaN(newTempo)) {
		if (newTempo >= 500) {
			CodeManager.sound.tempo = 500;
		} else if (newTempo <= 20) {
			CodeManager.sound.tempo = 20;
		} else {
			CodeManager.sound.tempo = newTempo;
		}
	}
};


/**
 * Tells children to keep passing message down to Slots/Blocks
 * @param {string} message
 * @param {boolean} includePalette - Whether Blocks in the palette should also get the message
 */
CodeManager.passRecursivelyDown = function(message, includePalette) {
	let args = [message].concat(Array.prototype.splice.call(arguments, 2));
	TabManager.passRecursivelyDown.apply(TabManager, args);
	if (includePalette) {
		BlockPalette.passRecursivelyDown.apply(BlockPalette, args);
	}
};


/**
 * Exports the project to XML
 * @return {Document} - The completed XML document
 */
CodeManager.createXml = function() {
	const CM = CodeManager;
	const xmlDoc = XmlWriter.newDoc("project");
	const project = xmlDoc.getElementsByTagName("project")[0];
	let fileName = "project";
	if (SaveManager.fileName != null) {
		fileName = SaveManager.fileName;
	}
	XmlWriter.setAttribute(project, "name", fileName);
	XmlWriter.setAttribute(project, "appVersion", GuiElements.appVersion);
	XmlWriter.setAttribute(project, "created", CodeManager.createdTime);
	XmlWriter.setAttribute(project, "modified", CodeManager.modifiedTime);
	const variables = XmlWriter.createElement(xmlDoc, "variables");
	for (let i = 0; i < CM.variableList.length; i++) {
		variables.appendChild(CM.variableList[i].createXml(xmlDoc));
	}
	project.appendChild(variables);
	const lists = XmlWriter.createElement(xmlDoc, "lists");
	for (let i = 0; i < CM.listList.length; i++) {
		lists.appendChild(CM.listList[i].createXml(xmlDoc));
	}
	project.appendChild(lists);
	project.appendChild(TabManager.createXml(xmlDoc));
	return xmlDoc;
};

/**
 * Loads the project from XML
 * @param projectNode
 */
CodeManager.importXml = function(projectNode) {
	CodeManager.deleteAll();
	Sound.changeFile();
	CodeManager.modifiedTime = XmlWriter.getAttribute(projectNode, "modified", new Date().getTime(), true);
	CodeManager.createdTime = XmlWriter.getAttribute(projectNode, "created", new Date().getTime(), true);
	const variablesNode = XmlWriter.findSubElement(projectNode, "variables");
	if (variablesNode != null) {
		const variableNodes = XmlWriter.findSubElements(variablesNode, "variable");
		for (let i = 0; i < variableNodes.length; i++) {
			Variable.importXml(variableNodes[i]);
		}
	}
	const listsNode = XmlWriter.findSubElement(projectNode, "lists");
	if (listsNode != null) {
		const listNodes = XmlWriter.findSubElements(listsNode, "list");
		for (let i = 0; i < listNodes.length; i++) {
			List.importXml(listNodes[i]);
		}
	}
	BlockPalette.getCategory("variables").refreshGroup();
	const tabsNode = XmlWriter.findSubElement(projectNode, "tabs");
	TabManager.importXml(tabsNode);
	BlockPalette.refresh();
	DeviceManager.updateSelectableDevices();
	TitleBar.setText(SaveManager.fileName);
	TouchReceiver.enableInteraction();
};

/**
 * Updates the modified time of the document
 */
CodeManager.updateModified = function() {
	CodeManager.modifiedTime = new Date().getTime();
};

/**
 * Deletes all tabs, stacks, and Blocks so a new project can be loaded
 */
CodeManager.deleteAll = function() {
	const CM = CodeManager;
	CM.stop();
	TabManager.deleteAll();
	UndoManager.clearUndos();

	CodeManager();
};

/**
 * Shows "Loading..." in the TitleBar and blocks interaction for 1 sec or until the file loads
 * @param message
 */
CodeManager.markLoading = function(message) {
	TitleBar.setText(message);
	TouchReceiver.disableInteraction(1000);
};

/**
 * Undoes markLoading, by restoring the filename and enabling interaction
 */
CodeManager.cancelLoading = function() {
	TitleBar.setText(SaveManager.fileName);
	TouchReceiver.enableInteraction();
};

/**
 * Indicates that a file is now open.  Called from SaveManager.backendSetName
 */
CodeManager.markOpen = function() {
	TouchReceiver.enableInteraction();
	BlockPalette.markOpen();
};


/* Convert between absolute and relative coords in the drag layer.  Used by moving BlockStacks to determine positions */
/**
 * @param {number} x
 * @return {number}
 */
CodeManager.dragAbsToRelX = function(x) {
	return x / TabManager.getActiveZoom();
};
/**
 * @param {number} y
 * @return {number}
 */
CodeManager.dragAbsToRelY = function(y) {
	return y / TabManager.getActiveZoom();
};
/**
 * @param {number} x
 * @return {number}
 */
CodeManager.dragRelToAbsX = function(x) {
	return x * TabManager.getActiveZoom();
};
/**
 * @param {number} y
 * @return {number}
 */
CodeManager.dragRelToAbsY = function(y) {
	return y * TabManager.getActiveZoom();
};
/**
 * When BirdBlox was created, we initially were going to have tabs on the main canvas for different sprites.
 * All messages to blocks are passed from TabManager > Tab > BlockStack > Block > Slot > etc.
 * We decided not to have tabs, so there's just one tab, which is generated and controlled by the TabManager.
 *
 * The TabManager's main job is passing messages to the active tab
 */
function TabManager() {
	const TM = TabManager;
	TM.tabList = [];
	TM.activeTab = null;
	TM.createInitialTab();
	TabManager.createTabSpaceBg();
	TM.isRunning = false;
	TM.scrolling = false;
	TM.zooming = false;
}

TabManager.setGraphics = function() {
	const TM = TabManager;
	TM.bg = Colors.black;

	TM.minZoom = 0.35;
	TM.maxZoom = 3;

	TM.tabAreaX = BlockPalette.width;
	if (GuiElements.smallMode) {
		TM.tabAreaX = 0;
	}
	TM.tabAreaY = TitleBar.height;
	TM.tabAreaWidth = GuiElements.width - TM.tabAreaXh;

	/* No longer different from tabArea since tab bar was removed */
	TM.tabSpaceX = TM.tabAreaX;
	TM.tabSpaceY = TitleBar.height;
	TM.tabSpaceWidth = GuiElements.width - TM.tabSpaceX;
	TM.tabSpaceHeight = GuiElements.height - TM.tabSpaceY;
	TM.spaceScrollMargin = 50;
	TM.undoDeleteMarginBase = 40;
	TM.undoDeleteMarginRand = 40;
};

/**
 * Creates the rectangle for the canvas
 */
TabManager.createTabSpaceBg = function() {
	const TM = TabManager;
	TM.bgRect = GuiElements.draw.rect(TM.tabSpaceX, TM.tabSpaceY, TM.tabSpaceWidth, TM.tabSpaceHeight, Colors.lightGray);
	TouchReceiver.addListenersTabSpace(TM.bgRect);
	GuiElements.layers.aTabBg.appendChild(TM.bgRect);
};

/**
 * Adds a Tab to the list (called in Tab constructor)
 * @param {Tab} tab
 */
TabManager.addTab = function(tab) {
	TabManager.tabList.push(tab);
};

/**
 * Removes a tab from the list
 * @param {Tab} tab
 */
TabManager.removeTab = function(tab) {
	const index = TabManager.tabList.indexOf(tab);
	TabManager.stackList.splice(index, 1);
};

/**
 * Creates a tab to be the initial Tab
 */
TabManager.createInitialTab = function() {
	const TM = TabManager;
	const t = new Tab();
	TM.activateTab(TM.tabList[0]);
};

/**
 * Sets a tab as the active Tab
 * @param {Tab} tab
 */
TabManager.activateTab = function(tab) {
	tab.activate();
	TabManager.activeTab = tab;
};

/**
 * Tells each Tab to update execution
 * @return {ExecutionStatus} - Whether the tab is currently running
 */
TabManager.updateRun = function() {
	if (!this.isRunning) {
		return new ExecutionStatusDone();
	}
	let rVal = false;
	for (let i = 0; i < TabManager.tabList.length; i++) {
		rVal = TabManager.tabList[i].updateRun().isRunning() || rVal;
	}
	this.isRunning = rVal;
	if (this.isRunning) {
		return new ExecutionStatusRunning();
	} else {
		return new ExecutionStatusDone();
	}
};

/**
 * Stops execution in the tab
 */
TabManager.stop = function() {
	TabManager.passRecursively("stop");
	this.isRunning = false;
};

/**
 * Tells the tab to stop execution everywhere except one stack
 * @param {BlockStack} stack
 */
TabManager.stopAllButStack = function(stack) {
	TabManager.passRecursively("stopAllButStack", stack);
};

/**
 * Passes message up from Tab to start execution
 */
TabManager.startRun = function() {
	TabManager.isRunning = true;
	CodeManager.startUpdateTimer();
};

/* The TabManager tracks information about scrolling before passing messages to the tab.  This way the TouchReceiver
 * can send messages straight to the TabManager instead of trying to find the active Tab */
/**
 * Passes message to Tab
 * @param {number} x
 * @param {number} y
 */
TabManager.startScroll = function(x, y) {
	const TM = TabManager;
	if (!TM.scrolling) {
		TM.scrolling = true;
		TM.activeTab.startScroll(x, y);
	}
};
/**
 * Passes message to Tab
 * @param {number} x
 * @param {number} y
 */
TabManager.updateScroll = function(x, y) {
	const TM = TabManager;
	if (TM.scrolling) {
		TM.activeTab.updateScroll(x, y);
	}
};
/**
 * Passes message to Tab
 */
TabManager.endScroll = function() {
	const TM = TabManager;
	if (TM.scrolling) {
		TM.scrolling = false;
		TM.activeTab.endScroll();
	}
};
/**
 * Passes message to Tab
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 */
TabManager.startZooming = function(x1, y1, x2, y2) {
	const TM = TabManager;
	if (!TM.zooming) {
		TM.zooming = true;
		TM.activeTab.startZooming(x1, y1, x2, y2);
	}
};
/**
 * Passes message to Tab
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 */
TabManager.updateZooming = function(x1, y1, x2, y2) {
	const TM = TabManager;
	if (TM.zooming) {
		TM.activeTab.updateZooming(x1, y1, x2, y2);
	}
};
/**
 * Passes message to Tab
 */
TabManager.endZooming = function() {
	const TM = TabManager;
	if (TM.zooming) {
		TM.zooming = false;
		TM.activeTab.endZooming();
	}
};

/**
 * Tells tab to restore a deleted stack from XML data
 * @param {Node} stackNode - The node to get the data from
 * @return {boolean} - Whether the data was valid
 */
TabManager.undoDelete = function(stackNode) {
	return TabManager.activeTab.undoDelete(stackNode);
};

/**
 * Generates XML for the all the Tabs
 * @param {Document} xmlDoc - The document to write to
 * @return {Node} - The XML node containing the data
 */
TabManager.createXml = function(xmlDoc) {
	const TM = TabManager;
	const tabs = XmlWriter.createElement(xmlDoc, "tabs");
	for (let i = 0; i < TM.tabList.length; i++) {
		tabs.appendChild(TM.tabList[i].createXml(xmlDoc));
	}
	return tabs;
};

/**
 * Imports the Tab data from the XML
 * @param {Node} tabsNode - The XML node containing information about the Tabs
 */
TabManager.importXml = function(tabsNode) {
	const TM = TabManager;
	if (tabsNode != null) {
		const tabNodes = XmlWriter.findSubElements(tabsNode, "tab");
		for (let i = 0; i < tabNodes.length; i++) {
			Tab.importXml(tabNodes[i]);
		}
	}
	if (TM.tabList.length === 0) {
		TM.createInitialTab();
	} else {
		TM.activateTab(TM.tabList[0]);
	}
};

/**
 * Clears and removes all tabs
 */
TabManager.deleteAll = function() {
	const TM = TabManager;
	for (let i = 0; i < TM.tabList.length; i++) {
		TM.tabList[i].delete();
	}
	TM.tabList = [];
	TM.activeTab = null;
	TM.isRunning = false;
	TM.scrolling = false;
};

/* Messages passed directly to tabs */
TabManager.eventFlagClicked = function() {
	TabManager.passRecursively("eventFlagClicked");
};
/**
 * @param {string} message
 */
TabManager.eventBroadcast = function(message) {
	TabManager.passRecursively("eventBroadcast", message);
};
TabManager.updateAvailableMessages = function() {
	TabManager.passRecursively("updateAvailableMessages");
};
/**
 * @param {Variable} variable
 */
TabManager.renameVariable = function(variable) {
	TabManager.passRecursively("renameVariable", variable);
};
/**
 * @param {Variable} variable
 */
TabManager.deleteVariable = function(variable) {
	TabManager.passRecursively("deleteVariable", variable);
};
/**
 * @param {List} list
 */
TabManager.renameList = function(list) {
	TabManager.passRecursively("renameList", list);
};
/**
 * @param {List} list
 */
TabManager.deleteList = function(list) {
	TabManager.passRecursively("deleteList", list);
};

/* Recursive functions that return true if any tab returns true */
/**
 * @param {string} message
 * @return {boolean}
 */
TabManager.checkBroadcastRunning = function(message) {
	if (this.isRunning) {
		for (let i = 0; i < TabManager.tabList.length; i++) {
			if (TabManager.tabList[i].checkBroadcastRunning(message)) {
				return true;
			}
		}
	}
	return false;
};
/**
 * @param {Variable} variable
 * @return {boolean}
 */
TabManager.checkVariableUsed = function(variable) {
	for (let i = 0; i < TabManager.tabList.length; i++) {
		if (TabManager.tabList[i].checkVariableUsed(variable)) {
			return true;
		}
	}
	return false;
};
/**
 * @param {List} list
 * @return {boolean}
 */
TabManager.checkListUsed = function(list) {
	for (let i = 0; i < TabManager.tabList.length; i++) {
		if (TabManager.tabList[i].checkListUsed(list)) {
			return true;
		}
	}
	return false;
};

/**
 * Returns the maximum selected value of all the DeviceDropSlots for a certain type of device
 * @param deviceClass - Subclass of device
 * @return {number}
 */
TabManager.countDevicesInUse = function(deviceClass) {
	let largest = 0;
	for (let i = 0; i < TabManager.tabList.length; i++) {
		largest = Math.max(largest, TabManager.tabList[i].countDevicesInUse(deviceClass));
	}
	return largest;
};

/**
 * Passes a message down to the Blocks/Slots in the TabManager
 * @param {string} message - The message to send.  Probably a function in the target object
 */
TabManager.passRecursivelyDown = function(message) {
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	TabManager.passRecursively.apply(TabManager, arguments);
};

/**
 * Calls the function on all Tabs in this TabManager
 * @param {function} functionName - The name of the function to call
 */
TabManager.passRecursively = function(functionName) {
	const args = Array.prototype.slice.call(arguments, 1);
	for (let i = 0; i < TabManager.tabList.length; i++) {
		const currentList = TabManager.tabList[i];
		currentList[functionName].apply(currentList, args);
	}
};

/**
 * Updates the background rectangle and tells children to update dimensions
 */
TabManager.updateZoom = function() {
	const TM = TabManager;
	TM.setGraphics();
	GuiElements.update.rect(TM.bgRect, TM.tabSpaceX, TM.tabSpaceY, TM.tabSpaceWidth, TM.tabSpaceHeight);
	TabManager.passRecursively("updateZoom");
};

/**
 * Gets the zoom level of the active tab
 * @return {number}
 */
TabManager.getActiveZoom = function() {
	if (TabManager.activeTab == null) {
		return 1;
	}
	return TabManager.activeTab.getZoom();
};
/**
 * When BirdBlox was created, we initially were going to have tabs on the main canvas for different sprites.
 * All messages to blocks are passed from TabManager > Tab > BlockStack > Block > Slot > etc.
 * We decided not to have tabs, so there's just one tab, which is generated by the TabManager when it is created.
 * Tabs pass messages to Blocks and manage the canvas.  They control scrolling/zooming of the canvas and the arrows
 * that indicate off-screen Blocks.
 * @constructor
 */
function Tab() {
	// group for the canvas
	this.mainG = GuiElements.create.group(0, 0);
	// The amount the canvas has been scrolled in each direction
	this.scrollX = 0;
	this.scrollY = 0;
	// The amount the canvas is zoomed
	this.zoomFactor = 1;
	// Whether the tab is visible (always true for the current tab)
	this.visible = false;
	TabManager.addTab(this);
	// List of stacks to pass messages to
	this.stackList = [];
	this.isRunning = false;
	this.scrolling = false;
	this.zooming = false;
	// Used while dragging.  Stores difference between the touch coords and scrollX/scrollY
	this.scrollXOffset = 0;
	this.scrollYOffset = 0;
	// Used while pinch zooming.  Stores the distance between the two fingers initially
	this.zoomStartDist = null;
	// Stores the initial zoomFactor while pinch zooming
	this.startZoom = null;
	// Updates the transformation on the group to reflect the zoom factor and scroll position
	this.updateTransform();
	// Arrows to show off-screen blocks
	this.overFlowArr = new OverflowArrows();
	// Dimension information
	this.dim = {};
	this.dim.x1 = 0;
	this.dim.y1 = 0;
	this.dim.x2 = 0;
	this.dim.y2 = 0;
}

/**
 * Brings the tab to the foreground.  Called by TabManager.
 */
Tab.prototype.activate = function() {
	GuiElements.layers.activeTab.appendChild(this.mainG);
	this.overFlowArr.show();
};

/**
 * Adds a stack to the list.  Called by stack constructor.
 * @param {BlockStack} stack
 */
Tab.prototype.addStack = function(stack) {
	this.stackList.push(stack);
};

/**
 * Removes a stack from the list. Called from BlockSTack.prototype.remove
 * @param {BlockStack} stack
 */
Tab.prototype.removeStack = function(stack) {
	const index = this.stackList.indexOf(stack);
	this.stackList.splice(index, 1);
};

/* Convert between screen coords and coords within the Tab */
/**
 * @param {number} x
 * @return {number}
 */
Tab.prototype.relToAbsX = function(x) {
	return x * this.zoomFactor + this.scrollX;
};
/**
 * @param {number} y
 * @return {number}
 */
Tab.prototype.relToAbsY = function(y) {
	return y * this.zoomFactor + this.scrollY;
};
/**
 * @param {number} x
 * @return {number}
 */
Tab.prototype.absToRelX = function(x) {
	return (x - this.scrollX) / this.zoomFactor;
};
/**
 * @param {number} y
 * @return {number}
 */
Tab.prototype.absToRelY = function(y) {
	return (y - this.scrollY) / this.zoomFactor;
};
/**
 * @return {number}
 */
Tab.prototype.getAbsX = function() {
	return this.relToAbsX(0);
};
/**
 * @return {number}
 */
Tab.prototype.getAbsY = function() {
	return this.relToAbsY(0);
};

/* Recursively passed messages.  Each of these function simply calls the function on the Tab's stacks */
Tab.prototype.findBestFit = function() {
	this.passRecursively("findBestFit");
};
Tab.prototype.eventFlagClicked = function() {
	this.passRecursively("eventFlagClicked");
};
Tab.prototype.eventBroadcast = function(message) {
	this.passRecursively("eventBroadcast", message);
};
Tab.prototype.updateAvailableMessages = function() {
	this.passRecursively("updateAvailableMessages");
};
Tab.prototype.renameVariable = function(variable) {
	this.passRecursively("renameVariable", variable);
};
Tab.prototype.deleteVariable = function(variable) {
	this.passRecursively("deleteVariable", variable);
};
Tab.prototype.renameList = function(list) {
	this.passRecursively("renameList", list);
};
Tab.prototype.deleteList = function(list) {
	this.passRecursively("deleteList", list);
};

/* Recursive functions that return booleans.  These functions call a function on each stack and return true if any
 * stack returns true. */
/**
 * @param {string} message
 * @return {boolean}
 */
Tab.prototype.checkBroadcastRunning = function(message) {
	if (this.isRunning) {
		const stacks = this.stackList;
		for (let i = 0; i < stacks.length; i++) {
			if (stacks[i].checkBroadcastRunning(message)) {
				return true;
			}
		}
	}
	return false;
};
/**
 * @param {Variable} variable
 * @return {boolean}
 */
Tab.prototype.checkVariableUsed = function(variable) {
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		if (stacks[i].checkVariableUsed(variable)) {
			return true;
		}
	}
	return false;
};
/**
 * @param {List} list
 * @return {boolean}
 */
Tab.prototype.checkListUsed = function(list) {
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		if (stacks[i].checkListUsed(list)) {
			return true;
		}
	}
	return false;
};

/**
 * Updates execution of Blocks.  This function performs one execution step on every stack.
 * @returns {ExecutionStatus} - Whether the tab is still running
 */
Tab.prototype.updateRun = function() {
	if (!this.isRunning) {
		return new ExecutionStatusDone();
	}
	const stacks = this.stackList;
	let rVal = false;
	for (let i = 0; i < stacks.length; i++) {
		rVal = stacks[i].updateRun().isRunning() || rVal;
	}
	this.isRunning = rVal;
	if (this.isRunning) {
		return new ExecutionStatusRunning();
	} else {
		return new ExecutionStatusDone();
	}
};

/**
 * Stops execution of all stacks
 */
Tab.prototype.stop = function() {
	this.passRecursively("stop");
	this.isRunning = false;
};

/**
 * Stops execution of all stacks except the specified stack
 * @param stack
 */
Tab.prototype.stopAllButStack = function(stack) {
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		if (stacks[i] !== stack) {
			stacks[i].stop();
		}
	}
};

/**
 * Passes up the message to start running to the TabManager.  Called by a stack when it is tapped.
 */
Tab.prototype.startRun = function() {
	this.isRunning = true;
	TabManager.startRun();
};

/**
 * Stores information necessary to begin scrolling when the user drags their finger on the canvas
 * @param {number} x - The x coord of the touch
 * @param {number} y - The y coord of the touch
 */
Tab.prototype.startScroll = function(x, y) {
	if (!this.scrolling) {
		this.scrolling = true;
		this.scrollXOffset = this.scrollX - x;
		this.scrollYOffset = this.scrollY - y;
		this.updateTabDim();
	}
};

/**
 * Moves the canvas to the correct location, given that the user dragged to the provided coordinate
 * @param {number} x - The x coord of the touch
 * @param {number} y - The y coord of the touch
 */
Tab.prototype.updateScroll = function(x, y) {
	if (this.scrolling) {
		this.scrollX = this.scrollXOffset + x;
		this.scrollY = this.scrollYOffset + y;
		GuiElements.move.group(this.mainG, this.scrollX, this.scrollY, this.zoomFactor);
		this.updateArrowsShift();
	}
};

/**
 * Notes that the canvas is done scrolling
 */
Tab.prototype.endScroll = function() {
	this.scrolling = false;
};

/**
 * Stores data necessary to start zooming when the user has two fingers on the screen
 * @param {number} x1 - The x coord of the first touch
 * @param {number} y1 - The y coord of the first touch
 * @param {number} x2 - The x coord of the second touch
 * @param {number} y2 - The y coord of the second touch
 */
Tab.prototype.startZooming = function(x1, y1, x2, y2) {
	if (!this.zooming) {
		this.zooming = true;
		const x = (x1 + x2) / 2;
		const y = (y1 + y2) / 2;
		this.scrollXOffset = this.scrollX - x;
		this.scrollYOffset = this.scrollY - y;
		const deltaX = x2 - x1;
		const deltaY = y2 - y1;
		this.zoomStartDist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
		this.startZoom = this.zoomFactor;
		this.updateTabDim();
	}
};

/**
 * Moves and zooms the canvas given the positions of the two touches
 * @param {number} x1 - The x coord of the first touch
 * @param {number} y1 - The y coord of the first touch
 * @param {number} x2 - The x coord of the second touch
 * @param {number} y2 - The y coord of the second touch
 */
Tab.prototype.updateZooming = function(x1, y1, x2, y2) {
	if (this.zooming) {
		const x = (x1 + x2) / 2;
		const y = (y1 + y2) / 2;
		const deltaX = x2 - x1;
		const deltaY = y2 - y1;
		const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
		this.zoomFactor = this.startZoom * dist / this.zoomStartDist;
		this.zoomFactor = Math.max(TabManager.minZoom, Math.min(TabManager.maxZoom, this.zoomFactor));
		const zoomRatio = this.zoomFactor / this.startZoom;
		this.scrollX = this.scrollXOffset * zoomRatio + x;
		this.scrollY = this.scrollYOffset * zoomRatio + y;
		this.updateTransform();
		this.updateArrowsShift();
	}
};

/**
 * Notes that the canvas is done zooming
 */
Tab.prototype.endZooming = function() {
	this.zooming = false;
};

/**
 * Updates the transformation on the group according to the scroll position and zoom.
 */
Tab.prototype.updateTransform = function() {
	GuiElements.move.group(this.mainG, this.scrollX, this.scrollY, this.zoomFactor);
	GuiElements.update.zoom(GuiElements.layers.drag, this.zoomFactor);
	GuiElements.update.zoom(GuiElements.layers.highlight, this.zoomFactor);
};

/**
 * Recursively computes the dimensions of the Tab by allowing all stacks to update the bounding box
 */
Tab.prototype.updateTabDim = function() {
	const dim = this.dim;
	dim.width = 0;
	dim.height = 0;
	dim.x1 = null;
	dim.y1 = null;
	dim.x2 = null;
	dim.y2 = null;
	this.passRecursively("updateTabDim");
	if (dim.x1 == null) {
		dim.x1 = 0;
		dim.y1 = 0;
		dim.x2 = 0;
		dim.y2 = 0;
	}
};

/**
 * Writes the contents of the Tab to xml
 * @param {Document} xmlDoc - The XML document to write to
 * @return {Node} - The XML Node for this Tab
 */
Tab.prototype.createXml = function(xmlDoc) {
	const tab = XmlWriter.createElement(xmlDoc, "tab");
	//XmlWriter.setAttribute(tab,"name",this.name);
	XmlWriter.setAttribute(tab, "x", this.scrollX);
	XmlWriter.setAttribute(tab, "y", this.scrollY);
	XmlWriter.setAttribute(tab, "zoom", this.zoomFactor);
	const stacks = XmlWriter.createElement(xmlDoc, "stacks");
	for (let i = 0; i < this.stackList.length; i++) {
		stacks.appendChild(this.stackList[i].createXml(xmlDoc));
	}
	tab.appendChild(stacks);
	return tab;
};

/**
 * Imports the stacks from the provided node into this tab
 * @param {Node} tabNode - The tab node to import from
 * @return {Tab}
 */
Tab.importXml = function(tabNode) {
	const x = XmlWriter.getAttribute(tabNode, "x", 0, true);
	const y = XmlWriter.getAttribute(tabNode, "y", 0, true);
	const zoom = XmlWriter.getAttribute(tabNode, "zoom", 1, true);
	const tab = new Tab();
	tab.scrollX = x;
	tab.scrollY = y;
	tab.zoomFactor = zoom;
	tab.updateTransform();
	const stacksNode = XmlWriter.findSubElement(tabNode, "stacks");
	if (stacksNode != null) {
		const stackNodes = XmlWriter.findSubElements(stacksNode, "stack");
		for (let i = 0; i < stackNodes.length; i++) {
			BlockStack.importXml(stackNodes[i], tab);
		}
	}
	tab.updateArrows();
	return tab;
};

/**
 * Removes the tab
 */
Tab.prototype.delete = function() {
	this.passRecursively("remove");
	this.mainG.remove();
};

/**
 * Creates a stack based on the stackNode provided by the UndoManager in the top left corner
 * @param {Node} stackNode - The XML node for the stack
 * @return {boolean} - Whether the stack was created (false if the XML is invalid)
 */
Tab.prototype.undoDelete = function(stackNode) {
	// The position is randomized slightly to make multiple undos look like a "pile" of blocks, so all are visible
	const xMargin = TabManager.undoDeleteMarginRand * Math.random() + TabManager.undoDeleteMarginBase;
	const yMargin = TabManager.undoDeleteMarginRand * Math.random() + TabManager.undoDeleteMarginBase;

	const x = this.absToRelX(xMargin + BlockPalette.width);
	const y = this.absToRelY(yMargin + TitleBar.height);
	const stack = BlockStack.importXml(stackNode, this);
	if (stack == null) {
		return false;
	}
	stack.move(x, y);
	this.updateArrows();
	return true;
};

/**
 * Returns the maximum selected value of all the DeviceDropSlots for a certain type of device
 * @param deviceClass - Subclass of device
 * @return {number}
 */
Tab.prototype.countDevicesInUse = function(deviceClass) {
	let largest = 0;
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		largest = Math.max(largest, stacks[i].countDevicesInUse(deviceClass));
	}
	return largest;
};

/**
 * Passes a message down to the Blocks/Slots in the tab
 * @param {string} message - The message to send.  Probably a function in the target object
 */
Tab.prototype.passRecursivelyDown = function(message) {
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);
};

/**
 * Calls the function on all Stacks in this tab
 * @param {function} functionName - The name of the function to call
 */
Tab.prototype.passRecursively = function(functionName) {
	const args = Array.prototype.slice.call(arguments, 1);
	const stacks = this.stackList;
	for (let i = 0; i < stacks.length; i++) {
		const currentStack = stacks[i];
		const currentL = stacks.length;
		currentStack[functionName].apply(currentStack, args);
		if (currentL !== stacks.length) {
			i--;
		}
	}
};

/**
 * Retrieves the zoom from the tab
 * @return {number}
 */
Tab.prototype.getZoom = function() {
	return this.zoomFactor;
};

/**
 * Updates the UI for the new zoom level
 */
Tab.prototype.updateZoom = function() {
	this.overFlowArr.updateZoom();
	this.updateArrows();
};

/**
 * Makes the arrows appear/disappear depending on the size/position of the canvas
 */
Tab.prototype.updateArrows = function() {
	this.updateTabDim();
	const x1 = this.relToAbsX(this.dim.x1);
	const y1 = this.relToAbsY(this.dim.y1);
	const x2 = this.relToAbsX(this.dim.x2);
	const y2 = this.relToAbsY(this.dim.y2);
	this.overFlowArr.setArrows(x1, x2, y1, y2);
};

/**
 * Like updateArrows but avoids recomputing the size of the Tab, since it assumes that the canvas has only been zoomed
 * and the Blocks have not changed
 */
Tab.prototype.updateArrowsShift = function() {
	const x1 = this.relToAbsX(this.dim.x1);
	const y1 = this.relToAbsY(this.dim.y1);
	const x2 = this.relToAbsX(this.dim.x2);
	const y2 = this.relToAbsY(this.dim.y2);
	this.overFlowArr.setArrows(x1, x2, y1, y2);
};
/**
 * A static class that manages making recordings
 */
function RecordingManager() {
	let RM = RecordingManager;

	/** @enum {number} */
	RM.recordingStates = {
		stopped: 0,
		recording: 1,
		paused: 2
	};
	RM.state = RM.recordingStates.stopped;
	RM.updateTimer = null;
	RM.updateInterval = 200;
	RM.startTime = null;
	RM.pausedTime = 0;
	RM.awaitingPermission = false;
}

/**
 * Provides UI/Dialogs to rename a recording
 * @param {string} oldFilename - The name of the recording to rename
 * @param {function} nextAction - The function to run if the recording is renamed
 */
RecordingManager.userRenameFile = function(oldFilename, nextAction) {
	SaveManager.userRenameFile(true, oldFilename, nextAction);
};

/**
 * Provides UI/dialogs to delete a recording
 * @param {string} filename - The name of the recording to delete
 * @param {function} nextAction - The function to run if the recording if deleted
 */
RecordingManager.userDeleteFile = function(filename, nextAction) {
	SaveManager.userDeleteFile(true, filename, nextAction);
};

/**
 * Tries to start recording
 */
RecordingManager.startRecording = function() {
	let RM = RecordingManager;
	let request = new HttpRequestBuilder("sound/recording/start");
	HtmlServer.sendRequestWithCallback(request.toString(), function(result) {
		if (result === "Started") {
			// Successfully started recording. Change state
			RM.setState(RM.recordingStates.recording);
			RecordingDialog.startedRecording();
		} else if (result === "Permission denied") {
			let message = "Please grant recording permissions to the BirdBlox app in settings";
			DialogManager.showAlertDialog("Permission denied", message, "Dismiss");
		} else if (result === "Requesting permission") {
			RM.awaitingPermission = true;
		}
	});
};

/**
 * Tell the backend to stop recording
 */
RecordingManager.stopRecording = function() {
	let RM = RecordingManager;
	let request = new HttpRequestBuilder("sound/recording/stop");
	let stopRec = function() {
		RM.setState(RM.recordingStates.stopped);
		RecordingDialog.stoppedRecording();
	};
	HtmlServer.sendRequestWithCallback(request.toString(), stopRec, stopRec);
};

/**
 * Called from backend when there is an unexpected interruption.
 */
RecordingManager.interruptRecording = function() {
	let RM = RecordingManager;
	RM.setState(RM.recordingStates.stopped);
	RecordingDialog.stoppedRecording();
};

/**
 * Tells the backend to pause recording
 */
RecordingManager.pauseRecording = function() {
	let RM = RecordingManager;
	let request = new HttpRequestBuilder("sound/recording/pause");
	let stopRec = function() {
		RM.setState(RM.recordingStates.stopped);
		RecordingDialog.stoppedRecording();
	};
	let pauseRec = function() {
		RM.setState(RM.recordingStates.paused);
		RecordingDialog.pausedRecording();
	};
	HtmlServer.sendRequestWithCallback(request.toString(), pauseRec, stopRec);
};

/**
 * Prompts the user to discard the current recording
 */
RecordingManager.discardRecording = function() {
	let RM = RecordingManager;
	let stopRec = function() {
		RM.setState(RM.recordingStates.stopped);
		RecordingDialog.stoppedRecording();
	};
	let message = "Are you sure you would like to delete the current recording?";
	DialogManager.showChoiceDialog("Delete", message, "Continue recording", "Delete", true, function(result) {
		if (result === "2") {
			let request = new HttpRequestBuilder("sound/recording/discard");
			HtmlServer.sendRequestWithCallback(request.toString(), stopRec, stopRec);
		}
	}, stopRec);
};

/**
 * Tells the backend to resume recording
 */
RecordingManager.resumeRecording = function() {
	let RM = RecordingManager;
	let request = new HttpRequestBuilder("sound/recording/unpause");
	let stopRec = function() {
		RM.setState(RM.recordingStates.stopped);
		RecordingDialog.stoppedRecording();
	};
	let resumeRec = function() {
		RM.setState(RM.recordingStates.recording);
		RecordingDialog.startedRecording();
	};
	HtmlServer.sendRequestWithCallback(request.toString(), resumeRec, stopRec);
};

/**
 * Requests a list of recordings from the backend
 * @param {function} callbackFn - type (Array<Sound>) -> (), called with the list of recordings
 */
RecordingManager.listRecordings = function(callbackFn) {
	Sound.loadSounds(true, callbackFn);
};

/**
 * Changes the state of the RecordingManager and notifies any open Recording Dialogs to update their UI
 * @param state
 */
RecordingManager.setState = function(state) {
	let RM = RecordingManager;
	let prevState = RM.state;
	RM.state = state;
	let states = RM.recordingStates;
	if (state === states.recording) {
		if (RM.updateTimer == null) {
			if (prevState === states.stopped) RM.pausedTime = 0;
			RM.startTime = new Date().getTime();
			RM.updateTimer = self.setInterval(RM.updateCounter, RM.updateInterval);
		}
	} else if (state === states.paused) {
		if (RM.updateTimer != null) {
			RM.updateTimer = window.clearInterval(RM.updateTimer);
			RM.updateTimer = null;
			RM.pausedTime = RM.getElapsedTime();
		}
	} else {
		if (RM.updateTimer != null) {
			RM.updateTimer = window.clearInterval(RM.updateTimer);
			RM.updateTimer = null;
		}
	}
};

/**
 * Updates the elapsed time counters on any open dialogs
 */
RecordingManager.updateCounter = function() {
	let RM = RecordingManager;
	RecordingDialog.updateCounter(RM.getElapsedTime());
};

/**
 * Computes the elapsed time
 * @return {number} - Recording time in milliseconds
 */
RecordingManager.getElapsedTime = function() {
	let RM = RecordingManager;
	return new Date().getTime() - RM.startTime + RM.pausedTime;
};

/**
 * Starts recording if permission is granted and the app was waiting for permission
 */
RecordingManager.permissionGranted = function() {
	let RM = RecordingManager;
	if (RM.awaitingPermission) {
		RM.awaitingPermission = false;
		if (RecordingDialog.currentDialog != null) {
			RM.startRecording();
		}
	}
};
/**
 * Abstract class that controls a dialog with a scrollable region containing a number of rows. Each row normally
 * contains buttons but can also have other types of content. Only one dialog can be visible at any time.
 * The constructor does not draw anything, rather show() must be called.  Calling hide() then show() is used to reload
 * the dialog.  When show() is called, createRow is automatically called to generate each row, which must be implemented
 * by the subclass
 * @param {boolean} autoHeight - Whether the dialog should get taller as number of row increase. Discouraged for
 *                               dialogs that reload frequently
 * @param {string} title - The test to display in the title bar
 * @param {number} rowCount - The number of row to load. Determines how many times createRow is called
 * @param {number} extraTop - The amount of additional space to put between the title bar and the rows (for extra ui)
 * @param {number} extraBottom - The amount of extra space to put below the rows
 * @param {number} [extendTitleBar=0] - The amount the title bar's background should be extended
 * @constructor
 */
function RowDialog(autoHeight, title, rowCount, extraTop, extraBottom, extendTitleBar) {
	if (extendTitleBar == null) {
		extendTitleBar = 0;
	}
	this.autoHeight = autoHeight;
	this.title = title;
	this.rowCount = rowCount;
	this.extraTopSpace = extraTop;
	this.extraBottomSpace = extraBottom;
	this.extendTitleBar = extendTitleBar;
	/* The close/cancel/dismiss buttons at the bottom of the dialog are centeredButtons.  They should be added with
	 * addCenteredButton before show() is called */
	/** @type {Array<object>} - An array of entries including text and callbackFn for each button */
	this.centeredButtons = [];
	/** @type {string} - The text to display if there are no rows. Set using addHintText before show() is called */
	this.hintText = "";
	this.visible = false;
}

RowDialog.setConstants = function() {
	//TODO: This really should be in a separate "setStatics" function, since it isn't a constant
	RowDialog.currentDialog = null;

	RowDialog.titleBarColor = Colors.lightGray;
	RowDialog.titleBarFontC = Colors.white;
	RowDialog.bgColor = Colors.black;
	RowDialog.centeredBnWidth = 100;
	RowDialog.bnHeight = SmoothMenuBnList.bnHeight;
	RowDialog.bnMargin = 5;
	RowDialog.titleBarH = RowDialog.bnHeight + RowDialog.bnMargin;

	// The dialog tries to take up a certain ratio of the smaller of the screen's dimensions
	RowDialog.widthRatio = 0.7;
	RowDialog.heightRatio = 0.75;

	// But if that is too small, it uses the min dimensions
	RowDialog.minWidth = 400;
	RowDialog.minHeight = 400;

	RowDialog.hintMargin = 5;
	RowDialog.titleBarFont = Font.uiFont(16).bold();
	RowDialog.hintTextFont = Font.uiFont(16);
	RowDialog.centeredfontWeight = "bold";
	RowDialog.smallBnWidth = 45;
	RowDialog.iconH = 15;
};

/**
 * Adds information for a centered button to the centeredButtons array. The buttons are built when "show" is called
 * They show up at the bottom of the dialog
 * @param {string} text - The text to show on the button
 * @param {function} callbackFn - The function to call when the button is tapped
 */
RowDialog.prototype.addCenteredButton = function(text, callbackFn) {
	let entry = {};
	entry.text = text;
	entry.callbackFn = callbackFn;
	this.centeredButtons.push(entry);
};

/**
 * Builds all the visuals of the dialog and sets the dialog as currentDialog.  Closes any existing dialogs.
 */
RowDialog.prototype.show = function() {
	if (!this.visible) {
		this.visible = true;
		// Close existing dialog if any
		if (RowDialog.currentDialog != null && RowDialog.currentDialog !== this) {
			RowDialog.currentDialog.closeDialog();
		}
		RowDialog.currentDialog = this;
		this.calcHeights();
		this.calcWidths();
		this.x = GuiElements.width / 2 - this.width / 2;
		this.y = GuiElements.height / 2 - this.height / 2;
		this.group = GuiElements.create.group(this.x, this.y);
		this.bgRect = this.drawBackground();

		this.titleRect = this.createTitleRect();
		this.titleText = this.createTitleLabel(this.title);

		// All the rows go in this group, which is scrollable
		this.rowGroup = this.createContent();
		this.createCenteredBns();
		this.scrollBox = this.createScrollBox(); // could be null
		if (this.scrollBox != null) {
			this.scrollBox.show();
		}

		GuiElements.layers.overlay.appendChild(this.group);

		GuiElements.blockInteraction();
	}
};

/**
 * Computes the height of the dialog and its content.
 */
RowDialog.prototype.calcHeights = function() {
	const RD = RowDialog;
	let centeredBnHeight = (RD.bnHeight + RD.bnMargin) * this.centeredButtons.length + RD.bnMargin;
	let nonScrollHeight = RD.titleBarH + centeredBnHeight + RD.bnMargin;
	nonScrollHeight += this.extraTopSpace + this.extraBottomSpace;
	const shorterDim = Math.min(GuiElements.height, GuiElements.width);
	let minHeight = Math.max(shorterDim * RowDialog.heightRatio, RD.minHeight);
	let ScrollHeight = this.rowCount * (RD.bnMargin + RD.bnHeight) - RD.bnMargin;
	let totalHeight = nonScrollHeight + ScrollHeight;
	if (!this.autoHeight) totalHeight = 0;
	this.height = Math.min(Math.max(minHeight, totalHeight), GuiElements.height);
	this.centeredButtonY = this.height - centeredBnHeight + RD.bnMargin;
	this.innerHeight = ScrollHeight;
	this.scrollBoxHeight = Math.min(this.height - nonScrollHeight, ScrollHeight);
	this.scrollBoxY = RD.bnMargin + RD.titleBarH + this.extraTopSpace;
	this.extraTopY = RD.titleBarH;
	this.extraBottomY = this.height - centeredBnHeight - this.extraBottomSpace + RD.bnMargin;
};

/**
 * Computes the width of the dialog and its content.
 */
RowDialog.prototype.calcWidths = function() {
	const RD = RowDialog;
	const shorterDim = Math.min(GuiElements.height, GuiElements.width);
	this.width = Math.min(GuiElements.width, Math.max(shorterDim * RD.widthRatio, RD.minWidth));
	this.scrollBoxWidth = this.width - 2 * RD.bnMargin;
	this.scrollBoxX = RD.bnMargin;
	this.centeredButtonX = this.width / 2 - RD.centeredBnWidth / 2;
	this.contentWidth = this.width - RD.bnMargin * 2;
};

/**
 * Draws the gray background rectangle of the dialog
 * @return {Element} - The SVG rect element
 */
RowDialog.prototype.drawBackground = function() {
	let rect = GuiElements.draw.rect(0, 0, this.width, this.height, RowDialog.bgColor);
	this.group.appendChild(rect);
	return rect;
};

/**
 * Draws the black rect behind the title bar
 * @return {Element} - The SVG rect element
 */
RowDialog.prototype.createTitleRect = function() {
	const RD = RowDialog;
	const rect = GuiElements.draw.rect(0, 0, this.width, RD.titleBarH + this.extendTitleBar, RD.titleBarColor);
	this.group.appendChild(rect);
	return rect;
};

/**
 * Draws the title text
 * @param {string} title - The text for the title
 * @return {Element} - The SVG text element
 */
RowDialog.prototype.createTitleLabel = function(title) {
	var RD = RowDialog;
	var textE = GuiElements.draw.text(0, 0, title, RD.titleBarFont, RD.titleBarFontC);
	var x = this.width / 2 - GuiElements.measure.textWidth(textE) / 2;
	var y = RD.titleBarH / 2 + RD.titleBarFont.charHeight / 2;
	GuiElements.move.text(textE, x, y);
	this.group.appendChild(textE);
	return textE;
};

/**
 * Creates the rows of the rowDialog and returns the group containing them
 * @return {Element} the SVG group element containing the rows
 */
RowDialog.prototype.createContent = function() {
	const RD = RowDialog;
	let y = 0;
	const rowGroup = GuiElements.create.group(0, 0);
	if (this.rowCount > 0) {
		for (let i = 0; i < this.rowCount; i++) {
			// Determined by subclass
			this.createRow(i, y, this.contentWidth, rowGroup);
			y += RD.bnHeight + RD.bnMargin;
		}
	} else if (this.hintText !== "") {
		this.createHintText();
	}
	return rowGroup;
};

/**
 * Creates the content for the row at this index and adds it to the contentGroup
 * @param {number} index
 * @param {number} y - The y coord relative to the contentGroup
 * @param {number} width - The width the row should be
 * @param {Element} contentGroup - The SVG group element the content should be added to
 */
RowDialog.prototype.createRow = function(index, y, width, contentGroup) {
	DebugOptions.markAbstract();
};

/**
 * Generates the centered buttons and adds them to the group
 */
RowDialog.prototype.createCenteredBns = function() {
	const RD = RowDialog;
	let y = this.centeredButtonY;
	this.centeredButtonEs = [];
	for (let i = 0; i < this.centeredButtons.length; i++) {
		let bn = this.createCenteredBn(y, this.centeredButtons[i]);
		this.centeredButtonEs.push(bn);
		y += RD.bnHeight + RD.bnMargin;
	}
};

/**
 * Creates a centered button for the given entry
 * @param {number} y - Where the button should be placed vertically
 * @param {object} entry - The information for the button with fields for text and callbackFn
 * @return {Button}
 */
RowDialog.prototype.createCenteredBn = function(y, entry) {
	const RD = RowDialog;
	const button = new Button(this.centeredButtonX, y, RD.centeredBnWidth, RD.bnHeight, this.group);
	button.addText(entry.text, null, null, RD.centeredfontWeight);
	button.setCallbackFunction(entry.callbackFn, true);
	return button;
};

/**
 * Creates the SmoothScrollBox for the dialog
 * @return {SmoothScrollBox}
 */
RowDialog.prototype.createScrollBox = function() {
	if (this.rowCount === 0) return null;
	let x = this.x + this.scrollBoxX;
	let y = this.y + this.scrollBoxY;
	return new SmoothScrollBox(this.rowGroup, GuiElements.layers.frontScroll, x, y,
		this.scrollBoxWidth, this.scrollBoxHeight, this.scrollBoxWidth, this.innerHeight);
};

/**
 * Creates the text below the title bar.  Should only be called if hinText !== "" and there are no rows
 */
RowDialog.prototype.createHintText = function() {
	const RD = RowDialog;
	this.hintTextE = GuiElements.draw.text(0, 0, "", RD.hintTextFont, RD.titleBarFontC);
	GuiElements.update.textLimitWidth(this.hintTextE, this.hintText, this.width);
	let textWidth = GuiElements.measure.textWidth(this.hintTextE);
	let x = this.width / 2 - textWidth / 2;
	let y = this.scrollBoxY + RD.hintTextFont.charHeight + RD.hintMargin;
	GuiElements.move.text(this.hintTextE, x, y);
	this.group.appendChild(this.hintTextE);
};

/**
 * Removes the dialog from view and unblocks the ui behind it.  Subclasses to cleanup here.
 */
RowDialog.prototype.closeDialog = function() {
	if (this.visible) {
		this.hide();
		GuiElements.unblockInteraction();
	}
};

/**
 * Gets the amount the user has scrolled the contentGroup
 * @return {number}
 */
RowDialog.prototype.getScroll = function() {
	if (this.scrollBox == null) return 0;
	return this.scrollBox.getScrollY();
};

/**
 * Sets scroll to a certain amount.  Used when content is reloaded
 * @param y
 */
RowDialog.prototype.setScroll = function(y) {
	if (this.scrollBox == null) return;
	this.scrollBox.setScrollY(y);
};

/**
 * Reloads the dialog if the zoom level changes
 */
RowDialog.prototype.updateZoom = function() {
	if (this.visible) {
		let scroll = this.getScroll();
		this.closeDialog();
		this.show();
		this.setScroll(scroll);
	}
};

/**
 * Notifies the open dialog that the zoom level has changed
 */
RowDialog.updateZoom = function() {
	if (RowDialog.currentDialog != null) {
		RowDialog.currentDialog.updateZoom();
	}
};

/**
 * Removes the content of the dialog from view, but does not unblock the UI or preform cleanup
 */
RowDialog.prototype.hide = function() {
	if (this.visible) {
		this.visible = false;
		this.group.remove();
		if (this.scrollBox != null) {
			this.scrollBox.hide();
		}
		this.scrollBox = null;
		if (RowDialog.currentDialog === this) {
			RowDialog.currentDialog = null;
		}
	}
};

/**
 * Rebuild the dialog.  Called when the content of the rows change
 * @param {number} rowCount - The new number of rows
 */
RowDialog.prototype.reloadRows = function(rowCount) {
	this.rowCount = rowCount;
	if (this.visible) {
		let scroll = this.getScroll();
		this.hide();
		this.show();
		this.setScroll(scroll);
	}
};

/**
 * Determines whether the rowDialog is currently scrolling, so subclasses can avoid reloading it while it is moving
 * @return {boolean}
 */
RowDialog.prototype.isScrolling = function() {
	if (this.scrollBox != null) {
		return this.scrollBox.isMoving();
	}
	return false;
};

/**
 * Stores the hint text to display when there is no content.  Should be called before show()
 * @param {string} hintText
 */
RowDialog.prototype.addHintText = function(hintText) {
	this.hintText = hintText;
};

/**
 * Called by subclasses to retrieve extraTopY
 * @return {number} - The amount of space above the content
 */
RowDialog.prototype.getExtraTopY = function() {
	return this.extraTopY;
};

/**
 * Called by subclasses to retrieve extraBottomY
 * @return {number} - The amount of space below the content
 */
RowDialog.prototype.getExtraBottomY = function() {
	return this.extraBottomY;
};

/**
 * Called by subclasses to retrieve the width of the dialog
 * @return {number}
 */
RowDialog.prototype.getContentWidth = function() {
	return this.contentWidth;
};

/**
 * Called by subclasses to retrieve the generated center button
 * @return {Button}
 */
RowDialog.prototype.getCenteredButton = function(i) {
	return this.centeredButtonEs[i];
};

/* Convert between relative and abs coords for items in the contentGroup */
/**
 * @param {number} x
 * @return {number}
 */
RowDialog.prototype.contentRelToAbsX = function(x) {
	if (!this.visible) return x;
	return this.scrollBox.relToAbsX(x);
};
/**
 * @param {number} y
 * @return {number}
 */
RowDialog.prototype.contentRelToAbsY = function(y) {
	if (!this.visible) return y;
	return this.scrollBox.relToAbsY(y);
};

/**
 * Used by subclasses to create a large button for the row that calls a certain function when tapped
 * @param {number} bnWidth
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @param {function} [callbackFn]
 * @return {Button}
 */
RowDialog.createMainBn = function(bnWidth, x, y, contentGroup, callbackFn) {
	const RD = RowDialog;
	const button = new Button(x, y, bnWidth, RD.bnHeight, contentGroup);
	if (callbackFn != null) {
		button.setCallbackFunction(callbackFn, true);
	}
	button.makeScrollable();
	return button;
};

/**
 * Used by subclasses to create a button with text that calls a function
 * @param {string} text
 * @param {number} bnWidth
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @param {function} [callbackFn]
 * @return {Button}
 */
RowDialog.createMainBnWithText = function(text, bnWidth, x, y, contentGroup, callbackFn) {
	const button = RowDialog.createMainBn(bnWidth, x, y, contentGroup, callbackFn);
	button.addText(text);
	return button;
};

/**
 * Used by subclasses to create a small button that calls a function when tapped
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @param {function} callbackFn
 * @return {Button}
 */
RowDialog.createSmallBn = function(x, y, contentGroup, callbackFn) {
	const RD = RowDialog;
	const button = new Button(x, y, RD.smallBnWidth, RD.bnHeight, contentGroup);
	if (callbackFn != null) {
		button.setCallbackFunction(callbackFn, true);
	}
	button.makeScrollable();
	return button;
};

/**
 * Used by subclasses to create a small button with an icon
 * @param {object} pathId - entry of VectorPaths
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @param {function} callbackFn
 * @return {Button}
 */
RowDialog.createSmallBnWithIcon = function(pathId, x, y, contentGroup, callbackFn) {
	let RD = RowDialog;
	let button = RowDialog.createSmallBn(x, y, contentGroup, callbackFn);
	button.addIcon(pathId, RD.iconH);
	return button;
};
/**
 * A dialog for opening and managing local files.  On iOS, a cloud button is included for opening cloud files, and
 * on Android an additional tab opens an OpenCloudDialog for managing cloud files.
 * @param {FileList} fileList - A list of files and account information retrieved from the backend
 * @constructor
 */
function OpenDialog(fileList) {
	const OD = OpenDialog;
	const RD = RowDialog;
	this.fileList = fileList;
	this.files = fileList.localFiles;
	if (GuiElements.isAndroid) {
		// On Android, space is needed for the row of tabs
		RD.call(this, false, "Open", this.files.length, OD.tabRowHeight, OD.extraBottomSpace, OD.tabRowHeight - 1);
	} else {
		RD.call(this, false, "Open", this.files.length, 0, OpenDialog.extraBottomSpace);
	}
	// this.addCenteredButton("Cancel", this.closeDialog.bind(this));
	this.addHintText("No saved programs");
}
OpenDialog.prototype = Object.create(RowDialog.prototype);
OpenDialog.prototype.constructor = OpenDialog;

OpenDialog.setConstants = function() {
	OpenDialog.extraBottomSpace = RowDialog.bnHeight + RowDialog.bnMargin;
	OpenDialog.currentDialog = null; // The currently open dialog, can also be an OpenCloudDialog
	OpenDialog.cloudBnWidth = RowDialog.smallBnWidth * 1.6;
	OpenDialog.tabRowHeight = RowDialog.titleBarH;
};

/**
 * @inheritDoc
 */
OpenDialog.prototype.show = function() {
	RowDialog.prototype.show.call(this);
	OpenDialog.currentDialog = this;
	this.createNewBn();
	if (GuiElements.isIos) {
		this.createCloudBn();
	}
	if (GuiElements.isAndroid) {
		this.createTabRow();
	}
};

/**
 * @inheritDoc
 * @param {number} index
 * @param {number} y
 * @param {number} width
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createRow = function(index, y, width, contentGroup) {
	const cols = 3;
	const RD = RowDialog;
	let largeBnWidth = width - RD.smallBnWidth * cols - RD.bnMargin * cols;
	const file = this.files[index];
	this.createFileBn(file, largeBnWidth, 0, y, contentGroup);

	let currentX = largeBnWidth + RD.bnMargin;
	this.createRenameBn(file, currentX, y, contentGroup);
	currentX += RD.bnMargin + RD.smallBnWidth;
	//this.createDuplicateBn(file, currentX, y, contentGroup);
	if (this.fileList.signedIn) {
		// If signed in, the export button is replaced with an upload button (the export button goes in the more menu)
		this.createUploadBn(file, currentX, y, contentGroup);
	} else {
		this.createExportBn(file, currentX, y, contentGroup);
	}
	currentX += RD.bnMargin + RD.smallBnWidth;
	this.createMoreBn(file, currentX, y, contentGroup);
};

/**
 * Creates the button which shows the file name and opens the file when tapped
 * @param {string} file - The name of the file
 * @param {number} bnWidth
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createFileBn = function(file, bnWidth, x, y, contentGroup) {
	RowDialog.createMainBnWithText(file, bnWidth, x, y, contentGroup, function() {
		this.closeDialog();
		SaveManager.userOpenFile(file);
	}.bind(this));
};

/**
 * Creates the button for deleting files.  This button has been moved into the more menu, so this function is not used
 * anymore.
 * @param {string} file - The name of the file to delete
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createDeleteBn = function(file, x, y, contentGroup) {
	const me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.trash, x, y, contentGroup, function() {
		SaveManager.userDeleteFile(false, file, function() {
			me.reloadDialog();
		});
	});
};

/**
 * Creates the button for renaming files
 * @param {string} file - The name of the file to delete
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createRenameBn = function(file, x, y, contentGroup) {
	const me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.edit, x, y, contentGroup, function() {
		SaveManager.userRenameFile(false, file, function() {
			me.reloadDialog();
		});
	});
};

/**
 * Creates a button for duplicating files
 * @param {string} file - The name of the file to delete
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createDuplicateBn = function(file, x, y, contentGroup) {
	const me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.copy, x, y, contentGroup, function() {
		SaveManager.userDuplicateFile(file, function() {
			me.reloadDialog();
		});
	});
};

/**
 * Creates a button for exporting files
 * @param {string} file - The name of the file to delete
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createExportBn = function(file, x, y, contentGroup) {
	const me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.share, x, y, contentGroup, function() {
		let x1 = this.contentRelToAbsX(x);
		let x2 = this.contentRelToAbsX(x + RowDialog.smallBnWidth);
		let y1 = this.contentRelToAbsY(y);
		let y2 = this.contentRelToAbsY(y + RowDialog.bnHeight);
		x1 = GuiElements.relToAbsX(x1);
		x2 = GuiElements.relToAbsX(x2);
		y1 = GuiElements.relToAbsX(y1);
		y2 = GuiElements.relToAbsX(y2);
		SaveManager.userExportFile(file, x1, x2, y1, y2);
	}.bind(this));
};

/**
 * Creates a button for uploading files.  Only available on Android
 * @param {string} file - The name of the file to delete
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createUploadBn = function(file, x, y, contentGroup) {
	const me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.cloudUpload, x, y, contentGroup, function() {
		const request = new HttpRequestBuilder("cloud/upload");
		request.addParam("filename", file);
		HtmlServer.sendRequestWithCallback(request.toString());
	});
};

/**
 * Creates a button for more actions, which are listed in a dropdown
 * @param {string} file - The name of the file to delete
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenDialog.prototype.createMoreBn = function(file, x, y, contentGroup) {
	RowDialog.createSmallBnWithIcon(VectorPaths.dots, x, y, contentGroup, function() {
		const x1 = this.contentRelToAbsX(x);
		const x2 = this.contentRelToAbsX(x + RowDialog.smallBnWidth);
		const y1 = this.contentRelToAbsY(y);
		const y2 = this.contentRelToAbsY(y + RowDialog.bnHeight);
		let type = FileContextMenu.types.localSignedOut;
		if (this.fileList.signedIn) {
			type = FileContextMenu.types.localSignedIn;
		}
		new FileContextMenu(this, file, type, x1, x2, y1, y2);
	}.bind(this));
};

/**
 * Creates a button at the bottom of the dialog for opening a blank, new file.
 * @return {Button}
 */
OpenDialog.prototype.createNewBn = function() {
	let RD = RowDialog;
	let OD = OpenDialog;
	let x = RD.bnMargin;
	let y = this.getExtraBottomY();
	let button = new Button(x, y, this.getContentWidth(), RD.bnHeight, this.group);
	button.addText("New");
	button.setCallbackFunction(function() {
		SaveManager.userNew(this.closeDialog.bind(this))
	}.bind(this), true);
	return button;
};

/**
 * Re-retrieves the list of open files from the backend and reloads the dialog
 */
OpenDialog.prototype.reloadDialog = function() {
	let thisScroll = this.getScroll();
	let me = this;
	HtmlServer.sendRequestWithCallback("data/files", function(response) {
		if (OpenDialog.currentDialog === me) {
			me.closeDialog();
			const openDialog = new OpenDialog(new FileList(response));
			openDialog.show();
			openDialog.setScroll(thisScroll);
		}
	});
};

/**
 * Creates a button in the top-right corner of the dialog for opening from cloud storage (iOS only)
 */
OpenDialog.prototype.createCloudBn = function() {
	const OD = OpenDialog;
	const RD = RowDialog;
	const x = this.width - RD.bnMargin - OD.cloudBnWidth;
	let button = new Button(x, RD.bnMargin, OD.cloudBnWidth, RD.titleBarH - 2 * RD.bnMargin, this.group);
	button.addIcon(VectorPaths.cloud);
	button.setCallbackFunction(function() {
		HtmlServer.sendRequestWithCallback("cloud/showPicker");
	}, true);
};

/**
 * Creates tabs for opening the the OpenCloudDialog (Android only)
 * @return {TabRow}
 */
OpenDialog.prototype.createTabRow = function() {
	const OD = OpenDialog;
	let y = this.getExtraTopY();
	let tabRow = new TabRow(0, y, this.width, OD.tabRowHeight, this.group, 0);

	tabRow.addTab("On Device", "device");
	tabRow.addTab(this.fileList.getCloudTitle(), "cloud");

	tabRow.setCallbackFunction(this.tabSelected.bind(this));
	tabRow.show();
	return tabRow;
};

/**
 * Switches to the OpenCloudDialog if its tab is selected
 * @param {string} tab - The id of the selected tab
 */
OpenDialog.prototype.tabSelected = function(tab) {
	if (tab === "cloud") {
		const cloudDialog = new OpenCloudDialog(this.fileList);
		this.hide();
		cloudDialog.show();
	}
};

/**
 * Retrieves a list of local files and cloud account information (on Android) and shows an Open dialog
 */
OpenDialog.showDialog = function() {
	OpenDialog.opening = true; // Allows the action to be canceled if OpenDialog.closeDialog is called in the interval
	HtmlServer.sendRequestWithCallback("data/files", function(response) {
		if (!OpenDialog.opening) return;
		const openDialog = new OpenDialog(new FileList(response));
		openDialog.show();
		OpenDialog.opening = false;
	}, function() {
		OpenDialog.opening = false;
	});
};

OpenDialog.closeFileAndShowDialog = function() {
	SaveManager.userClose(OpenDialog.showDialog);
};

/**
 * @inheritDoc
 */
OpenDialog.prototype.closeDialog = function() {
	OpenDialog.currentDialog = null;
	RowDialog.prototype.closeDialog.call(this);
};

/**
 * Closes the currently open dialog
 */
OpenDialog.closeDialog = function() {
	OpenDialog.opening = false;
	if (OpenDialog.currentDialog != null) {
		OpenDialog.currentDialog.closeDialog();
	}
};

/**
 * Reloads the currently open dialog, if that dialog is an OpenDialog
 */
OpenDialog.filesChanged = function() {
	if (OpenDialog.currentDialog != null && OpenDialog.currentDialog.constructor === OpenDialog) {
		OpenDialog.currentDialog.reloadDialog();
	}
};
/**
 * A dialog for managing cloud files on Android.  Contains a tab for returning to the OpenDialog
 * @param {FileList} fileList - Used to obtain account information
 * @param {Array<string>} [cloudFileList] - An array of files on the cloud, or null if they haven't been loaded yet
 * @param {string} [error] - The error that occurred while loading files (if present)
 * @constructor
 */
function OpenCloudDialog(fileList, cloudFileList, error) {
	const OD = OpenDialog;
	const RD = RowDialog;
	this.fileList = fileList;
	// We need to load the files if the user is signed in and the files aren't loaded and there isn't an error
	this.loading = cloudFileList == null && this.fileList.signedIn && error == null;
	// There's only one row for the sign in button if there are no files
	let count = 1;
	// There isn't any hint text unless we are signed in
	let hintText = "";

	if (this.fileList.signedIn) {
		if (error != null) {
			// An error occurred, display the error
			hintText = error;
		} else if (this.loading) {
			hintText = "Loading...";
		} else {
			hintText = "No saved programs"
		}
		this.files = cloudFileList;
		if (this.files == null) {
			this.files = [];
		}
		count = this.files.length;
	}

	RD.call(this, false, "Open", count, OD.tabRowHeight, 0, OD.tabRowHeight - 1);
	// this.addCenteredButton("Cancel", this.closeDialog.bind(this));
	this.addHintText(hintText);

	// Load the files from the backend
	if (this.loading) {
		this.loadFiles();
	}
}
OpenCloudDialog.prototype = Object.create(RowDialog.prototype);
OpenCloudDialog.prototype.constructor = OpenCloudDialog;

/**
 * @inheritDoc
 */
OpenCloudDialog.prototype.show = function() {
	RowDialog.prototype.show.call(this);
	OpenDialog.currentDialog = this;
	this.createTabRow();
};

/**
 * Creates a row for managing the files, or just a sign in button if we aren't signed in
 * @inheritDoc
 * @param {number} index
 * @param {number} y
 * @param {number} width
 * @param {Element} contentGroup
 */
OpenCloudDialog.prototype.createRow = function(index, y, width, contentGroup) {
	const RD = RowDialog;
	if (this.fileList.signedIn) {
		const cols = 2;
		const file = this.files[index];

		const largeBnWidth = width - RD.smallBnWidth * cols - RD.bnMargin * cols;
		this.createFileBn(file, largeBnWidth, 0, y, contentGroup);

		let currentX = largeBnWidth + RD.bnMargin;
		this.createRenameBn(file, currentX, y, contentGroup);
		currentX += RD.bnMargin + RD.smallBnWidth;
		this.createMoreBn(file, currentX, y, contentGroup);

	} else {
		this.createSignInBn(width, 0, y, contentGroup);
	}
};

/**
 * Creates a button for downloading a file
 * @param {string} file - The name of the file
 * @param {number} bnWidth
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenCloudDialog.prototype.createFileBn = function(file, bnWidth, x, y, contentGroup) {
	const button = RowDialog.createMainBn(bnWidth, x, y, contentGroup, function() {
		const request = new HttpRequestBuilder("cloud/download");
		request.addParam("filename", file);
		HtmlServer.sendRequestWithCallback(request.toString());
	}.bind(this));
	button.addSideTextAndIcon(VectorPaths.cloudDownload, null, file);
};

/**
 * Creates a sign in button
 * @param {number} bnWidth
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenCloudDialog.prototype.createSignInBn = function(bnWidth, x, y, contentGroup) {
	const button = RowDialog.createMainBn(bnWidth, x, y, contentGroup, function() {
		HtmlServer.sendRequestWithCallback("cloud/signIn");
	}.bind(this));
	button.addText("Sign in");
};

/**
 * Creates a button for renaming a file
 * @param {string} file - The name of the file
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenCloudDialog.prototype.createRenameBn = function(file, x, y, contentGroup) {
	const me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.edit, x, y, contentGroup, function() {
		const request = new HttpRequestBuilder("cloud/rename");
		request.addParam("filename", file);
		HtmlServer.sendRequestWithCallback(request.toString());
	});
};

/**
 * Creates a button for displaying additional options
 * @param {string} file - The name of the file
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
OpenCloudDialog.prototype.createMoreBn = function(file, x, y, contentGroup) {
	RowDialog.createSmallBnWithIcon(VectorPaths.dots, x, y, contentGroup, function() {
		// Get the coords to show the menu at
		const x1 = this.contentRelToAbsX(x);
		const x2 = this.contentRelToAbsX(x + RowDialog.smallBnWidth);
		const y1 = this.contentRelToAbsY(y);
		const y2 = this.contentRelToAbsY(y + RowDialog.bnHeight);
		// Show the more options menu
		new FileContextMenu(this, file, FileContextMenu.types.cloud, x1, x2, y1, y2);
	}.bind(this));
};

/**
 * Creates a tab to return to the OpenDialog
 * @return {TabRow}
 */
OpenCloudDialog.prototype.createTabRow = function() {
	const OD = OpenDialog;
	let y = this.getExtraTopY();
	let tabRow = new TabRow(0, y, this.width, OD.tabRowHeight, this.group, 1);

	tabRow.addTab("On Device", "device");
	let signOutFn = null;
	// If signed in, an X appears in the tab which signs the user out
	if (this.fileList.signedIn) {
		signOutFn = this.userSignOut.bind(this);
	}
	tabRow.addTab(this.fileList.getCloudTitle(), "cloud", signOutFn);

	tabRow.setCallbackFunction(this.tabSelected.bind(this));
	tabRow.show();
	return tabRow;
};

/**
 * Switches back to the OpenDialog if the user selects that tab
 * @param {string} tab - The id of the selected tab
 */
OpenCloudDialog.prototype.tabSelected = function(tab) {
	if (tab === "device") {
		const openDialog = new OpenDialog(this.fileList);
		this.hide();
		openDialog.show();
		openDialog.reloadDialog();
	}
};

/**
 * @inheritDoc
 */
OpenCloudDialog.prototype.closeDialog = function() {
	OpenDialog.currentDialog = null;
	RowDialog.prototype.closeDialog.call(this);
};

/**
 * Re-retrieves the local files and shows an OpenDialog
 */
OpenCloudDialog.prototype.reloadToOpen = function() {
	const me = this;
	HtmlServer.sendRequestWithCallback("data/files", function(response) {
		if (OpenDialog.currentDialog === me) {
			me.closeDialog();
			const openDialog = new OpenDialog(new FileList(response));
			openDialog.show();
		}
	});
};

/**
 * Reloads the OpenCloudDialog with the specified cloud files.  Re-retrieves local files and account info
 * @param {Array<string>} [cloudFileList] - The list of cloud files.  If  undefined, redownloads
 */
OpenCloudDialog.prototype.reloadDialog = function(cloudFileList) {
	if (cloudFileList == null) {
		cloudFileList = null;
	}

	let thisScroll = this.getScroll();
	let me = this;
	HtmlServer.sendRequestWithCallback("data/files", function(response) {
		if (OpenDialog.currentDialog === me) {
			me.closeDialog();
			const openDialog = new OpenCloudDialog(new FileList(response), cloudFileList);
			openDialog.show();
			openDialog.setScroll(thisScroll);
		}
	});
};

/**
 * Confirms the user's intent to sign out and then signs out
 */
OpenCloudDialog.prototype.userSignOut = function() {
	DebugOptions.assert(this.fileList.account != null);
	let message = "Disconnect account " + this.fileList.account + "?\n";
	message += "Downloaded files will remain on this device.";
	const me = this;
	DialogManager.showChoiceDialog("Disconnect account", message, "Don't disconnect", "disconnect", true, function(result) {
		if (result === "2") {
			me.signOut();
		}
	});
};

/**
 * Issues a signOut request and reloads the dialog
 */
OpenCloudDialog.prototype.signOut = function() {
	const me = this;
	HtmlServer.sendRequestWithCallback("cloud/signOut", function() {
		me.reloadDialog();
	});
};

/**
 * Requests the list of cloud files and creates a new OpenCloudDialog with them, or shows an error
 */
OpenCloudDialog.prototype.loadFiles = function() {
	const me = this;
	HtmlServer.sendRequestWithCallback("cloud/list", function(response) {
		if (OpenDialog.currentDialog === me) {
			const object = JSON.parse(response);
			let files = object.files;
			if (files != null) {
				me.closeDialog();
				const cloudDialog = new OpenCloudDialog(me.fileList, files);
				cloudDialog.show();
			}
		}
	}, function(status, error) {
		if (OpenDialog.currentDialog === me) {
			me.closeDialog();
			const cloudDialog = new OpenCloudDialog(me.fileList, null, error);
			cloudDialog.show();
		}
	});
};

/**
 * Parses the list of cloud files and reloads the OpenCloudDialog with them
 * @param {string} [jsonString] - List of new cloud files as a JSON array of strings encoded as a string
 */
OpenCloudDialog.filesChanged = function(jsonString) {
	if (OpenDialog.currentDialog != null && OpenDialog.currentDialog.constructor === OpenCloudDialog) {
		if (jsonString != null) {
			jsonString = JSON.parse(jsonString).files;
		}
		OpenDialog.currentDialog.reloadDialog(jsonString);
	}
};
/**
 * Holds all the data necessary to show an OpenDialog, which includes a list of local files and the cloud account the
 * user is signed into (if any}.  A list of cloud files is downloaded later.
 * @param {string} jsonString - String representation of object containing the above information
 * @constructor
 */
function FileList(jsonString) {
	const object = JSON.parse(jsonString);
	this.localFiles = object.files;
	if (this.localFiles == null) {
		this.localFiles = []
	}
	this.signedIn = object.signedIn === true;
	if (!GuiElements.isAndroid) {
		// We only show this information on Android
		this.signedIn = false;
	}
	this.account = object.account;
	if (this.account == null || !this.signedIn) {
		this.account = null;
	}
}

/**
 * Gets the string to show in the Cloud tab.  Only relevant on Android.
 * @return {string}
 */
FileList.prototype.getCloudTitle = function(){
	if (this.account != null) {
		return this.account;
	}
	return "Cloud";
};
/**
 * A tabbed dialog for connecting multiple devices.  Each type of device has a tab in which devices can be reordered,
 * added, and removed.  A status light for each device indicates if it is connected and an info button shows
 * whether the firmware is up to date
 * @param deviceClass - A subclass of Device, the tab that should be open to start
 * @constructor
 */
function ConnectMultipleDialog(deviceClass) {
	let CMD = ConnectMultipleDialog;
	// Store the open tab so it can be reopened by default next time
	CMD.lastClass = deviceClass;
	let title = "Connect Multiple";
	this.deviceClass = deviceClass;
	let count = deviceClass.getManager().getDeviceCount();
	RowDialog.call(this, false, title, count, CMD.tabRowHeight, CMD.extraBottomSpace, CMD.tabRowHeight - 1);
	this.addCenteredButton("Done", this.closeDialog.bind(this));
	this.addHintText("Tap \"+\" to connect");
}
ConnectMultipleDialog.prototype = Object.create(RowDialog.prototype);
ConnectMultipleDialog.prototype.constructor = ConnectMultipleDialog;

ConnectMultipleDialog.setConstants = function() {
	let CMD = ConnectMultipleDialog;
	CMD.currentDialog = null;

	CMD.extraBottomSpace = RowDialog.bnHeight + RowDialog.bnMargin;
	CMD.tabRowHeight = RowDialog.titleBarH;
	CMD.numberWidth = 35;
	CMD.plusFont = Font.uiFont(26);

	CMD.numberFont = Font.uiFont(16);
	CMD.numberColor = Colors.white;
};

/**
 * Creates the status light, main button, info button, and remove button
 * @inheritDoc
 * @param {number} index
 * @param {number} y
 * @param {number} width
 * @param {Element} contentGroup
 */
ConnectMultipleDialog.prototype.createRow = function(index, y, width, contentGroup) {
	let CMD = ConnectMultipleDialog;
	let statusX = 0;
	let numberX = statusX + DeviceStatusLight.radius * 2;
	let mainBnX = numberX + CMD.numberWidth;
	let mainBnWidth = width - (RowDialog.smallBnWidth + RowDialog.bnMargin) * 2 - mainBnX;
	let infoBnX = mainBnX + RowDialog.bnMargin + mainBnWidth;
	let removeBnX = infoBnX + RowDialog.bnMargin + RowDialog.smallBnWidth;

	let robot = this.deviceClass.getManager().getDevice(index);
	this.createStatusLight(robot, statusX, y, contentGroup);
	this.createNumberText(index, numberX, y, contentGroup);
	this.createMainBn(robot, index, mainBnWidth, mainBnX, y, contentGroup);
	this.createInfoBn(robot, index, infoBnX, y, contentGroup);
	this.createRemoveBn(robot, index, removeBnX, y, contentGroup);
};

/**
 * Creates a light to indicate the status of the provided robot
 * @param {Device} robot
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @return {DeviceStatusLight}
 */
ConnectMultipleDialog.prototype.createStatusLight = function(robot, x, y, contentGroup) {
	return new DeviceStatusLight(x, y + RowDialog.bnHeight / 2, contentGroup, robot);
};

/**
 * Creates a number for the row.  Since the blocks control a Device with a certain number, is is important for the
 * user to know when device is, say, Hummingbird 3
 * @param {number} index
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
ConnectMultipleDialog.prototype.createNumberText = function(index, x, y, contentGroup) {
	let CMD = ConnectMultipleDialog;
	let textE = GuiElements.draw.text(0, 0, (index + 1) + "", CMD.numberFont, CMD.numberColor);
	let textW = GuiElements.measure.textWidth(textE);
	let textX = x + (CMD.numberWidth - textW) / 2;
	let textY = y + (RowDialog.bnHeight + CMD.numberFont.charHeight) / 2;
	GuiElements.move.text(textE, textX, textY);
	contentGroup.appendChild(textE);
	return textE;
};

/**
 * Creates a button which shows which robot is connected in that position of the list. Tapping the button allows the
 * robot to be replaced with a different robot
 *
 * @param {Device} robot - The robot currently in this location
 * @param {number} index
 * @param {number} bnWidth
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @return {Button}
 */
ConnectMultipleDialog.prototype.createMainBn = function(robot, index, bnWidth, x, y, contentGroup) {
	let connectionX = this.x + this.width / 2;
	return RowDialog.createMainBnWithText(robot.name, bnWidth, x, y, contentGroup, function() {
		let upperY = this.contentRelToAbsY(y);
		let lowerY = this.contentRelToAbsY(y + RowDialog.bnHeight);
		// When tapped, a list of robots to connect from appears
		(new RobotConnectionList(connectionX, upperY, lowerY, index, this.deviceClass)).show();
	}.bind(this));
};

/**
 * Creates the button for removing a robot from the list
 * @param {Device} robot
 * @param {number} index
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @return {Button}
 */
ConnectMultipleDialog.prototype.createRemoveBn = function(robot, index, x, y, contentGroup) {
	let button = RowDialog.createSmallBn(x, y, contentGroup);
	button.addText("X");
	button.setCallbackFunction(function() {
		this.deviceClass.getManager().removeDevice(index);
	}.bind(this), true);
	return button;
};

/**
 * Creates a button which shows info about the device's firmware
 * @param {Device} robot
 * @param {number} index
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 * @return {Button}
 */
ConnectMultipleDialog.prototype.createInfoBn = function(robot, index, x, y, contentGroup) {
	let button = RowDialog.createSmallBn(x, y, contentGroup, robot.showFirmwareInfo.bind(robot));

	// The appearance of the button changes depending on the firmwareStatus
	const statuses = Device.firmwareStatuses;
	function updateStatus(firmwareStatus) {
		if (firmwareStatus === statuses.old) {
			button.addColorIcon(VectorPaths.warning, RowDialog.iconH, DeviceStatusLight.yellowColor);
		} else if (firmwareStatus === statuses.incompatible) {
			button.addColorIcon(VectorPaths.warning, RowDialog.iconH, DeviceStatusLight.redColor);
		} else {
			button.addIcon(VectorPaths.info, RowDialog.iconH);
		}
	}
	updateStatus(robot.getFirmwareStatus());
	robot.setFirmwareStatusListener(updateStatus);

	return button;
};

/**
 * Creates the dialog and starts a scan for the current device type
 * @inheritDoc
 */
ConnectMultipleDialog.prototype.show = function() {
	let CMD = ConnectMultipleDialog;
	RowDialog.prototype.show.call(this);
	CMD.currentDialog = this;
	this.createConnectBn();
	this.createTabRow();
	this.deviceClass.getManager().startDiscover(function() {
		return this.visible;
	}.bind(this));
};

/**
 * Creates a "+" button for connecting to another robot
 * @return {Button}
 */
ConnectMultipleDialog.prototype.createConnectBn = function() {
	let CMD = ConnectMultipleDialog;
	let bnWidth = this.getContentWidth() - RowDialog.smallBnWidth - DeviceStatusLight.radius * 2 - CMD.numberWidth;
	let x = (this.width - bnWidth) / 2;
	// Gets the location to add the button
	let y = this.getExtraBottomY();
	let button = new Button(x, y, bnWidth, RowDialog.bnHeight, this.group);
	button.addText("+", CMD.plusFont);
	let upperY = y + this.y;
	let lowerY = upperY + RowDialog.bnHeight;
	let connectionX = this.x + this.width / 2;
	button.setCallbackFunction(function() {
		// Shows a list of devices to connect
		(new RobotConnectionList(connectionX, upperY, lowerY, null, this.deviceClass)).show();
	}.bind(this), true);
	const manager = this.deviceClass.getManager();
	if (manager.getDeviceCount() >= DeviceManager.maxDevices) {
		button.disable();
	}
	return button;
};

/**
 * Creates a row of tabs for each device type, which when selected, reload the dialog for that tab
 * @return {TabRow}
 */
ConnectMultipleDialog.prototype.createTabRow = function() {
	let CMD = ConnectMultipleDialog;
	let selectedIndex = Device.getTypeList().indexOf(this.deviceClass);
	let y = this.getExtraTopY();
	let tabRow = new TabRow(0, y, this.width, CMD.tabRowHeight, this.group, selectedIndex);
	Device.getTypeList().forEach(function(deviceClass) {
		tabRow.addTab(deviceClass.getDeviceTypeName(false), deviceClass);
	});
	// When a tab is selected, reloadDialog will be called with the class of the device type
	tabRow.setCallbackFunction(this.reloadDialog.bind(this));
	tabRow.show();
	return tabRow;
};

/**
 * Reloads the dialog with the provided device type's tab open, or the last selected type if none is provided
 * @param [deviceClass] - subclass of Device
 */
ConnectMultipleDialog.prototype.reloadDialog = function(deviceClass) {
	if (deviceClass == null) {
		deviceClass = this.deviceClass;
	}
	if (deviceClass !== this.deviceClass) {
		// Stop discovery before switching tabs
		this.deviceClass.getManager().stopDiscover();
	}
	let thisScroll = this.getScroll();
	let me = this;
	me.hide();
	let dialog = new ConnectMultipleDialog(deviceClass);
	dialog.show();
	if (deviceClass === this.deviceClass) {
		dialog.setScroll(thisScroll);
	}
};

/**
 * Closes the dialog and stops discovery
 * @inheritDoc
 */
ConnectMultipleDialog.prototype.closeDialog = function() {
	let CMD = ConnectMultipleDialog;
	RowDialog.prototype.closeDialog.call(this);
	CMD.currentDialog = null;
	this.deviceClass.getManager().stopDiscover();
};

/**
 * Reloads the currently open dialog
 */
ConnectMultipleDialog.reloadDialog = function() {
	let CMD = ConnectMultipleDialog;
	if (CMD.currentDialog != null) {
		CMD.currentDialog.reloadDialog();
	}
};

/**
 * Creates and shows a ConnectMultipleDialog with the default tab open
 */
ConnectMultipleDialog.showDialog = function() {
	let CMD = ConnectMultipleDialog;
	if (CMD.lastClass == null) {
		CMD.lastClass = Device.getTypeList()[0];
	}
	(new ConnectMultipleDialog(CMD.lastClass)).show();
};
/**
 * A dialog for creating and managing recordings.  RecordingDialogs interact with the RecordingManager for making
 * recordings, the Sound class for playing recordings, and SaveManager for renaming and deleting recordings
 * @param {Array<Sound>} listOfRecordings - The list of recordings for the open file
 * @constructor
 */
function RecordingDialog(listOfRecordings) {
	const RecD = RecordingDialog;
	// Create an array of ids
	this.recordings = listOfRecordings.map(function(x) {
		return x.id;
	});
	// Extra space at the bottom is needed for the recording controls
	RowDialog.call(this, true, "Recordings", this.recordings.length, 0, RecordingDialog.extraBottomSpace);
	this.addCenteredButton("Done", this.closeDialog.bind(this));
	this.addHintText("Tap record to start");
	/** @type {RecordingManager.recordingStates} - Whether the dialog is currently recording */
	this.state = RecordingManager.state;
}
RecordingDialog.prototype = Object.create(RowDialog.prototype);
RecordingDialog.prototype.constructor = RecordingDialog;

RecordingDialog.setConstants = function() {
	let RecD = RecordingDialog;
	RecD.currentDialog = null;
	RecD.extraBottomSpace = RowDialog.bnHeight + RowDialog.bnMargin;
	RecD.coverRectOpacity = 0.8;
	RecD.coverRectColor = Colors.black;
	RecD.counterColor = Colors.white;
	RecD.counterFont = Font.uiFont(60);
	RecD.remainingFont = Font.uiFont(16);
	RecD.remainingMargin = 10;
	RecD.counterBottomMargin = 50;
	RecD.recordColor = "#f00";
	RecD.recordFont = Font.uiFont(25);
	RecD.recordIconH = RecD.recordFont.charHeight;
	RecD.iconSidemargin = 10;
	RecD.recordingLimit = 5 * 60 * 1000;   // The maximum number of ms in a recording
	RecD.remainingThreshold = 5 * 60 * 1000;   // The remaining time is displayed when less than this many ms are left.
};

/**
 * @inheritDoc
 * @param {number} index
 * @param {number} y
 * @param {number} width
 * @param {Element} contentGroup
 */
RecordingDialog.prototype.createRow = function(index, y, width, contentGroup) {
	let RD = RowDialog;
	let largeBnWidth = width - RD.smallBnWidth * 2 - RD.bnMargin * 2;
	let recording = this.recordings[index];
	this.createMainBn(recording, largeBnWidth, 0, y, contentGroup);
	let renameBnX = largeBnWidth + RD.bnMargin;
	this.createRenameBn(recording, renameBnX, y, contentGroup);
	let deleteBnX = renameBnX + RD.smallBnWidth + RD.bnMargin;
	this.createDeleteBn(recording, deleteBnX, y, contentGroup);
};

/**
 * Creates the button for each recording that plays the recording when tapped
 * @param {Sound} recording
 * @param {number} bnWidth
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
RecordingDialog.prototype.createMainBn = function(recording, bnWidth, x, y, contentGroup) {
	let button = RowDialog.createMainBn(bnWidth, x, y, contentGroup);
	// Track whether the button is currently playing the recording
	const state = {};
	state.playing = false;
	let me = this;
	let showPlay = function() {
		button.addSideTextAndIcon(VectorPaths.play, RowDialog.iconH, recording);
	};
	let showStop = function() {
		button.addSideTextAndIcon(VectorPaths.square, RowDialog.iconH, recording);
	};
	// When the button is tapped...
	button.setCallbackFunction(function() {
		// Check the state...
		if (state.playing) {
			// Stop the sound
			Sound.stopAllSounds();
		} else {
			// Start the sound
			Sound.playAndStopPrev(recording, true, function() {
				state.playing = true;
				showStop();
			}, null, function() {
				// When the sound stops, change the icon and state
				if (me.visible) {
					state.playing = false;
					showPlay();
				}
			});
		}
	}, true);
	// Start with the play icon
	showPlay();
};

/**
 * Create the button for deleting recordings
 * @param {string} file - The name of the recording to delete
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
RecordingDialog.prototype.createDeleteBn = function(file, x, y, contentGroup) {
	let me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.trash, x, y, contentGroup, function() {
		RecordingManager.userDeleteFile(file, function() {
			me.reloadDialog();
		});
	});
};

/**
 * Create te button for renaming recordings
 * @param {string} file - The name of the recording to rename
 * @param {number} x
 * @param {number} y
 * @param {Element} contentGroup
 */
RecordingDialog.prototype.createRenameBn = function(file, x, y, contentGroup) {
	let me = this;
	RowDialog.createSmallBnWithIcon(VectorPaths.edit, x, y, contentGroup, function() {
		RecordingManager.userRenameFile(file, function() {
			me.reloadDialog();
		});
	});
};

/**
 * @inheritDoc
 */
RecordingDialog.prototype.show = function() {
	// Create the rows, title bar, etc.
	RowDialog.prototype.show.call(this);
	RecordingDialog.currentDialog = this;
	// Create the controls at the bottom.  These buttons are all hidden when created.
	this.recordButton = this.createRecordButton();
	this.discardButton = this.createDiscardButton();
	this.saveButton = this.createSaveButton();
	this.pauseButton = this.createPauseButton();
	this.resumeRecordingBn = this.createResumeRecordingBn();
	// Show the controls that correspond to the current state
	this.goToState(this.state);
};

/**
 * @inheritDoc
 */
RecordingDialog.prototype.hide = function() {
	RowDialog.prototype.hide.call(this);
	this.setCounterVisibility(false);
};

/**
 * @inheritDoc
 */
RecordingDialog.prototype.closeDialog = function() {
	RowDialog.prototype.closeDialog.call(this);
	RecordingDialog.currentDialog = null;
	Sound.stopAllSounds();
};

/**
 * Create the control for recording sounds
 * @return {Button}
 */
RecordingDialog.prototype.createRecordButton = function() {
	let RD = RowDialog;
	let RecD = RecordingDialog;
	let x = RD.bnMargin;
	// gets the location of additional content
	let y = this.getExtraBottomY();
	let button = new Button(x, y, this.getContentWidth(), RD.bnHeight, this.group);
	// The button has slightly larger text in red with a circle icon next to it (centered)
	button.addCenteredTextAndIcon(VectorPaths.circle, RecD.recordIconH, RecD.iconSidemargin,
		"Record", RecD.recordFont, RecD.recordColor);
	button.setCallbackFunction(function() {
		RecordingManager.startRecording();
	}, true);
	return button;
};

/**
 * Create a control that is 1/3 the width of the record button
 * @param {number} buttonPosition - [0, 1, 2], whether the button is in the first, second, or third position
 * @param {function} callbackFn - Called on tap
 * @return {Button}
 */
RecordingDialog.prototype.createOneThirdBn = function(buttonPosition, callbackFn) {
	let RD = RowDialog;
	let width = (this.getContentWidth() - RD.bnMargin * 2) / 3;
	let x = (RD.bnMargin + width) * buttonPosition + RD.bnMargin;
	let y = this.getExtraBottomY();
	let button = new Button(x, y, width, RD.bnHeight, this.group);
	button.setCallbackFunction(callbackFn, true);
	return button;
};

/**
 * Creates the button for discarding the current recording
 * @return {Button}
 */
RecordingDialog.prototype.createDiscardButton = function() {
	let RD = RowDialog;
	let RecD = RecordingDialog;
	let button = this.createOneThirdBn(0, function() {
		RecordingManager.discardRecording();
	}.bind(this));
	button.addCenteredTextAndIcon(VectorPaths.trash, RD.iconH, RecD.iconSidemargin, "Discard");
	return button;
};

/**
 * Creates the button for saving (stopping) the current recording
 * @return {Button}
 */
RecordingDialog.prototype.createSaveButton = function() {
	let RD = RowDialog;
	let RecD = RecordingDialog;
	let button = this.createOneThirdBn(1, function() {
		this.goToState(RecordingManager.recordingStates.stopped);
		RecordingManager.stopRecording();
	}.bind(this));
	button.addCenteredTextAndIcon(VectorPaths.square, RD.iconH, RecD.iconSidemargin, "Stop");
	return button;
};

/**
 * Creates the button for pausing the current recording
 * @return {Button}
 */
RecordingDialog.prototype.createPauseButton = function() {
	let RD = RowDialog;
	let RecD = RecordingDialog;
	let button = this.createOneThirdBn(2, function() {
		this.goToState(RecordingManager.recordingStates.paused);
		RecordingManager.pauseRecording();
	}.bind(this));
	button.addCenteredTextAndIcon(VectorPaths.pause, RD.iconH, RecD.iconSidemargin, "Pause");
	return button;
};

/**
 * Creates the button to unpause recording
 * @return {Button}
 */
RecordingDialog.prototype.createResumeRecordingBn = function() {
	let RD = RowDialog;
	let RecD = RecordingDialog;
	let button = this.createOneThirdBn(2, function() {
		this.goToState(RecordingManager.recordingStates.recording);
		RecordingManager.resumeRecording();
	}.bind(this));
	button.addCenteredTextAndIcon(VectorPaths.circle, RD.iconH, RecD.iconSidemargin, "Record");
	return button;
};

/**
 * Draws the dark rectangle to cover the dialog while recording
 * @return {Element}
 */
RecordingDialog.prototype.drawCoverRect = function() {
	let halfStep = RowDialog.bnMargin / 2;
	let x = this.x + halfStep;
	let y = this.y + this.getExtraTopY() + halfStep;
	let height = this.getExtraBottomY() - this.getExtraTopY() - RowDialog.bnMargin;
	let width = this.width - RowDialog.bnMargin;
	let rect = GuiElements.draw.rect(x, y, width, height, RecordingDialog.coverRectColor);
	GuiElements.update.opacity(rect, RecordingDialog.coverRectOpacity);
	GuiElements.layers.overlayOverlay.appendChild(rect);
	return rect;
};

/**
 * Draws the recording elapsed timer counter with "0:00" as the string
 * @return {Element} - An SVG text element
 */
RecordingDialog.prototype.drawTimeCounter = function() {
	let RD = RecordingDialog;

	let textE = GuiElements.draw.text(0, 0, "0:00", RD.counterFont, RD.counterColor);
	GuiElements.layers.overlayOverlay.appendChild(textE);
	let width = GuiElements.measure.textWidth(textE);
	let height = GuiElements.measure.textHeight(textE);
	let x = this.x + this.width / 2 - width / 2;
	let y = this.getExtraBottomY() - RecordingDialog.counterBottomMargin;
	let span = this.getExtraBottomY() - this.getExtraTopY() - height;
	if (span < 2 * RecordingDialog.counterBottomMargin) {
		y = this.getExtraBottomY() - span / 2;
	}
	y += this.y;
	this.counterY = y;
	GuiElements.move.text(textE, x, y);
	this.counter =  textE;

	let remainingY = y + RD.remainingFont.charHeight + RD.remainingMargin;
	let remainingWidth = GuiElements.measure.stringWidth("0:00 Remaining", RD.remainingFont);
	let remainingX = this.x + (this.width - remainingWidth) / 2;
	this.remainingY = remainingY;
	this.remaingingText = GuiElements.draw.text(remainingX, remainingY, "", RD.remainingFont, RD.counterColor);
	GuiElements.layers.overlayOverlay.appendChild(this.remaingingText);
};

/**
 * Creates and shows a RecordingDialog after retrieving a list of recordings from the frontend
 */
RecordingDialog.showDialog = function() {
	RecordingManager.listRecordings(function(result) {
		let recordDialog = new RecordingDialog(result);
		recordDialog.show();
	});
};

/**
 * shows/hides parts of the dialog according to the recording state provided.
 * @param {RecordingManager.recordingStates} state - The state this RecordingDialog should enter
 */
RecordingDialog.prototype.goToState = function(state) {
	let RecD = RecordingDialog;
	this.state = state;
	let states = RecordingManager.recordingStates;
	if (state === states.stopped) {
		this.recordButton.show();
		this.discardButton.hide();
		this.saveButton.hide();
		this.pauseButton.hide();
		this.resumeRecordingBn.hide();
		this.setCounterVisibility(false);
		this.getCenteredButton(0).enable();
	} else if (state === states.recording) {
		this.recordButton.hide();
		this.discardButton.show();
		this.saveButton.show();
		this.pauseButton.show();
		this.resumeRecordingBn.hide();
		this.setCounterVisibility(true);
		this.getCenteredButton(0).disable();
	} else if (state === states.paused) {
		this.recordButton.hide();
		this.discardButton.show();
		this.saveButton.show();
		this.pauseButton.hide();
		this.resumeRecordingBn.show();
		this.setCounterVisibility(true);
		this.getCenteredButton(0).disable();
	}
};

/**
 * Notifies the current RecordingDialog (if any) that recording has started
 */
RecordingDialog.startedRecording = function() {
	if (RecordingDialog.currentDialog != null) {
		RecordingDialog.currentDialog.goToState(RecordingManager.recordingStates.recording);
	}
};

/**
 * Notifies the current RecordingDialog (if any) that recording has stopped
 */
RecordingDialog.stoppedRecording = function() {
	if (RecordingDialog.currentDialog != null) {
		RecordingDialog.currentDialog.goToState(RecordingManager.recordingStates.stopped);
		RecordingDialog.currentDialog.reloadDialog();
	}
};

/**
 * Notifies the current RecordingDialog (if any) that recording has paused
 */
RecordingDialog.pausedRecording = function() {
	if (RecordingDialog.currentDialog != null) {
		RecordingDialog.currentDialog.goToState(RecordingManager.recordingStates.paused);
	}
};

/**
 * Re-retrieves the list of names from the backend and reloads the dialog with it
 * @inheritDoc
 */
RecordingDialog.prototype.reloadDialog = function() {
	let thisScroll = this.getScroll();
	let me = this;
	RecordingManager.listRecordings(function(response) {
		me.closeDialog();
		let dialog = new RecordingDialog(response);
		dialog.show();
		dialog.setScroll(thisScroll);
	});
};

/**
 * Shows/hides the counter and coverRect
 * @param {boolean} visible - Whether the counter and background behind it should be visible
 */
RecordingDialog.prototype.setCounterVisibility = function(visible) {
	if (visible) {
		if (this.coverRect == null) {
			this.coverRect = this.drawCoverRect();
		}
		if (this.counter == null) {
			this.drawTimeCounter();
		}
	} else {
		if (this.coverRect != null) {
			this.coverRect.remove();
			this.coverRect = null;
		}
		if (this.counter != null) {
			this.counter.remove();
			this.counter = null;
			this.remaingingText.remove();
			this.remaingingText = null;
		}
	}
};

/**
 * Sets the text of the counter according to the provided time.  Formats the time into hh:mm:ss or mm:ss
 * @param {number} time - elapsed time in ms
 */

RecordingDialog.prototype.timeToString = function(time) {
	if (this.counter == null) return;
	let totalSeconds = Math.floor(time / 1000);
	let seconds = totalSeconds % 60;
	let totalMinutes = Math.floor(totalSeconds / 60);
	let minutes = totalMinutes % 60;
	let hours = Math.floor(totalMinutes / 60);
	let secondsString = seconds + "";
	if (secondsString.length < 2) {
		secondsString = "0" + secondsString;
	}
	let minutesString = minutes + "";
	let totalString = minutesString + ":" + secondsString;
	if (hours > 0) {
		if (minutesString.length < 2) {
			minutesString = "0" + minutesString;
		}
		totalString = hours + ":" + minutesString + ":" + secondsString;
	}
	return totalString;
};
RecordingDialog.prototype.updateCounter = function(time) {
	const RD = RecordingDialog;
	if (this.counter == null) return;
	const totalString = this.timeToString(time);
	GuiElements.update.text(this.counter, totalString);
	let width = GuiElements.measure.textWidth(this.counter);
	let counterX = this.x + this.width / 2 - width / 2;
	GuiElements.move.text(this.counter, counterX, this.counterY);

	const remainingMs = Math.max(0, RD.recordingLimit - time + 999);
	if (remainingMs < RD.remainingThreshold) {
		const remainingString = this.timeToString(remainingMs) + " remaining";
		GuiElements.update.text(this.remaingingText, remainingString);
		let remainingWidth = GuiElements.measure.textWidth(this.remaingingText);
		let remainingX = this.x + this.width / 2 - remainingWidth / 2;
		GuiElements.move.text(this.remaingingText, remainingX, this.remainingY);
	}
};

/**
 * Updates the counter of the current RecordingDialog.  Called by the RecordingManager
 * @param time
 */
RecordingDialog.updateCounter = function(time) {
	if (this.currentDialog != null) {
		this.currentDialog.updateCounter(time);
	}
};

RecordingDialog.recordingsChanged = function() {
	if (RecordingDialog.currentDialog != null) {
		RecordingDialog.currentDialog.reloadDialog();
	}
}

RecordingDialog.alertNotInProject = function() {
	let message = "Please open a project before recording";
	DialogManager.showAlertDialog("No project open", message, "OK");
};
/**
 * Provides a list of Robots of a certain type to connect to in a BubbleOverlay.  Updates as new robots are found.
 * The list might be associated with a specific slot of the ConnectMultipleDialog, in which case it will not list
 * the robot that is currently in that slot and will allow robots in different slots to be selected to swap places
 * with them.
 * @param {number} x - The x coord of the point of the bubble
 * @param {number} upperY - The y coord if the bubble points up
 * @param {number} lowerY - The y coord if the bubble points down
 * @param {number|null} [index] - The index of slot this list is associated with, or null if N/A
 * @param deviceClass - Subclass of Device to scan for
 * @constructor
 */
function RobotConnectionList(x, upperY, lowerY, index, deviceClass) {
	if (index == null) {
		index = null;
	}
	this.x = x;
	this.upperY = upperY;
	this.lowerY = lowerY;
	this.index = index;
	this.deviceClass = deviceClass;
	this.visible = false;

	/* Sometimes the list is told to update its entries but can't since it is currently being scrolled.  In that case,
	 * marks a pending update and starts a timer which keeps trying to update until it succeeds */
	this.updatePending = false;
	this.updateTimer = new Timer(1000, this.checkPendingUpdate.bind(this));
}

RobotConnectionList.setConstants = function() {
	let RCL = RobotConnectionList;
	RCL.bnMargin = 5;
	RCL.bgColor = Colors.lightGray;
	RCL.updateInterval = DiscoverDialog.updateInterval;
	RCL.height = 150;
	RCL.width = 200;
};

/**
 * Makes the list visible with whatever devices have been detected so far (according to the cache in DeviceManager)
 */
RobotConnectionList.prototype.show = function() {
	this.showWithList(this.deviceClass.getManager().getDiscoverCache());
};

/**
 * Shows the RobotConnectionList with entries for the robots on the provided JSON-encoded list
 * @param {string} list - A JSON-encoded list of robots as a string
 */
RobotConnectionList.prototype.showWithList = function(list) {
	let RCL = RobotConnectionList;
	this.visible = true;
	this.group = GuiElements.create.group(0, 0);
	this.menuBnList = null;
	let layer = GuiElements.layers.overlayOverlay;
	let overlayType = Overlay.types.connectionList;
	this.bubbleOverlay = new BubbleOverlay(overlayType, RCL.bgColor, RCL.bnMargin, this.group, this, layer);
	this.bubbleOverlay.display(this.x, this.x, this.upperY, this.lowerY, RCL.width, RCL.height);
	this.deviceClass.getManager().registerDiscoverCallback(this.updateRobotList.bind(this));
	this.updateRobotList(list);
};

/**
 * Checks if the list needs to be updated and tries if it does
 */
RobotConnectionList.prototype.checkPendingUpdate = function() {
	if (this.updatePending) {
		this.updateRobotList(this.deviceClass.getManager().getDiscoverCache());
	}
};

/**
 * Updates the RobotConnectionList to contain the robots in the provided list
 * @param {string} jsonArray - A JSON-encoded array of robots as a string
 */
RobotConnectionList.prototype.updateRobotList = function(jsonArray) {
	const RCL = RobotConnectionList;
	let isScrolling = this.menuBnList != null && this.menuBnList.isScrolling();
	if (TouchReceiver.touchDown || !this.visible || isScrolling) {
		// Can't update, mark update pending and return
		this.updatePending = true;
		this.updateTimer.start();
		return;
	}
	// We're updating, so the pending update is cleared
	this.updatePending = false;
	this.updateTimer.stop();
	/* We include connected devices if this list is associated with a slot of the ConnectMultipleDialog to allow
	 * Robots to swap places. */
	const includeConnected = this.index !== null;
	const robotArray = this.deviceClass.getManager().fromJsonArrayString(jsonArray, includeConnected, this.index);

	// We perform the update and try to keep the scrolling the same
	let oldScroll = null;
	if (this.menuBnList != null) {
		oldScroll = this.menuBnList.getScroll();
		this.menuBnList.hide();
	}
	let layer = GuiElements.layers.overlayOverlayScroll;
	this.menuBnList = new SmoothMenuBnList(this, this.group, 0, 0, RCL.width, layer);
	this.menuBnList.markAsOverlayPart(this.bubbleOverlay);
	this.menuBnList.setMaxHeight(RCL.height);
	for (let i = 0; i < robotArray.length; i++) {
		this.addBnListOption(robotArray[i]);
	}
	this.menuBnList.show();
	if (oldScroll != null) {
		this.menuBnList.setScroll(oldScroll);
	}
};

/**
 * Adds an option to the menuBnList for the provided robot
 * @param {Device} robot
 */
RobotConnectionList.prototype.addBnListOption = function(robot) {
	let me = this;
	this.menuBnList.addOption(robot.name, function() {
		me.close();
		if (me.index == null) {
			me.deviceClass.getManager().appendDevice(robot);
		} else {
			me.deviceClass.getManager().setOrSwapDevice(me.index, robot);
		}
	});
};

/**
 * Closes the list
 */
RobotConnectionList.prototype.close = function() {
	this.bubbleOverlay.hide();
	this.visible = false;
	this.updateTimer.stop();
	if (this.menuBnList != null) this.menuBnList.hide();
};

/* Convert between relative and absolute coordinates */
RobotConnectionList.prototype.relToAbsX = function(x) {
	if (!this.visible) return x;
	return this.bubbleOverlay.relToAbsX(x);
};
RobotConnectionList.prototype.relToAbsY = function(y) {
	if (!this.visible) return y;
	return this.bubbleOverlay.relToAbsY(y);
};


/**
 * A dialog for discovering and connecting to a certain type of robot
 * @param deviceClass - subclass of Device, type of robot to scan for
 * @constructor
 */
function DiscoverDialog(deviceClass) {
	let DD = DiscoverDialog;
	let title = "Connect " + deviceClass.getDeviceTypeName(false);
	RowDialog.call(this, false, title, 0, 0, 0);
	this.addCenteredButton("Cancel", this.closeDialog.bind(this));
	this.deviceClass = deviceClass;
	this.addHintText(deviceClass.getConnectionInstructions());

	/** @type {Array<Device>} - The discovered devices to use as the content of the dialog */
	this.discoveredDevices = [];

	/* If an update happens at an inconvenient time (like while scrolling), the dialog is not reloaded; rather
	 * updatePending is set to true, the timer is started, and the reload occurs at a better time */
	this.updatePending = false;
	this.updateTimer = new Timer(1000, this.checkPendingUpdate.bind(this));
}
DiscoverDialog.prototype = Object.create(RowDialog.prototype);
DiscoverDialog.prototype.constructor = DiscoverDialog;

/**
 * Shows the dialog and starts the scan for devices
 * @inheritDoc
 */
DiscoverDialog.prototype.show = function() {
	const DD = DiscoverDialog;
	RowDialog.prototype.show.call(this);
	this.discoverDevices();
};

/**
 * Starts the scan for devices and registers the dialog to receive updates when devices are detected
 */
DiscoverDialog.prototype.discoverDevices = function() {
	let me = this;
	// Start the discover, and if the DeviceManger wants to know if it should ever restart a scan...
	this.deviceClass.getManager().startDiscover(function() {
		// Tell the device manager that it should scan again if the dialog is still open
		return this.visible;
	}.bind(this));
	// When a device is detected, update the dialog
	this.deviceClass.getManager().registerDiscoverCallback(this.updateDeviceList.bind(this));
};

/**
 * Checks if there is a pending update and updates the dialog if there is
 */
DiscoverDialog.prototype.checkPendingUpdate = function() {
	if (this.updatePending) {
		this.updateDeviceList(this.deviceClass.getManager().getDiscoverCache());
	}
};

/**
 * Reloads the dialog with the information from the new device list, or sets a pending update if the user is scrolling
 * or is touching the screen
 * @param {string} deviceList - A string representing a JSON array of devices
 */
DiscoverDialog.prototype.updateDeviceList = function(deviceList) {
	if (!this.visible) {
		return;
	} else if (TouchReceiver.touchDown || this.isScrolling()) {
		this.updatePending = true;
		this.updateTimer.start();
		return;
	}
	this.updatePending = false;
	this.updateTimer.stop();
	// Read the JSON
	this.discoveredDevices = this.deviceClass.getManager().fromJsonArrayString(deviceList);

	// Sort the devices by signal strength

	this.discoveredDevicesRSSISorted = this.discoveredDevices.sort(function(a,b) {
		return parseFloat(b.RSSI) - parseFloat(a.RSSI);
	});
	
	//this.reloadRows(this.discoveredDevicesRSSISorted.length);
	
	this.reloadRows(this.discoveredDevices.length);
};

/**
 * Creates the connection button for each discovered device
 * @inheritDoc
 * @param {number} index
 * @param {number} y
 * @param {number} width
 * @param {Element} contentGroup
 */
DiscoverDialog.prototype.createRow = function(index, y, width, contentGroup) {
	// TODO: use RowDialog.createMainBnWithText instead
	const button = new Button(0, y, width, RowDialog.bnHeight, contentGroup);

	button.addText(this.discoveredDevices[index].name + " (" + this.discoveredDevices[index].device + ")");
	const me = this;
	button.setCallbackFunction(function() {
		me.selectDevice(me.discoveredDevices[index]);
	}, true);
	button.makeScrollable();
};

/**
 * Connects to a device and closes the dialog
 * @param device
 */
DiscoverDialog.prototype.selectDevice = function(device) {
	this.deviceClass.getManager().setOneDevice(device);
	this.closeDialog();
};

/**
 * Stops the update timer and discover
 */
DiscoverDialog.prototype.closeDialog = function() {
	RowDialog.prototype.closeDialog.call(this);
	this.updateTimer.stop();
	this.deviceClass.getManager().stopDiscover();
};
/**
 * Displays a list of buttons for file manipulation.  Accessed by tapping the dots next to a file in an open dialog
 * @param {RowDialog} dialog - The dialog to reload when the files are changed
 * @param {string} file - The name of the file this option is for
 * @param {FileContextMenu.types} type - The type of context menu to show. Determines what options are available
 * @param {number} x1
 * @param {number} x2
 * @param {number} y1
 * @param {number} y2
 * @constructor
 */
function FileContextMenu(dialog, file, type, x1, x2, y1, y2) {
	this.file = file;
	this.dialog = dialog;
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.type = type;
	this.showMenu();
}

FileContextMenu.setGraphics = function() {
	const FCM = FileContextMenu;

	/** @enum {number} */
	FCM.types = {
		localSignedIn: 1,   // For when the user is looking at an open file and is signed into cloud storage
		localSignedOut: 2,   // For when the user is looking at an open file and is signed out of cloud storage
		cloud: 3   // For when the user if looking at a cloud file
	};

	FCM.bnMargin = Button.defaultMargin;
	FCM.bgColor = Colors.lightGray;
	FCM.blockShift = 20;
	FCM.width = 115;
};

/**
 * Generates and presents the menu
 */
FileContextMenu.prototype.showMenu = function() {
	const FCM = FileContextMenu;
	this.group = GuiElements.create.group(0, 0);
	const layer = GuiElements.layers.overlayOverlay;
	const scrollLayer = GuiElements.layers.overlayOverlayScroll;
	const overlayType = Overlay.types.inputPad;
	this.bubbleOverlay = new BubbleOverlay(overlayType, FCM.bgColor, FCM.bnMargin, this.group, this, layer);
	this.menuBnList = new SmoothMenuBnList(this.bubbleOverlay, this.group, 0, 0, FCM.width, scrollLayer);
	this.menuBnList.markAsOverlayPart(this.bubbleOverlay);
	this.addOptions();
	const height = this.menuBnList.previewHeight();
	this.bubbleOverlay.display(this.x1, this.x2, this.y1, this.y2, FCM.width, height);
	this.menuBnList.show();
};

/**
 * Adds options and their behaviors to the menu
 */
FileContextMenu.prototype.addOptions = function() {
	const FCM = FileContextMenu;
	if (this.type === FCM.types.localSignedIn) {
		this.menuBnList.addOption("", function() {
			SaveManager.userExportFile(this.file);
			this.close();
		}.bind(this), this.createAddIconToBnFn(VectorPaths.share, "Share"));
	}
	if (this.type === FCM.types.localSignedIn || this.type === FCM.types.localSignedOut) {
		this.menuBnList.addOption("", function() {
			const dialog = this.dialog;
			SaveManager.userDuplicateFile(this.file, function() {
				dialog.reloadDialog();
			});
			this.close();
		}.bind(this), this.createAddIconToBnFn(VectorPaths.copy, "Duplicate"));
	}
	this.menuBnList.addOption("", function() {
		if (this.type === FCM.types.cloud) {
			const request = new HttpRequestBuilder("cloud/delete");
			request.addParam("filename", this.file);
			HtmlServer.sendRequestWithCallback(request.toString());
			this.close();
		} else {
			const dialog = this.dialog;
			SaveManager.userDeleteFile(false, this.file, function() {
				dialog.reloadDialog();
			});
			this.close();
		}
	}.bind(this), this.createAddIconToBnFn(VectorPaths.trash, "Delete"));
};

/**
 * Creates the function to add the icon to the button
 * @param {object} pathId - Object from VectorPaths
 * @param {string} text - Text to display on the button
 * @return {function} - type: Button -> ()
 */
FileContextMenu.prototype.createAddIconToBnFn = function(pathId, text) {
	return function(bn) {
		bn.addSideTextAndIcon(pathId, null, text, null, null, null, null, null, null, true, false);
	}
};

/**
 * Closes the menu
 */
FileContextMenu.prototype.close = function() {
	this.bubbleOverlay.hide();
	this.menuBnList.hide()
};
/**
 * A set of four arrows around the edges of the canvas that show off screen Blocks
 * @constructor
 */
function OverflowArrows() {
	this.group = GuiElements.create.group(0, 0);
	this.triTop = this.makeTriangle();
	this.triLeft = this.makeTriangle();
	this.triRight = this.makeTriangle();
	this.triBottom = this.makeTriangle();
	this.setArrowPos();
	this.visible = false;
}

OverflowArrows.setConstants = function() {
	const OA = OverflowArrows;
	OA.triangleW = 25;
	OA.triangleH = 15;
	OA.margin = 15;
	OA.opacity = 0.5;
};

/**
 * Creates an SVG path element of the correct color.  The actual path information will be added later.
 * @return {Element} - The SVG path element
 */
OverflowArrows.prototype.makeTriangle = function() {
	const OA = OverflowArrows;
	const tri = GuiElements.create.path();
	GuiElements.update.color(tri, Colors.white);
	GuiElements.update.opacity(tri, OA.opacity);
	GuiElements.update.makeClickThrough(tri);
	return tri;
};

/**
 * Updates the visibility of the arrows given the active region of the canvas. If the canvas extends beyond an arrow
 * in one direction, then that arrow becomes visible to indicate off screen blocks
 * @param {number} left - The left boundary of the canvas
 * @param {number} right - The right boundary of the canvas
 * @param {number} top - The top boundary of the canvas
 * @param {number} bottom - The bottom boundary of the canvas
 */
OverflowArrows.prototype.setArrows = function(left, right, top, bottom) {
	if (left === right) {
		// If the width of the canvas is 0, there are no Blocks, so the arrows should be hidden.
		this.showIfTrue(this.triLeft, false);
		this.showIfTrue(this.triRight, false);
	} else {
		this.showIfTrue(this.triLeft, left < this.left);
		this.showIfTrue(this.triRight, right > this.right);
	}
	if (top === bottom) {
		// If the height of the canvas is 0, there are no Blocks, so the arrows should be hidden.
		this.showIfTrue(this.triTop, false);
		this.showIfTrue(this.triBottom, false);
	} else {
		this.showIfTrue(this.triTop, top < this.top);
		this.showIfTrue(this.triBottom, bottom > this.bottom);
	}
};

/**
 * Sets the visibility of the triangle according to the boolean parameter
 * @param {Element} tri - The path to set the visibility of
 * @param {boolean} shouldShow - Whether the path should be visible of not.
 */
OverflowArrows.prototype.showIfTrue = function(tri, shouldShow) {
	if (shouldShow) {
		this.group.appendChild(tri);
	} else {
		tri.remove();
	}
};

/**
 * Makes all overflow arrows visible
 */
OverflowArrows.prototype.show = function() {
	if (!this.visible) {
		this.visible = true;
		GuiElements.layers.overflowArr.appendChild(this.group);
	}
};

/**
 * Makes all overflow arrows hidden
 */
OverflowArrows.prototype.hide = function() {
	if (this.visible) {
		this.visible = false;
		this.group.remove();
	}
};

/**
 * Recomputes the positions of the overflow arrows
 */
OverflowArrows.prototype.updateZoom = function() {
	this.setArrowPos();
};

/**
 * Moves overflowArrows to the correct positions and stores the boundary of the portion of the screen for the canvas
 */
OverflowArrows.prototype.setArrowPos = function() {
	const OA = OverflowArrows;
	this.left = BlockPalette.width;
	if (!GuiElements.paletteLayersVisible) {
		this.left = 0;
	}
	this.top = TitleBar.height;
	this.right = GuiElements.width;
	this.bottom = GuiElements.height;

	const midX = (this.left + this.right) / 2;
	const midY = (this.top + this.bottom) / 2;
	const topY = this.top + OA.margin;
	const bottomY = this.bottom - OA.margin;
	const leftX = this.left + OA.margin;
	const rightX = this.right - OA.margin;

	GuiElements.update.triangleFromPoint(this.triTop, midX, topY, OA.triangleW, OA.triangleH, true);
	GuiElements.update.triangleFromPoint(this.triLeft, leftX, midY, OA.triangleW, OA.triangleH, false);
	GuiElements.update.triangleFromPoint(this.triRight, rightX, midY, OA.triangleW, -OA.triangleH, false);
	GuiElements.update.triangleFromPoint(this.triBottom, midX, bottomY, OA.triangleW, -OA.triangleH, true);
};
/**
 * BlockStack is a class that holds a stack of Blocks.
 * BlockStacks move, execute, and snap the Blocks within them.
 * They pass messages onto their Blocks, which are passed on recursively.
 * Blocks are initially created outside a BlockStacks, but are immediately moved into one.
 * Empty BlockStacks are not allowed because each BlockStack must have a non-null firstBlock property.
 * @constructor
 * @param {Block} firstBlock - The first Block in the BlockStack.
 * The firstBlock is automatically moved along with subsequent Blocks into the BlockStack.
 * @param {Tab} tab - The tab the BlockStack lives within.
 */
function BlockStack(firstBlock, tab) {
	tab.addStack(this); // The Tab maintains a list of all its BlockStacks.
	this.firstBlock = firstBlock;
	this.firstBlock.stop(); // Prevents execution.
	this.firstBlock.stopGlow(); // Removes visual indicator of execution.
	this.returnType = firstBlock.returnType; // The BlockStack returns the same type of value as its first Block.
	this.tab = tab;
	this.x = 0;
	this.y = 0;
	this.x = this.absToRelX(firstBlock.getAbsX());
	this.y = this.absToRelY(firstBlock.getAbsY());
	this.tabGroup = tab.mainG; // Stores the SVG group element of the Tab it is within.
	this.group = GuiElements.create.group(this.x, this.y, this.tabGroup); // Creates a group for the BlockStack.
	this.firstBlock.changeStack(this); // Moves all Blocks into the BlockStack.
	this.dim = {}; // Stores information about the snap bounding box of the BlockStack.
	// this.dim values will be assigned later.
	this.dim.cw = 0; // Dimensions of regions command blocks can be attached to.
	this.dim.ch = 0;
	this.dim.rw = 0; // Dimensions of regions reporter/predicate blocks can be attached to.
	this.dim.rh = 0;
	this.dim.cx1 = 0; // These will be measured relative to the Tab, not the BlockStack.
	this.dim.cy1 = 0;
	this.dim.rx1 = 0;
	this.dim.ry1 = 0;
	this.updateDim(); // Updates the this.dim values, the dimensions of the Blocks, and aligns them.
	this.isRunning = false;
	this.currentBlock = null; // Keeps track of which Block in the BlockStack is currently executing.
	this.isDisplayStack = false;
	this.runningBroadcastMessage = ""; // Keeps track of if this stack's execution was started by a broadcast.
	this.move(this.x, this.y);
	this.flying = false; // BlockStacks being moved enter flying mode so they are above other BlockStacks and Tabs.
	this.tab.updateArrows();
}

/**
 * Recursively updates the this.dim values, the dimensions of the Blocks, and and the Blocks' alignment.
 */
BlockStack.prototype.updateDim = function() {
	// Recursively updates the dimensions of the Blocks.
	this.firstBlock.updateDim();
	// The first Block is aligned to the top-left corner of the BlockStack.
	// Blocks recursively aligned.
	this.firstBlock.updateAlign(0, 0);
	// Clear existing values from bounding boxes.
	// During updateStackDim, these values are measured relative to the BlockStack.
	this.dim.cx1 = 0;
	this.dim.cy1 = 0;
	this.dim.cx2 = 0;
	this.dim.cy2 = 0;
	this.dim.rx1 = 0;
	this.dim.ry1 = 0;
	this.dim.rx2 = 0;
	this.dim.ry2 = 0;
	// Recursively each box updates the this.dim boxes to include their own bounding boxes.
	this.firstBlock.updateStackDim();
	// Dimensions of both types of boxes are calculated.
	this.dim.cw = this.dim.cx2 - this.dim.cx1;
	this.dim.ch = this.dim.cy2 - this.dim.cy1;
	this.dim.rw = this.dim.rx2 - this.dim.rx1;
	this.dim.rh = this.dim.ry2 - this.dim.ry1;
};

/**
 * Converts a coordinate relative to the inside of the stack to one relative to the screen.
 * @param {number} x - The coord relative to the inside fo the stack.
 * @return {number} - The coord relative to the screen.
 */
BlockStack.prototype.relToAbsX = function(x) {
	if (this.flying) {
		return CodeManager.dragRelToAbsX(x + this.x);
	} else {
		return this.tab.relToAbsX(x + this.x); // In a Tab; return x plus Tab's offset.
	}
};

/**
 * @param {number} y
 * @return {number}
 */
BlockStack.prototype.relToAbsY = function(y) {
	if (this.flying) {
		return CodeManager.dragRelToAbsY(y + this.y); // Not in a Tab; scale by dragLayer's scale
	} else {
		return this.tab.relToAbsY(y + this.y); // In a Tab; return y plus Tab's offset.
	}
};
/**
 * Converts a coordinate relative to the screen to one relative to the inside of the stack.
 * @param {number} x - The coord relative to the screen.
 * @return {number} - The coord relative to the inside fo the stack.
 */
BlockStack.prototype.absToRelX = function(x) {
	if (this.flying) {
		return CodeManager.dragAbsToRelX(x) - this.x;
	} else {
		return this.tab.absToRelX(x) - this.x; // In a Tab; return x minus Tab's offset.
	}
};
/**
 * @param {number} y
 * @return {number}
 */
BlockStack.prototype.absToRelY = function(y) {
	if (this.flying) {
		return CodeManager.dragAbsToRelY(y) - this.y;
	} else {
		return this.tab.absToRelY(y) - this.y; // In a Tab; return y minus Tab's offset.
	}
};
/**
 * Returns the x coord of the BlockStack relative to the screen.
 * @return {number} The x coord of the BlockStack relative to the screen.
 */
BlockStack.prototype.getAbsX = function() {
	return this.relToAbsX(0);
};
/**
 * Returns the y coord of the BlockStack relative to the screen.
 * @return {number} The y coord of the BlockStack relative to the screen.
 */
BlockStack.prototype.getAbsY = function() {
	return this.relToAbsY(0);
};

/**
 * Searches the Blocks within this BlockStack to find one which fits the moving BlockStack.
 * Returns no values but stores results on CodeManager.fit.
 */
BlockStack.prototype.findBestFit = function() {
	const move = CodeManager.move;
	// If this BlockStack is the one being moved, it can't attach to itself.
	if (move.stack === this) {
		return;
	}
	// Check if the moving BlockStack can attach to the top of this BlockStack.
	if (move.bottomOpen && this.firstBlock.topOpen) {
		this.findBestFitTop();
	}
	// Recursively check if the moving BlockStack can attach to the bottom of any Blocks in this BlockStack.
	if (move.topOpen) {
		// Only check recursively if the corner of the moving BlockStack falls within this BlockStack's snap box.
		let absCx = this.relToAbsX(this.dim.cx1);
		let absCy = this.relToAbsY(this.dim.cy1);
		let absW = this.relToAbsX(this.dim.cw) - absCx;
		let absH = this.relToAbsY(this.dim.ch) - absCy;
		if (move.pInRange(move.topX, move.topY, absCx, absCy, absW, absH)) {
			this.firstBlock.findBestFit();
		}
	}
	// Recursively check recursively if the moving BlockStack can attach one of this BlockStack's Slots.
	if (move.returnsValue) {
		// Only check if the BlockStack's bounding box overlaps with this BlockStack's bounding box.
		let absRx = this.relToAbsX(this.dim.rx1);
		let absRy = this.relToAbsY(this.dim.ry1);
		let absW = this.relToAbsX(this.dim.rw) - absRx;
		let absH = this.relToAbsY(this.dim.rh) - absRy;
		let width = move.bottomX - move.topX;
		let height = move.bottomY - move.topY;
		if (move.rInRange(move.topX, move.topY, width, height, absRx, absRy, absW, absH)) {
			this.firstBlock.findBestFit();
		}
	}
};

/**
 * Moves this BlockStack to a new location relative to the Tab. Updates this.x and this.y accordingly.
 * @param {number} x - the x coord to move to.
 * @param {number} y - the y coord to move to.
 */
BlockStack.prototype.move = function(x, y) {
	this.x = x;
	this.y = y;
	GuiElements.move.group(this.group, x, y);
};

/**
 * Recursively stops the execution of the BlockStack and its contents. Removes the glow as well.
 */
BlockStack.prototype.stop = function() {
	if (this.isRunning) {
		this.firstBlock.stop();
		this.endRun(); // Removes glow and sets isRunning.
	}
};

/**
 * Updates the execution of the BlockStack and its contents. Returns boolean to indicate if still running.
 * @return {ExecutionStatus}
 */
BlockStack.prototype.updateRun = function() {
	if (this.isRunning) {
		// Different procedures are used if the Block returns a value.
		if (this.returnType === Block.returnTypes.none) {
			// If the current Block has been removed, don't run it.
			if (this.currentBlock.stack !== this) {
				this.endRun(); // Stop execution.
				return new ExecutionStatusDone();
			}
			// Update the current Block.
			let execStatus = this.currentBlock.updateRun();
			if (!execStatus.isRunning()) {
				// If the block threw a error, display it
				if (execStatus.hasError()) {
					this.endRun();
					return new ExecutionStatusDone();
				} else {
					// Otherwise, the next block will run next.
					this.currentBlock = this.currentBlock.nextBlock;
				}
			}
			// If the end of the BlockStack has been reached, end execution.
			if (this.currentBlock != null) {
				return new ExecutionStatusRunning();
			} else {
				this.endRun();
				return new ExecutionStatusDone();
			}
		} else {
			// Procedure for Blocks that return a value.
			let execStatus = this.currentBlock.updateRun();
			if (execStatus.isRunning()) {
				return new ExecutionStatusRunning();
			} else if (execStatus.hasError()) {
				this.endRun();
				return new ExecutionStatusDone();
			} else {
				// When it is done running, display the result.
				this.currentBlock.displayResult(execStatus.getResult());
				this.endRun(); // Execution is done.
				return new ExecutionStatusDone();
			}
		}
	} else {
		// It's not running, so we are done
		return new ExecutionStatusDone();
	}
};

/**
 * Starts execution of the BlockStack starting with the specified Block. Makes BlockStack glow, too.
 * @param {Block} [startBlock] - The first Block to execute. By default, this.firstBlock is used.
 * @param {string} [broadcastMessage] - Indicates if execution was triggered by a broadcast
 */
BlockStack.prototype.startRun = function(startBlock, broadcastMessage) {
	if (startBlock == null) {
		startBlock = this.firstBlock;
	}
	if (broadcastMessage == null) {
		broadcastMessage = "";
	}
	this.runningBroadcastMessage = broadcastMessage;
	if (!this.isRunning) { // Only start if not already running.
		this.isRunning = true;
		this.currentBlock = startBlock;
		this.firstBlock.glow();
		this.tab.startRun(); // Starts Tab if it is not already running.
	}
};

/**
 * Ends execution and removes glow. Does not call stop() function on Blocks; assumes they have stopped already.
 */
BlockStack.prototype.endRun = function() {
	this.isRunning = false;
	this.firstBlock.stopGlow();
};

/**
 * Checks if the moving BlockStack can snap on to the top of this BlockStack. Returns nothing.
 * Results are stored in CodeManager.fit.
 * Only called if moving BlockStack returns no value.
 */
BlockStack.prototype.findBestFitTop = function() {
	const snap = BlockGraphics.command.snap; // Get snap bounding box for command Blocks.
	const move = CodeManager.move;
	const fit = CodeManager.fit;
	const x = this.firstBlock.getAbsX(); // Uses screen coordinates.
	const y = this.firstBlock.getAbsY();
	const height = this.relToAbsY(this.firstBlock.height) - y;
	/* Now the BlockStack will check if the bottom-left corner of the moving BlockStack falls within
	 * the snap bounding box of the first Block in the BlockStack. */
	// Gets the bottom-left corner of the moving BlockStack.
	const moveBottomLeftX = move.topX;
	const moveBottomLeftY = move.bottomY;
	// Gets the snap bounding box of the first Block.
	const snapBLeft = x - snap.left;
	const snapBTop = y - snap.top;
	const snapBWidth = snap.left + snap.right;
	const snapBHeight = snap.top + height + snap.bottom;
	// Checks if the point falls in the box.
	if (move.pInRange(moveBottomLeftX, moveBottomLeftY, snapBLeft, snapBTop, snapBWidth, snapBHeight)) {
		const xDist = move.topX - x;
		const yDist = move.bottomY - y;
		const dist = xDist * xDist + yDist * yDist; // Computes the distance.
		if (!fit.found || dist < fit.dist) { // Compares it to existing fit.
			fit.found = true;
			fit.bestFit = this; // Note that in this case the bestFit is set to a BlockStack, not a Block.
			fit.dist = dist; // Saves the fit.
		}
	}
};

/**
 * Recursively attaches the provided Block and its subsequent Blocks to the top of this BlockStack.
 * @param {Block} block - The Block to attach to this BlockStack.
 */
BlockStack.prototype.snap = function(block) {
	block.stack.stop();
	if (this.isRunning) {
		// Make it glow if this stack is running
		block.glow();
	}
	/* Move this BlockStack up by the height of the of the stack the Block belongs to.
	 * This compensates for the amount existing Blocks will be shifted down by the newly-added Blocks. */
	this.move(this.x, this.y - block.stack.getHeight());

	// The new top Block.
	const topStackBlock = block;
	// The last Block in the stack being added.
	const bottomStackBlock = block.getLastBlock();
	// The topmost of the existing Blocks.
	const upperBlock = this.firstBlock;

	// Fix references between Blocks to glue them together.
	this.firstBlock = topStackBlock;
	topStackBlock.parent = null;
	bottomStackBlock.nextBlock = upperBlock;
	upperBlock.parent = bottomStackBlock;
	// The old BlockStack can now be destroyed.
	const oldG = block.stack.group;
	block.stack.remove();
	block.changeStack(this);
	oldG.remove();

	this.updateDim();
};

/**
 * Adds an indicator showing that the moving BlockStack will snap onto the top of this BlockStack if released.
 */
BlockStack.prototype.highlight = function() {
	Highlighter.highlight(this.getAbsX(), this.getAbsY(), 0, 0, 0, false, this.isRunning);
};

/**
 * Shifts this BlockStack by the specified amount.
 * @param {number} x - The amount to shift in the x direction.
 * @param {number} y - The amount to shift in the y direction.
 */
BlockStack.prototype.shiftOver = function(x, y) {
	this.move(this.x + x, this.y + y);
};

/**
 * Recursively copies this BlockStack and all its contents to a new BlockStack. Returns the new BlockStack.
 * @return {BlockStack} - The newly-copied BlockStack.
 */
BlockStack.prototype.duplicate = function(x, y) {
	// First duplicate the Blocks.
	const firstCopyBlock = this.firstBlock.duplicate(x, y);
	// Then put them in a new BlockStack.
	return new BlockStack(firstCopyBlock, this.tab);
};

/**
 * Returns the Tab this BlockStack belongs to. Used by the Blocks it contains when they need to kow their tab.
 * @return {Tab} - The Tab this BlockStack belongs to.
 */
BlockStack.prototype.getTab = function() {
	return this.tab;
};

/**
 * Moves this BlockStack out of the Tab's group and into the drag layer about other Blocks.
 */
BlockStack.prototype.fly = function() {
	// Remove group from Tab (visually only).
	this.group.remove();
	// Add group to drag layer.
	GuiElements.layers.drag.appendChild(this.group);
	// Get current location on screen.
	const absX = this.getAbsX();
	const absY = this.getAbsY();
	// Record that this BlockStack is flying.
	this.flying = true;
	// Move to ensure that position on screen does not change.
	this.move(CodeManager.dragAbsToRelX(absX), CodeManager.dragAbsToRelY(absY));
	this.tab.updateArrows();
};

/**
 * Moves this BlockStack back into its Tab's group.
 */
BlockStack.prototype.land = function() {
	this.group.remove(); // Remove from drag layer.
	this.tabGroup.appendChild(this.group); // Go back into tab group.
	const absX = this.getAbsX(); // Get current location on screen.
	const absY = this.getAbsY();
	this.flying = false;
	// Move to ensure that position on screen does not change.
	this.move(this.tab.absToRelX(absX), this.tab.absToRelY(absY));
	this.tab.updateArrows();
};

/**
 * Stops execution and removes the BlockStack digitally and visually.
 */
BlockStack.prototype.remove = function() {
	this.stop();
	this.group.remove();
	this.tab.removeStack(this);
	this.tab.updateArrows();
};

/**
 * Passes message to first Block in BlockStack that the flag was tapped.
 */
BlockStack.prototype.eventFlagClicked = function() {
	// Only pass message if not already running.
	if (!this.isRunning) {
		this.firstBlock.eventFlagClicked();
	}
};

/**
 * Passes broadcast message to first Block in BlockStack.
 * @param {string} message - The broadcast message
 */
BlockStack.prototype.eventBroadcast = function(message) {
	this.firstBlock.eventBroadcast(message);
};

/**
 * Checks if a broadcast is still running (used for the broadcast and wait Block).
 * @param {string} message - The broadcast message
 */
BlockStack.prototype.checkBroadcastRunning = function(message) {
	if (this.isRunning) {
		return this.runningBroadcastMessage === message;
	}
	return false;
};

/**
 * Recursively updates the available broadcast messages.
 */
BlockStack.prototype.updateAvailableMessages = function() {
	this.firstBlock.updateAvailableMessages();
};

/**
 * Recursively returns the last Block in the BlockStack.
 * @return {Block} - The last Block in the BlockStack.
 */
BlockStack.prototype.getLastBlock = function() {
	return this.firstBlock.getLastBlock();
};

/**
 * Updates the dimensions of the Tab
 */
BlockStack.prototype.updateTabDim = function() {
	// Flying blocks don't count
	if (this.flying) return;

	// If this stack's bounding box is outside the Tab's current bounding box, update the Tab's box to include it.
	const dim = this.tab.dim;
	if (dim.x1 == null || this.x < dim.x1) {
		dim.x1 = this.x;
	}
	if (dim.y1 == null || this.y < dim.y1) {
		dim.y1 = this.y;
	}
	const x2 = this.x + this.dim.rw;
	if (dim.x2 == null || x2 > dim.x2) {
		dim.x2 = x2;
	}
	const y2 = this.y + this.dim.rh;
	if (dim.y2 == null || y2 > dim.y2) {
		dim.y2 = y2;
	}
};

/**
 * Writes the BlockStack to XML
 * @param {Document} xmlDoc - The document to write to
 * @return {Node} - The XML node representing the BlockStack
 */
BlockStack.prototype.createXml = function(xmlDoc) {
	const stack = XmlWriter.createElement(xmlDoc, "stack");
	XmlWriter.setAttribute(stack, "x", this.x);
	XmlWriter.setAttribute(stack, "y", this.y);
	// Create a tag for Blocks and recursively write the Blocks to it.
	const blocks = XmlWriter.createElement(xmlDoc, "blocks");
	this.firstBlock.writeToXml(xmlDoc, blocks);
	stack.appendChild(blocks);
	return stack;
};

/**
 * Creates a BlockStack from XML
 * @param {Node} stackNode - The tag to import from
 * @param {Tab} tab - The Tab to import into
 * @return {BlockStack|null} stack - The imported stack
 */
BlockStack.importXml = function(stackNode, tab) {
	const x = XmlWriter.getAttribute(stackNode, "x", 0, true);
	const y = XmlWriter.getAttribute(stackNode, "y", 0, true);
	const blocksNode = XmlWriter.findSubElement(stackNode, "blocks");
	const blockNodes = XmlWriter.findSubElements(blocksNode, "block");

	// All stacks must have at least one Block to be created
	let firstBlock = null;
	let i = 0;
	// The first Block to successfully import becomes the first Block in the Stack
	while (firstBlock == null && i < blockNodes.length) {
		firstBlock = Block.importXml(blockNodes[i]);
		i++;
	}
	if (firstBlock == null) {
		// All Blocks could not import.  Exit.
		return null;
	}
	const stack = new BlockStack(firstBlock, tab);
	stack.move(x, y);
	// We iterate through the Blocks, keeping track of the previous Block so we can link them properly
	let previousBlock = firstBlock;
	while (i < blockNodes.length) {
		const newBlock = Block.importXml(blockNodes[i]);
		if (newBlock != null) {
			previousBlock.snap(newBlock);
			previousBlock = newBlock;
		}
		i++;
	}
	stack.updateDim();
	return stack;
};

/**
 * Notifies the BlockStack that a variable has been renamed.  Passed recursively.
 * @param {Variable} variable - The variable that has been renamed
 */
BlockStack.prototype.renameVariable = function(variable) {
	this.passRecursively("renameVariable", variable);
};

/**
 * Notifies the BlockStack that a variable has been deleted.  Passed recursively.
 * @param {Variable} variable - The variable that has been deleted
 */
BlockStack.prototype.deleteVariable = function(variable) {
	this.passRecursively("deleteVariable", variable);
};

/**
 * Notifies the BlockStack that a list has been renamed.  Passed recursively.
 * @param {List} list - The list that has been renamed
 */
BlockStack.prototype.renameList = function(list) {
	this.passRecursively("renameList", list);
};

/**
 * Notifies the BlockStack that a list has been deleted.  Passed recursively.
 * @param {List} list - The list that has been deleted
 */
BlockStack.prototype.deleteList = function(list) {
	this.passRecursively("deleteList", list);
};

/**
 * @param {Variable} variable
 * @return {boolean}
 */
BlockStack.prototype.checkVariableUsed = function(variable) {
	return this.firstBlock.checkVariableUsed(variable);
};

/**
 * @param {List} list
 * @return {boolean}
 */
BlockStack.prototype.checkListUsed = function(list) {
	return this.firstBlock.checkListUsed(list);
};

/**
 * Updates dimensions after device dropdowns become visible
 * @param deviceClass
 */
BlockStack.prototype.hideDeviceDropDowns = function(deviceClass) {
	this.updateDim();
};

/**
 * Updates dimensions after device dropdowns become hidden
 * @param deviceClass
 */
BlockStack.prototype.showDeviceDropDowns = function(deviceClass) {
	this.updateDim();
};

/**
 * @param deviceClass
 * @return {number}
 */
BlockStack.prototype.countDevicesInUse = function(deviceClass) {
	return this.firstBlock.countDevicesInUse(deviceClass);
};

/**
 * @param {string} message
 */
BlockStack.prototype.passRecursivelyDown = function(message) {
	const myMessage = message;
	let funArgs = Array.prototype.slice.call(arguments, 1);

	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);

	if(myMessage === "showDeviceDropDowns" && this.showDeviceDropDowns != null) {
		this.showDeviceDropDowns.apply(this, funArgs);
	}
	if(myMessage === "hideDeviceDropDowns" && this.hideDeviceDropDowns != null) {
		this.hideDeviceDropDowns.apply(this, funArgs);
	}
};

/**
 *
 * @param {string} functionName
 */
BlockStack.prototype.passRecursively = function(functionName) {
	let args = Array.prototype.slice.call(arguments, 1);
	this.firstBlock[functionName].apply(this.firstBlock, args);
};

/**
 * Returns the width of the BlockStack (using relative coordinates)
 * @return {number}
 */
BlockStack.prototype.getWidth = function() {
	return this.dim.rw;
};

/**
 * Returns the height of the BlockStack (using relative coordinates)
 * @return {number}
 */
BlockStack.prototype.getHeight = function() {
	return this.dim.rh;
};
/**
 * Represents a request to be used with HtmlServer
 * @param url {String} - The beginning of the request
 * @constructor
 */
function HttpRequestBuilder(url){
	DebugOptions.validateNonNull(url);
	this.request = url;
	this.hasFirstParam = false;
}

/**
 * Adds a get parameter with the given key and value
 * @param key {String}
 * @param value {String} - The value, which will be percent encoded before it is sent
 */
HttpRequestBuilder.prototype.addParam = function(key, value){
	if(!this.hasFirstParam){
		this.hasFirstParam = true;
		this.request += "?";
	} else{
		this.request += "&";
	}
	this.request += key;
	this.request += "=";
	this.request += HtmlServer.encodeHtml(value);
};

/**
 * Returns the request to give to HtmlServer
 * @returns {String}
 */
HttpRequestBuilder.prototype.toString = function(){
	return this.request;
};


/**
 * Represents a setting stored on the backend.  Automatically edits and caches the backend value
 * @param {string} key - The key of the setting (on the backend)
 * @param {string|number} defaultVal - The default value of the setting
 * @param {boolean} [number=false] - Whether the setting is a number
 * @param {boolean} [integer=false] - Whether the setting only accepts integer values
 * @param {number|null} [min] - The minimum value the setting can take (null for no minimum)
 * @param {number|null} [max] - The maximum value the setting can take (null for no minimum)
 */
function Setting(key, defaultVal, number, integer, min, max) {
	if(number == null) {
		number = false;
	}
	if(integer == null) {
		integer = false;
	}
	if(min == null) {
		max = null;
	}
	if(max == null) {
		max = null;
	}

	this.key = key;
	this.number = number;
	this.integer = integer;
	this.min = min;
	this.max = max;
	this.value = defaultVal;
}

/**
 * Gets the cached value of the setting
 * @return {number|string}
 */
Setting.prototype.getValue = function(){
	return this.value;
};

/**
 * Sends a request to change the setting and updates the cached value. Validates the value to ensure it is in range
 * @param {number|string} value - The value to store
 */
Setting.prototype.writeValue = function(value){
	this.value = value;
	if(this.number) {
		this.value = (new NumData(value)).getValueInR(this.min, this.max);
	}
	const request = new HttpRequestBuilder("settings/set");
	request.addParam("key", this.key);
	request.addParam("value", HtmlServer.encodeHtml(this.value + ""));
	HtmlServer.sendRequestWithCallback(request.toString());
};

/**
 * Sends a request to get the value of the setting from the backend.  Keeps the current value if it gets no response.
 * @param {function} callbackFn - type (string|number) -> () called with value once read, or with current value if error
 */
Setting.prototype.readValue = function(callbackFn){
	const request = new HttpRequestBuilder("settings/get");
	request.addParam("key", this.key);
	HtmlServer.sendRequestWithCallback(request.toString(), function(result){
		let res = result;
		if(this.number) {
			const numData = (new StringData(res)).asNum();
			if(numData.isValid) {
				this.value = numData.getValueInR(this.min, this.max, false, this.integer);
			}
		} else {
			this.value = res;
		}
		callbackFn(this.value);
	}.bind(this), function(){
		if(callbackFn != null) callbackFn(this.value);
	}.bind(this));
};
/**
 * Static class stores Settings and makes them accessible to other classes
 */
function SettingsManager() {
	const SM = SettingsManager;
	SM.zoom = new Setting("zoom", 1, true, false, GuiElements.minZoomMult, GuiElements.maxZoomMult);
	SM.enableSnapNoise = new Setting("enableSnapNoise", "true");
	SM.sideBarVisible = new Setting("sideBarVisible", "true");
}

/**
 * Loads settings from the backend and calls callbackFn when finished
 * @param {function} callbackFn - Called when done loading/tying to load settings
 */
SettingsManager.loadSettings = function(callbackFn) {
	const SM = SettingsManager;
	SM.sideBarVisible.readValue(function() {
		SM.enableSnapNoise.readValue(function() {
			SM.zoom.readValue(callbackFn);
		});
	});
};
/**
 * HtmlServer is a static class sends messages to the backend
 */
function HtmlServer() {
	HtmlServer.port = 22179;
	HtmlServer.requestTimeout = 5000;
	HtmlServer.iosRequests = {};
	HtmlServer.iosHandler = HtmlServer.getIosHandler();
	HtmlServer.unansweredCount = 0; // Tracks pending requests
	/* Maximum safe number of unanswered requests. After this number is hit, some Blocks
	 * might choose to throttle requests (like Broadcast Blocks) */
	HtmlServer.unansweredCap = 10;
}

HtmlServer.getIosHandler = function() {
	if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.serverSubstitute &&
		window.webkit.messageHandlers.serverSubstitute.postMessage) {
		GuiElements.alert("Using native");
		return window.webkit.messageHandlers.serverSubstitute.postMessage;
	} else {
		GuiElements.alert("Using http");
		return null;
	}
};

HtmlServer.createFakeIosHandler = function() {
	return "test";
	return function (object) {
		console.log("request: " + object.request + ",  body: " + object.body + ", id: " + object.id);
	}
};

/**
 * Removes percent encoding from a string
 * @param {string} message - The percent encoded string
 * @return {string} - The decoded string
 */
HtmlServer.decodeHtml = function(message) {
	return decodeURIComponent(message.replace(/\+/g, " "));
};

/**
 * Applies percent encoding to a string
 * @param {string} message - The input string
 * @return {string} - The percent encoded string
 */
HtmlServer.encodeHtml = function(message) {
	/*if(message==""){
		return "%20"; //Empty strings can't be used in the URL.
	}*/
	let eVal;
	if (!encodeURIComponent) {
		eVal = escape(message);
		eVal = eVal.replace(/@/g, "%40");
		eVal = eVal.replace(/\//g, "%2F");
		eVal = eVal.replace(/\+/g, "%2B");
		eVal = eVal.replace(/'/g, "%60");
		eVal = eVal.replace(/"/g, "%22");
		eVal = eVal.replace(/`/g, "%27");
		eVal = eVal.replace(/&/g, "%26");
	} else {
		eVal = encodeURIComponent(message);
		eVal = eVal.replace(/~/g, "%7E");
		eVal = eVal.replace(/!/g, "%21");
		eVal = eVal.replace(/\(/g, "%28");
		eVal = eVal.replace(/\)/g, "%29");
		eVal = eVal.replace(/'/g, "%27");
		eVal = eVal.replace(/"/g, "%22");
		eVal = eVal.replace(/`/g, "%27");
		eVal = eVal.replace(/&/g, "%26");
	}
	return eVal; //.replace(/\%20/g, "+");
};

/**
 * Sends a request to the backend and calls a callback function with the results
 * @param {string} request - The request to send
 * @param {function|null} [callbackFn] - type (string) -> (), called with the response from the backend
 * @param {function|null} [callbackErr] - type ([number], [string]) -> (), called with the error status code and message
 * @param {boolean} [isPost=false] - Whether a post request should be used instead of a get request
 * @param {string|null} [postData] - The post data to send in the body of the request
 * @param {boolean} [isBluetoothBlock=false] - Whether the command is a bluetooth command issued by a Block.
 *                                             Used for sorting native calls on iOS
 */
HtmlServer.sendRequestWithCallback = function(request, callbackFn, callbackErr, isPost, postData, isBluetoothBlock) {
	callbackFn = DebugOptions.safeFunc(callbackFn);
	callbackErr = DebugOptions.safeFunc(callbackErr);
	if (DebugOptions.shouldLogHttp()) {
		// Requests are logged for debugging
		GuiElements.alert(HtmlServer.getUrlForRequest(request));
	}
	if (DebugOptions.shouldSkipHtmlRequests()) {
		// If we're testing on a device without a backend, we reply with a fake response
		setTimeout(function() {
			HtmlServer.unansweredCount--;
			if (false) {
				// We can respond with a fake error
				if (callbackErr != null) {
					callbackErr(418, "I'm a teapot");
				}
			} else {
				// Or with fake data
				if (callbackFn != null) {
					//callbackFn('Started');
					callbackFn('{"files":["project1","project2"],"signedIn":true,"account":"101010tw42@gmail.com"}');
					//callbackFn('[{"name":"hi","id":"there"}]');
					//callbackFn('{"availableName":"test","alreadySanitized":true,"alreadyAvailable":true,"files":["project1","project2"]}');
				}
			}
		}, 20);
		HtmlServer.unansweredCount++;
		return;
	}
	if (isPost == null) {
		isPost = false;
	}
	if (HtmlServer.iosHandler != null) {
		HtmlServer.sendNativeIosCall(request, callbackFn, callbackErr, isPost, postData, isBluetoothBlock);
		return;
	}
	let requestType = "GET";
	if (isPost) {
		requestType = "POST";
	}
	try {
		const xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (xhttp.readyState === 4) {
				HtmlServer.unansweredCount--;
				if (200 <= xhttp.status && xhttp.status <= 299) {
					if (callbackFn != null) {
						callbackFn(xhttp.responseText);
					}
				} else {
					if (callbackErr != null) {
						if (DebugOptions.shouldLogHttp()) {
							// Show the error on the screen
							GuiElements.alert("HTTP ERROR: " + xhttp.status + ", RESP: " + xhttp.responseText);
						}
						callbackErr(xhttp.status, xhttp.responseText);
					}
				}
			}
		};
		xhttp.open(requestType, HtmlServer.getUrlForRequest(request), true);
		if (isPost) {
			xhttp.setRequestHeader("Content-type", "text/plain; charset=utf-8");
			xhttp.send(postData);
		} else {
			xhttp.send();
		}
		HtmlServer.unansweredCount++;
	} catch (err) {
		if (callbackErr != null) {
			callbackErr(0, "Sending request failed");
		}
	}
};

/**
 * Sends a request and changes fields of a status object to track its progress.  Used for executing blocks
 * @param {string} request - The request to send
 * @param {object} requestStatus - The status object
 * @param {boolean} [isBluetoothBlock=false] - Whether the command is a bluetooth command issued by a Block.
 */
HtmlServer.sendRequest = function(request, requestStatus, isBluetoothBlock) {
	if (requestStatus != null) {
		requestStatus.error = false;
		const callbackFn = function(response) {
			requestStatus.finished = true;
			requestStatus.result = response;
		};
		const callbackErr = function(code, result) {
			requestStatus.finished = true;
			requestStatus.error = true;
			requestStatus.code = code;
			requestStatus.result = result;
		};
		HtmlServer.sendRequestWithCallback(request, callbackFn, callbackErr, false, null, isBluetoothBlock);
	} else {
		HtmlServer.sendRequestWithCallback(request, null, null, false, null, isBluetoothBlock);
	}
};

/**
 * Prepends localhost and the port number to the request
 * @param {string} request - The request to modify
 * @return {string} - The completed request
 */
HtmlServer.getUrlForRequest = function(request) {
	return "http://localhost:" + HtmlServer.port + "/" + request;
};

/**
 * Tells the backend that the frontend is done loading the UI
 */
HtmlServer.sendFinishedLoadingRequest = function() {
	HtmlServer.sendRequestWithCallback("ui/contentLoaded")
};

/**
 * Sends a command through the system iOS provides for allowing JS to call swift functions
 * @param {string} request - The request to send
 * @param {function|null} [callbackFn] - type (string) -> (), called with the response from the backend
 * @param {function|null} [callbackErr] - type ([number], [string]) -> (), called with the error status code and message
 * @param {boolean} [isPost=false] - Whether a post request should be used instead of a get request
 * @param {string|null} [postData] - The post data to send in the body of the request
 * @param {boolean} [isBluetoothBlock=false] - Whether the command is a bluetooth command issued by a Block.
 */
HtmlServer.sendNativeIosCall = function(request, callbackFn, callbackErr, isPost, postData, isBluetoothBlock) {
	GuiElements.alert("Sending: " + request + " using native");
	if(isBluetoothBlock == null) {
		isBluetoothBlock = false;
	}

	let id = null;
	while (id == null || HtmlServer.iosRequests[id] != null) {
		id = "requestId" + Math.random();
	}
	const requestObject = {};
	requestObject.request = request;
	if (isPost) {
		requestObject.body = postData;
	} else {
		requestObject.body = "";
	}
	requestObject.id = id;
	requestObject.inBackground = isBluetoothBlock? "true" : "false";
	HtmlServer.iosRequests[id] = {
		callbackFn: callbackFn,
		callbackErr: callbackErr
	};
	GuiElements.alert("Making request: " + request + " using native");
	HtmlServer.unansweredCount++;
	window.webkit.messageHandlers.serverSubstitute.postMessage(requestObject);
	GuiElements.alert("Made request: " + request + " using native, inBackground=" + requestObject.inBackground);
	window.setTimeout(function() {
		HtmlServer.responseFromIosCall(id, "0", "");
	}, HtmlServer.requestTimeout);
};

HtmlServer.responseFromIosCall = function(id, status, body) {
	//GuiElements.alert("got resp from native");
	const callbackObj = HtmlServer.iosRequests[id];
	HtmlServer.iosRequests[id] = undefined;
	if (callbackObj == null) {
		return;
	}
	HtmlServer.unansweredCount--;
	if (200 <= status && status <= 299) {
		if (callbackObj.callbackFn != null) {
			callbackObj.callbackFn(body);
		}
	} else {
		if (callbackObj.callbackErr != null) {
			if (DebugOptions.shouldLogHttp()) {
				// Show the error on the screen
				GuiElements.alert("HTTP ERROR: " + status + ", RESP: " +body);
			}
			callbackObj.callbackErr(Number(status), body);
		}
	}
};
/**
 * Sends requests to show dialogs and keeps track of open dialogs
 */
function DialogManager() {
	let DM = DialogManager;
	/* A dialog generated through Block execution must wait this amount before showing another dialog to give
	 * the user a chance to stop the program */
	DM.repeatDialogDelay = 500;
	DM.lastDialogDisplayTime = null;

	DM.dialogVisible = false;
	// The functions to call when a dialog finished
	DM.choiceCallback = null;
	DM.promptCallback = null;
}

/**
 * Checks if enough time has passed since the last dialog was closed to show another dialog.  Only affects dialogs
 * generated using Blocks
 * @return {boolean}
 */
DialogManager.checkDialogDelay = function() {
	let DM = DialogManager;
	let now = new Date().getTime();
	if (DM.dialogVisible) {
		return false;
	}
	return DM.lastDialogDisplayTime == null || now - DM.repeatDialogDelay >= DM.lastDialogDisplayTime;
};

/**
 * Sets the time a dialog was last closed to now
 */
DialogManager.updateDialogDelay = function() {
	let DM = DialogManager;
	DM.lastDialogDisplayTime = new Date().getTime();
};

/**
 * Shows a dialog with two options
 * @param {string} title - The text at the top of the dialog
 * @param {string} question - The text in the body of the dialog
 * @param {string} option1 - The text on the first button
 * @param {string|null} [option2] - The text on the second button. There will be only one button if left null
 * @param swapIfMouse - Whether the result should be inverted when using the js prompt function for debugging
 * @param callbackFn - type (boolean, string) -> (), the function to call with the result of "1", "2", or "cancelled"
 * @param callbackErr - type () -> (), the function to call if showing the dialog fails
 */
DialogManager.showChoiceDialog = function(title, question, option1, option2, swapIfMouse, callbackFn, callbackErr) {
	const DM = DialogManager;
	if (DM.dialogVisible) {
		// If there's already a dialog, call the fail function
		if (callbackErr != null) callbackErr();
		return;
	}
	TouchReceiver.touchInterrupt();
	DM.dialogVisible = true;
	if (DebugOptions.shouldUseJSDialogs()) { //Kept for debugging on a PC
		let result = confirm(question);
		DM.dialogVisible = false;
		if (swapIfMouse) {
			result = !result;
		}
		if (result) {
			callbackFn("1");
		} else {
			callbackFn("2");
		}
	} else {
		const HS = HtmlServer;
		const request = new HttpRequestBuilder("tablet/choice");
		request.addParam("title", title);
		request.addParam("question", question);
		request.addParam("button1", option1);
		if (option2 != null) {
			request.addParam("button2", option2);
		}
		const onDialogPresented = function() {
			DM.choiceCallback = callbackFn;
		};
		const onDialogFail = function() {
			DM.dialogVisible = false;
			if (callbackErr != null) {
				callbackErr();
			}
		};
		HS.sendRequestWithCallback(request.toString(), onDialogPresented, onDialogFail);
	}
};

/**
 * Calls the callback with the result
 * @param {boolean} [cancelled] - Whether the user closed the dialog without answering
 * @param {boolean} [firstSelected] - Whether the user selected the first option
 */
DialogManager.choiceDialogResponded = function(cancelled, firstSelected) {
	const DM = DialogManager;
	DM.dialogVisible = false;
	if (DM.choiceCallback != null) {
		let resp;
		if (cancelled) {
			resp = "cancelled";
		} else if (firstSelected) {
			resp = "1";
		} else {
			resp = "2";
		}
		DM.choiceCallback(resp);
	}
	DM.choiceCallback = null;
};

/**
 * Shows a prompt dialog that the user can enter text into
 * @param {string} title - The text to show in the top of the dialog
 * @param {string} question - The text to show in the body of the dialog
 * @param {string} prefill - (possibly "") The text that should already be in the dialog
 * @param {boolean} shouldPrefill - Whether the prefill text should be gray, uneditable hint text, or prefilled,
 *                                  selected text
 * @param {function} [callbackFn] - type (boolean, string) -> (), Called with the user's response
 * @param {function} [callbackErr] - type () -> (), Called if showing the dialog causes an error
 */
DialogManager.showPromptDialog = function(title, question, prefill, shouldPrefill, callbackFn, callbackErr) {
	const DM = DialogManager;
	if (DM.dialogVisible) {
		// Dialog is already visible so we throw an error.
		if (callbackErr != null) callbackErr();
		return;
	}
	TouchReceiver.touchInterrupt();
	DM.dialogVisible = true;
	if (DebugOptions.shouldUseJSDialogs()) { //Kept for debugging on a PC
		const newText = prompt(question);
		DM.dialogVisible = false;
		callbackFn(newText == null, newText);
	} else {
		const HS = HtmlServer;
		const request = new HttpRequestBuilder("tablet/dialog");
		request.addParam("title", title);
		request.addParam("question", question);
		if (shouldPrefill) {
			request.addParam("prefill", prefill);
		} else {
			request.addParam("placeholder", prefill);
		}
		request.addParam("selectAll", "true");
		const onDialogPresented = function(result) {
			DM.promptCallback = callbackFn;
		};
		const onDialogFail = function() {
			DM.dialogVisible = false;
			if (callbackErr != null) {
				callbackErr();
			}
		};
		HS.sendRequestWithCallback(request.toString(), onDialogPresented, onDialogPresented);
	}
};

/**
 * Calls the callback for prompt dialogs with the result
 * @param {boolean} cancelled - Whether the closed the dialog without responding
 * @param {string} [response] - The user's response to the prompt
 */
DialogManager.promptDialogResponded = function(cancelled, response) {
	const DM = DialogManager;
	DM.dialogVisible = false;
	DM.updateDialogDelay();   // Tell DialogManager to reset the dialog delay clock.
	if (DM.promptCallback != null) {
		DM.promptCallback(cancelled, response);
	}
	DM.promptCallback = null;
};

/**
 * Shows a dialog with a single button to alert the user of something
 * @param {string} title - The text at the top of the dialog
 * @param {string} message - The text in the body of the dialog
 * @param {string} button - The text on the dismiss button
 * @param {function} [callbackFn] - type () -> (), called when the dialog is dismissed
 * @param {function} [callbackErr] - type () -> (), called if displaying the dialog fails
 */
DialogManager.showAlertDialog = function(title, message, button, callbackFn, callbackErr) {
	if (DebugOptions.shouldUseJSDialogs()) {
		alert(message);
		if (callbackFn != null) callbackFn();
		return;
	}
	DialogManager.showChoiceDialog(title, message, button, null, true, callbackFn, callbackErr);
};
/**
 * The CallBackManager is a static classes that allows the backend to initiate JS actions.  All string parameters
 * sent through callbacks must be percent encoded for safely, as the backend run these methods using string
 * concatenation.  They all return a boolean indicating if the callback ran without error.  A result of true means
 * everything worked, while false indicates the request was bad, unimplemented, or encountered an error.
 */
function CallbackManager(){

}

CallbackManager.sounds = {};
/**
 * Called when recording stops unexpectedly
 * @return {boolean}
 */
CallbackManager.sounds.recordingEnded = function(){
	RecordingManager.interruptRecording();
	return true;
};
/**
 * Called when permission to record is granted by the user
 * @return {boolean}
 */
CallbackManager.sounds.permissionGranted = function(){
	RecordingManager.permissionGranted();
	return true;
};
/**
 * Called to notify the frontend that the list of recordings has changed
 * @returns {boolean}
 */
CallbackManager.sounds.recordingsChanged = function(){
	Sound.loadSounds(true);
	RecordingDialog.recordingsChanged();
	return true;
};

CallbackManager.data = {};
/**
 * Tells the frontend to open a file with the specified name and data
 * @param {string} fileName - The percent encoded name of the file
 * @param {string} data - The percent encoded content of the file
 * @return {boolean}
 */
CallbackManager.data.open = function(fileName, data) {
	fileName = HtmlServer.decodeHtml(fileName);
	data = HtmlServer.decodeHtml(data);
	SaveManager.backendOpen(fileName, data);
	return true;
};
/**
 * Sets the name of the currently open file (when there is a rename request, for example)
 * @param {string} fileName - The percent encoded new name of the file
 * @return {boolean}
 */
CallbackManager.data.setName = function(fileName){
	fileName = HtmlServer.decodeHtml(fileName);
	SaveManager.backendSetName(fileName);
	return true;
};
/**
 * Closes the current file and opens the blank file
 * @return {boolean}
 */
CallbackManager.data.close = function(){
	SaveManager.backendClose();
	return true;
};
/**
 * Tells the frontend to lock the UI and show Loading... until the file loads (or 1 sec passes)
 * @return {boolean}
 */
CallbackManager.data.markLoading = function(){
	SaveManager.backendMarkLoading();
	return true;
};
/**
 * Tells the frontend to reload the OpenDialog if it is open because the local files have changed
 * @return {boolean}
 */
CallbackManager.data.filesChanged = function(){
	OpenDialog.filesChanged();
	return true;
};

CallbackManager.cloud = {};
/**
 * Tells the frontend to reload the OpenCloudDialog if it is open because the cloud files have changed
 * @param {string} newFiles - A percent encoded JSON object containing the new list of files
 * @return {boolean}
 */
CallbackManager.cloud.filesChanged = function(newFiles){
	newFiles = HtmlServer.decodeHtml(newFiles);
	OpenCloudDialog.filesChanged(newFiles);
	return true;
};
/**
 * Tells the frontend that a cloud file have finished downloading
 * @param filename - The percent encoded file that has finished downloading
 * @return {boolean}
 */
CallbackManager.cloud.downloadComplete = function(filename) {
	filename = HtmlServer.decodeHtml(filename);
	OpenDialog.filesChanged();
	return true;
};
/**
 * Tells the frontend that the user has just signed in, so the OpenDialog needs to be reloaded if open
 * @return {boolean}
 */
CallbackManager.cloud.signIn = function(){
	OpenDialog.filesChanged();
	OpenCloudDialog.filesChanged();
	return true;
};

CallbackManager.dialog = {};
/**
 * Tells the frontend that the user has just closed a prompt dialog
 * @param {boolean} cancelled - Whether the dialog was cancelled or closed without being answered
 * @param {string} [response] - The percent encoded string containing the user's response (or null/undefined if N/A)
 * @return {boolean}
 */
CallbackManager.dialog.promptResponded = function(cancelled, response){
	if(response != null) {
		response = HtmlServer.decodeHtml(response);
	}
	DialogManager.promptDialogResponded(cancelled, response);
	return true;
};
/**
 * Tells the frontend that the user has just closed a choice dialog or alert dialog
 * @param {boolean} cancelled - Whether the dialog was closed without being answered
 * @param {boolean} firstSelected - Whether the first option was selected
 * @return {boolean}
 */
CallbackManager.dialog.choiceResponded = function(cancelled, firstSelected){
	DialogManager.choiceDialogResponded(cancelled, firstSelected);
	return true;
};

CallbackManager.robot = {};
/**
 * Tells the frontend whether the specified robot is in good communication with the backend over bluetooth
 * @param {string} robotId - The percent encoded id of the robot
 * @param {boolean} isConnected - Whether the backend is able to communicate with the robot
 * @return {boolean}
 */
CallbackManager.robot.updateStatus = function(robotId, isConnected){
	robotId = HtmlServer.decodeHtml(robotId);
	DeviceManager.updateConnectionStatus(robotId, isConnected);
	return true;
};
/**
 * Tells the frontend that a robot has just been disconnected because it has incompatible firmware
 * @param {string} robotId - The percent encoded id of the robot
 * @param {string} oldFirmware - The percent encoded version of firmware that was on the robot
 * @param {string} minFirmware - The percent encoded minimum version of firmware the backend requires
 */
CallbackManager.robot.disconnectIncompatible = function(robotId, oldFirmware, minFirmware) {
	robotId = HtmlServer.decodeHtml(robotId);
	oldFirmware = HtmlServer.decodeHtml(oldFirmware);
	minFirmware = HtmlServer.decodeHtml(minFirmware);
	DeviceManager.disconnectIncompatible(robotId, oldFirmware, minFirmware);
};
/**
 * Tells the frontend that the status of a robot's firmware
 * @param {string} robotId - The percent encoded id of the robot
 * @param {string} status - The percent encoded string "upToDate", "old", or "incompatible"
 * @return {boolean}
 */
CallbackManager.robot.updateFirmwareStatus = function(robotId, status) {
	robotId = HtmlServer.decodeHtml(robotId);
	status = HtmlServer.decodeHtml(status);
	const statuses = Device.firmwareStatuses;
	let firmwareStatus;
	if(status === "upToDate") {
		firmwareStatus = statuses.upToDate;
	} else if(status === "old") {
		firmwareStatus = statuses.old;
	} else if(status === "incompatible") {
		firmwareStatus = statuses.incompatible;
	} else {
		return false;
	}
	DeviceManager.updateFirmwareStatus(robotId, firmwareStatus);
	return true;
};
/**
 * Tells the frontend that a device has just been discovered
 * @param {string} robotTypeId - The percent encoded type of robot being scanned for
 * @param {string} robotList - A percent encoded JSON array of discovered devices
 * @return {boolean}
 */
CallbackManager.robot.discovered = function(robotTypeId, robotList){
	robotTypeId = HtmlServer.decodeHtml(robotTypeId);
	robotList = HtmlServer.decodeHtml(robotList);
	DeviceManager.backendDiscovered(robotTypeId, robotList);
	return true;
};
/**
 * Tells the frontend that the discover timed out so the frontend has a chance to start the discover again.
 * @param {string} robotTypeId - The percent encoded type of robot being scanned for
 * @return {boolean}
 */
CallbackManager.robot.discoverTimeOut = function(robotTypeId) {
	robotTypeId = HtmlServer.decodeHtml(robotTypeId);
	DeviceManager.possiblyRescan(robotTypeId);
	return true;
};
/**
 * Tells the frontend that the backend has stopped scanning for devices. The frontend might start the scan again.
 * @param {string} robotTypeId - The percent encoded type of robot being scanned for
 * @return {boolean}
 */
CallbackManager.robot.stopDiscover = function(robotTypeId) {
	robotTypeId = HtmlServer.decodeHtml(robotTypeId);
	DeviceManager.possiblyRescan(robotTypeId);
	return true;
};

CallbackManager.tablet = {};
/**
 * Tells the frontend which sensors the backend supports
 * @param {string} sensorList - A non percent encoded, return separated list of supported sensors
 * @return {boolean}
 */
CallbackManager.tablet.availableSensors = function(sensorList){
	TabletSensors.updateAvailable(sensorList);
	return true;
};
/**
 * Tells the frontend that the backend supports a specific sensor
 * @param {string} sensor - A non percent encoded string representing the supported sensor
 * @return {boolean} - Whether the sensor string was valid
 */
CallbackManager.tablet.addSensor = function(sensor){
	return TabletSensors.addSensor(sensor);
};
/**
 * Tells the frontend that the backend does not support a specific sensor
 * @param {string} sensor - A non percent encoded string representing the unsupported sensor
 * @return {boolean} - Whether the sensor string was valid
 */
CallbackManager.tablet.removeSensor = function(sensor){
	return TabletSensors.removeSensor(sensor);
};

/**
 * Tells the frontend to tell the backend something.  Exists because certain functions in that backend can't access
 * each other easily.  This wasn't my idea and I will take no responsibility for this function's existence.
 * @param {string} request - The percent encoded string representing request the backend wants the frontend to make
 */
CallbackManager.echo = function(request){
	// decode the request
	request = HtmlServer.decodeHtml(request);
	/* Send it back.  Hopefully it has all its parameters percent encoded already.  That means the backend needs
	 * to percent encode each parameter individually, and then percent encode the entire string again to pass it
	 * to this function. */
	HtmlServer.sendRequestWithCallback(request);
};

/**
 * Receives the backend's response to a native call
 * @param {string} id - The non percent encoded id of the request
 * @param {string} status - The non percent encoded status code
 * @param {string} body - The percent encoded response from the backend
 */
CallbackManager.httpResponse = function(id, status, body) {
	if (body != null) {
		body = HtmlServer.decodeHtml(body);
	}
	HtmlServer.responseFromIosCall(id, status, body);
};
/**
 * Static class that helps parse and write XML files
 */
function XmlWriter() {

}

/**
 * Creates ax XML document with the the specified tag
 * @param {string} tagName - The root tag
 * @return {Document} - An XML document to write to
 */
XmlWriter.newDoc = function(tagName) {
	tagName = XmlWriter.escape(tagName);
	const xmlString = "<" + tagName + "></" + tagName + ">";
	const parser = new DOMParser();
	return parser.parseFromString(xmlString, "text/xml");
};

/**
 * Creates a tag in the XML document.  It doesn't have a parent yet.  appendChild is used to do that.
 * @param {Document} xmlDoc - The document to create the tag in
 * @param {string} tagName - The name of the tag to create
 * @return {Element} - The resulting element
 */
XmlWriter.createElement = function(xmlDoc, tagName) {
	tagName = XmlWriter.escape(tagName);
	return xmlDoc.createElement(tagName);
};

/**
 * Sets an attribute of an element to a value.  Automatically escapes the value before doing so.
 * @param {Element} element
 * @param {string} name - The name of the attribute
 * @param {string} value - The value to set
 */
XmlWriter.setAttribute = function(element, name, value) {
	name = XmlWriter.escape(name);
	value = XmlWriter.escape(value);
	element.setAttribute(name, value);
};

/**
 * Creates a text node that contains data and can be added as a child of another tag
 * @param {Document} xmlDoc - The document to create the nod in
 * @param {string} data - The text to store; will be escaped
 * @return {Text}
 */
XmlWriter.createTextNode = function(xmlDoc, data) {
	data = XmlWriter.escape(data);
	return xmlDoc.createTextNode(data);
};

/**
 * Escapes text to be stored in text nodes and attributes.  Some automatic escaping is applied by the browser, but
 * this is just to be safe.  You may notice that some of these characters end up double escaped in the file.
 * @param {string} string - The string to escape
 * @return {string}
 */
XmlWriter.escape = function(string) {
	string = string + "";
	string = string.replace(/&/g, '&amp;');
	string = string.replace(/</g, '&lt;');
	string = string.replace(/>/g, '&gt;');
	string = string.replace(/"/g, '&quot;');
	string = string.replace(/'/g, '&apos;');
	string = string.replace(/ /g, '&#32;');
	return string;
};

/**
 * Unescapes the text in the XML file
 * @param {string} string
 * @return {string}
 */
XmlWriter.unEscape = function(string) {
	string = string + "";
	string = string.replace(/&#32;/g, ' ');
	string = string.replace(/&apos;/g, "'");
	string = string.replace(/&quot;/g, '"');
	string = string.replace(/&gt;/g, '>');
	string = string.replace(/&lt;/g, '<');
	string = string.replace(/&amp;/g, '&');
	return string;
};

/**
 * Opens the contents of an XML file in a new window.  Used for debugging
 * @param {Document} xmlDoc - The document to open
 */
XmlWriter.downloadDoc = function(xmlDoc) {
	window.open('data:text/xml,' + HtmlServer.encodeHtml(XmlWriter.docToText(xmlDoc)));
};

/**
 * Creates a Document from an XML string
 * @param {string} xmlString
 * @return {Document}
 */
XmlWriter.openDoc = function(xmlString) {
	const parser = new DOMParser();
	return parser.parseFromString(xmlString, "text/xml");
};

/**
 * Finds a tag in the document with the specified name
 * @param {Document} xmlDoc - The document to search
 * @param {string} tagName - The name of the tag to search for
 * @return {null|Node} - The node or null if no tag has that name
 */
XmlWriter.findElement = function(xmlDoc, tagName) {
	tagName = XmlWriter.escape(tagName);
	const results = xmlDoc.getElementsByTagName(tagName);
	if (results.length === 0) {
		return null;
	}
	return results[0];
};

/**
 * Finds children of the provided node with the specified name.
 * @param {Node} node
 * @param {string} tagName - The tag to look for
 * @return {Array<Node>} - All children with a matching name
 */
XmlWriter.findSubElements = function(node, tagName) {
	if (node == null) {
		return [];
	}
	const children = node.childNodes;
	const results = [];
	for (let i = 0; i < children.length; i++) {
		if (children[i].nodeType === 1 && children[i].nodeName === tagName) {
			results.push(children[i]);
		}
	}
	return results;
};

/**
 * Finds any child of the provided tag with the specified name
 * @param {Node} node - The node to examine
 * @param {string} tagName - The name to find
 * @return {Node|null}
 */
XmlWriter.findSubElement = function(node, tagName) {
	if (node == null) {
		return null;
	}
	const children = node.childNodes;
	for (let i = 0; i < children.length; i++) {
		if (children[i].nodeType === 1 && children[i].nodeName === tagName) {
			return children[i];
		}
	}
	return null;
};

/**
 * Reads an attribute of a node
 * @param {Node} element
 * @param {string} name - The name of the attribute
 * @param {*} [defaultVal] - The value to return if the attribute isn't found
 * @param {boolean} [isNum=false] - Whether the result should be converted to a number
 * @return {*}
 */
XmlWriter.getAttribute = function(element, name, defaultVal, isNum) {
	if (isNum == null) {
		isNum = false;
	}
	if (defaultVal == null) {
		defaultVal = null;
	}
	let val = element.getAttribute(XmlWriter.escape(name));
	if (val == null) {
		return defaultVal;
	}
	val = XmlWriter.unEscape(val);
	if (isNum) {
		const numData = (new StringData(val)).asNum();
		if (numData.isValid) {
			return numData.getValue();
		}
		return defaultVal;
	}
	return val;
};

/**
 * Read a text node from a element
 * @param {Node} element
 * @param {string} name - The name of the text node
 * @param {string|null|number} [defaultVal=null] - The value to return if there is no text node
 * @param {boolean} isNum - Whether the result should be converted to a number
 * @return {string|null|number}
 */
XmlWriter.getTextNode = function(element, name, defaultVal, isNum) {
	if (isNum == null) {
		isNum = false;
	}
	if (defaultVal == null) {
		defaultVal = null;
	}
	const innerNode = XmlWriter.findSubElement(element, name);
	if (innerNode == null) {
		return defaultVal;
	}
	const childNodes = innerNode.childNodes;
	if (childNodes.length >= 1 && childNodes[0].nodeType === 3) {
		let val = childNodes[0].nodeValue;
		if (val == null) {
			return defaultVal;
		}
		val = XmlWriter.unEscape(val);
		if (isNum) {
			const numData = (new StringData(val)).asNum();
			if (numData.isValid) {
				return numData.getValue();
			}
			return defaultVal;
		}
		return val;
	} else if (childNodes.length === 0) {
		return "";
	}
	return defaultVal;
};

/**
 * Convert an XML document into text
 * @param {Document} xmlDoc
 * @return {string}
 */
XmlWriter.docToText = function(xmlDoc) {
	const serializer = new XMLSerializer();
	return serializer.serializeToString(xmlDoc);
};

/**
 * Finds a Node from a list of nodes that has an attribute "key" that matches the provided key.  Used for finding
 * Slot nodes with certain keys
 * @param {Array<Node>} nodes
 * @param {string} key
 * @return {null|Node}
 */
XmlWriter.findNodeByKey = function(nodes, key) {
	for (let i = 0; i < nodes.length; i++) {
		const nodeKey = XmlWriter.getAttribute(nodes[i], "key", "");
		if (nodeKey === key) {
			return nodes[i];
		}
	}
	return null;
};
/**
 * Static class for file management.  Tracks the currently open file and deals with saving/opening files.
 */
function SaveManager() {
	// The name of the name, or null when the blank canvas is open
	SaveManager.fileName = null;
	// The file is auto saved any time it is edited and one every few seconds
	SaveManager.autoSaveTimer = new Timer(SaveManager.autoSaveInterval, SaveManager.autoSave);
	SaveManager.autoSaveTimer.start();
}

SaveManager.setConstants = function() {
	//SaveManager.invalidCharacters = "\\/:*?<>|.\n\r\0\"";
	// These characters can't be used in file names
	SaveManager.invalidCharactersFriendly = "\\/:*?<>|.$";
	SaveManager.autoSaveInterval = 1000 * 60;
	SaveManager.newProgName = "New program";
	SaveManager.emptyProgData = "<project><tabs></tabs></project>";
};

/**
 * Called when the backend would like to open a file
 * @param {string} fileName - The name of the file
 * @param {string} data - The content of the file
 * @param {boolean} named - false if the user should be prompted to name the file when they try to use the OpenDialog
 */
SaveManager.backendOpen = function(fileName, data) {
	SaveManager.fileName = fileName;
	SaveManager.loadData(data);
	OpenDialog.closeDialog();
	GuiElements.unblockInteraction();
};

/**
 * Reads the file contents from the XML
 * @param {string} data - A string of XML data
 * TODO: Provide a way for loading to fail if critical tags are missing rather than opening a blank document
 */
SaveManager.loadData = function(data) {
	if (data.length > 0) {
		if (data.charAt(0) === "%") {
			// The data haas an extra layer of encoding that needs to be removed
			data = decodeURIComponent(data);
		}
		const xmlDoc = XmlWriter.openDoc(data);
		const project = XmlWriter.findElement(xmlDoc, "project");
		if (project == null) {
			// There's no project tag.  The data is seriously corrupt, so we just open an empty file
			SaveManager.loadData(SaveManager.emptyProgData);
		} else {
			(DebugOptions.safeFunc(CodeManager.importXml))(project);
		}
	} else {
		// There's no data at all, so open an empty file
		SaveManager.loadData(SaveManager.emptyProgData);
	}
};

/**
 * Changes the name of the open file to match the provided name
 * @param {string} fileName
 */
SaveManager.backendSetName = function(fileName) {
	SaveManager.fileName = fileName;
	TitleBar.setText(fileName);
	CodeManager.markOpen();
};

/**
 * Clears the canvas and shows an Open Dialog
 */
SaveManager.backendClose = function() {
	SaveManager.loadBlank();
	OpenDialog.showDialog();
};

/**
 * Shows that a file is loading
 */
SaveManager.backendMarkLoading = function() {
	OpenDialog.closeDialog();
	CodeManager.markLoading("Loading...");
};

/**
 * Loads a blank canvas
 */
SaveManager.loadBlank = function() {
	SaveManager.fileName = null;
	SaveManager.loadData(SaveManager.emptyProgData);
};

/**
 * Closes the open file and notifies the backend
 * @param {function} nextAction
 */
SaveManager.userClose = function(nextAction) {
	SaveManager.loadBlank();
	const request = new HttpRequestBuilder("data/close");
	HtmlServer.sendRequestWithCallback(request.toString(), nextAction);
};

/**
 * Prompts the user for a name for the new file, creates it, and opens it (when the backend says it's loaded)
 * @param {function} [nextAction]
 */
SaveManager.userNew = function(nextAction) {
	SaveManager.promptNewFile("Enter file name", nextAction);
};

/**
 * Prompts the user for the file to create. Finds a good default name and prefills the dialog with that.
 * @param {string} message - The message to show in the body of the prompt
 * @param {function} [nextAction]
 */
SaveManager.promptNewFile = function(message, nextAction) {
	SaveManager.getAvailableName(SaveManager.newProgName, function(availableName, alreadySanitized, alreadyAvailable) {
		SaveManager.promptNewFileWithDefault(message, availableName, nextAction);
	});
};

/**
 * Prompts the user for the name of the file to create. Prefills the dialog with the default name
 * @param {string} message - The message to show in the body of the prompt
 * @param {string} defaultName - The name to prefill
 * @param {function} [nextAction]
 */
SaveManager.promptNewFileWithDefault = function(message, defaultName, nextAction) {
	DialogManager.showPromptDialog("New", message, defaultName, true, function(cancelled, response) {
		if (!cancelled) {
			SaveManager.sanitizeNew(response.trim(), nextAction);
		}
	});
};

/**
 * Verifies with the backend that the proposed name is valid for a new file and creates it. Prompts user otherwise
 * @param {string} proposedName - The name to check
 * @param {function} [nextAction]
 */
SaveManager.sanitizeNew = function(proposedName, nextAction) {
	if (proposedName === "") {
		const message = "Name cannot be blank. Enter a file name.";
		SaveManager.promptNewFile(message, nextAction);
	} else {
		GuiElements.alert("getting name");
		SaveManager.getAvailableName(proposedName, function(availableName, alreadySanitized, alreadyAvailable) {
			GuiElements.alert("Got available name" + availableName + "," + alreadySanitized + "," + alreadyAvailable);
			if (alreadySanitized && alreadyAvailable) {
				SaveManager.newSoft(availableName, nextAction);
			} else if (!alreadySanitized) {
				GuiElements.alert("not sanitized" + availableName + "," + alreadySanitized + "," + alreadyAvailable);
				let message = "The following characters cannot be included in file names: \n";
				message += SaveManager.invalidCharactersFriendly.split("").join(" ");
				SaveManager.promptNewFileWithDefault(message, availableName, nextAction);
			} else if (!alreadyAvailable) {
				let message = "\"" + proposedName + "\" already exists.  Enter a different name.";
				SaveManager.promptNewFileWithDefault(message, availableName, nextAction);
			}
		});
	}
};

/**
 * Creates a new file with the given name, clears the canvas, and shows "Saving..." until the document is opened.
 * @param {string} filename - The already validated name to save the file as
 * @param {function} [nextAction]
 */
SaveManager.newSoft = function(filename, nextAction) {
	const request = new HttpRequestBuilder("data/new");
	request.addParam("filename", filename);
	SaveManager.loadBlank();
	CodeManager.markLoading("Saving...");
	// If the saving fails, we show the open dialog so the user can try again.
	HtmlServer.sendRequestWithCallback(request.toString(), nextAction, null, true, SaveManager.emptyProgData);
};

/**
 * Sends the current file's data to the backend to save
 * @param {function} [nextAction] - The function to call once the data is successfully sent
 */
SaveManager.autoSave = function(nextAction) {
	if (SaveManager.fileName == null) {
		if (nextAction != null) nextAction();
		return;
	}
	const xmlDocText = XmlWriter.docToText(CodeManager.createXml());
	const request = new HttpRequestBuilder("data/autoSave");
	HtmlServer.sendRequestWithCallback(request.toString(), nextAction, null, true, xmlDocText);
};

/**
 * Tells the backend to open the specified file.  The backend will call CallbackManager.data.open with the data.
 * @param {string} fileName - The file to open
 */
SaveManager.userOpenFile = function(fileName) {
	const request = new HttpRequestBuilder("data/open");
	request.addParam("filename", fileName);
	CodeManager.markLoading("Loading...");
	HtmlServer.sendRequestWithCallback(request.toString(), function() {

	}, function() {
		CodeManager.cancelLoading();
	});
};

/**
 * Prompts the user for a name for the file
 * @param {boolean} isRecording - Whether the file is actually a recording (this reduces redundancy since the dialogs
 *                                are the same
 * @param {string} oldFilename - The name of the file to rename
 * @param {function} nextAction - The function to call after the rename is done and succeeds
 */
SaveManager.userRenameFile = function(isRecording, oldFilename, nextAction) {
	// We use the default message with the title "Name"
	SaveManager.promptRename(isRecording, oldFilename, "Name", null, nextAction);
};

/**
 * Prompts the user to rename a file, with the specified title and message for the dialog
 * @param {boolean} isRecording
 * @param {string} oldFilename
 * @param {string} title - The title of the prompt dialog
 * @param {string|null} [message] - The message for the dialog
 * @param {function} nextAction
 */
SaveManager.promptRename = function(isRecording, oldFilename, title, message, nextAction) {
	// We prefill the old filename
	SaveManager.promptRenameWithDefault(isRecording, oldFilename, title, message, oldFilename, nextAction);
};

/**
 * Prompts the user to rename a file, with the specified suggested name prefilled.
 * @param {boolean} isRecording
 * @param {string} oldFilename
 * @param {string} title
 * @param {string|null} [message="Enter a file name"]
 * @param {string} defaultName - The name to prefill into the dialog
 * @param {function} nextAction
 */
SaveManager.promptRenameWithDefault = function(isRecording, oldFilename, title, message, defaultName, nextAction) {
	if (message == null) {
		message = "Enter a file name";
	}
	// We ask for a new name
	DialogManager.showPromptDialog(title, message, defaultName, true, function(cancelled, response) {
		if (!cancelled) {
			// We see if that name is ok
			SaveManager.sanitizeRename(isRecording, oldFilename, title, response.trim(), nextAction);
		}
	});
};

/**
 * Checks if a name is legitimate and renames the current file to that name if it is.
 * @param {boolean} isRecording
 * @param {string} oldFilename
 * @param {string} title
 * @param {string} proposedName - The name to check
 * @param {function} nextAction
 */
SaveManager.sanitizeRename = function(isRecording, oldFilename, title, proposedName, nextAction) {
	if (proposedName === "") {
		const message = "Name cannot be blank. Enter a file name.";
		SaveManager.promptRename(isRecording, oldFilename, title, message, nextAction);
	} else if (proposedName === oldFilename) {
		if (!isRecording && SaveManager.fileName === oldFilename) {
			const request = new HttpRequestBuilder("data/markAsNamed");
			HtmlServer.sendRequestWithCallback(request.toString(), nextAction);
		} else {
			if (nextAction != null) nextAction();
		}
	} else {
		SaveManager.getAvailableName(proposedName, function(availableName, alreadySanitized, alreadyAvailable) {
			if (alreadySanitized && alreadyAvailable) {
				SaveManager.renameSoft(isRecording, oldFilename, title, availableName, nextAction);
			} else if (!alreadySanitized) {
				let message = "The following characters cannot be included in file names: \n";
				message += SaveManager.invalidCharactersFriendly.split("").join(" ");
				SaveManager.promptRenameWithDefault(isRecording, oldFilename, title, message, availableName, nextAction);
			} else if (!alreadyAvailable) {
				let message = "\"" + proposedName + "\" already exists.  Enter a different name.";
				SaveManager.promptRenameWithDefault(isRecording, oldFilename, title, message, availableName, nextAction);
			}
		}, isRecording);
	}
};

/**
 * Tries to rename the file, does nothing if it fails
 * @param {boolean} isRecording
 * @param {string} oldFilename
 * @param {string} title - The title of the dialog to use if the renaming fails
 * @param {string} newName
 * @param {function} nextAction
 */
SaveManager.renameSoft = function(isRecording, oldFilename, title, newName, nextAction) {
	const request = new HttpRequestBuilder("data/rename");
	request.addParam("oldFilename", oldFilename);
	request.addParam("newFilename", newName);
	SaveManager.addTypeToRequest(request, isRecording);
	let callback = nextAction;
	if (isRecording) {
		callback = function() {
			CodeManager.renameRecording(oldFilename, newName);
			if (nextAction != null) nextAction();
		}
	}
	HtmlServer.sendRequestWithCallback(request.toString(), callback);
};

/**
 * Prompts the user to delete a file
 * @param {boolean} isRecording - Whether the file is actually a recording (to reduce redundant code)
 * @param {string} filename - The name of the file to delete
 * @param {function} nextAction - The action to perform if the file is deleted successfully
 */
SaveManager.userDeleteFile = function(isRecording, filename, nextAction) {
	const question = "Are you sure you want to delete \"" + filename + "\"?";
	DialogManager.showChoiceDialog("Delete", question, "Cancel", "Delete", true, function(response) {
		if (response === "2") {
			SaveManager.delete(isRecording, filename, nextAction);
		}
	}, null);
};

/**
 * Tells the backend to delete a file
 * @param {boolean} isRecording
 * @param {string} filename
 * @param {function} nextAction
 */
SaveManager.delete = function(isRecording, filename, nextAction) {
	const request = new HttpRequestBuilder("data/delete");
	request.addParam("filename", filename);
	SaveManager.addTypeToRequest(request, isRecording);
	let callback = nextAction;
	if (isRecording) {
		callback = function() {
			CodeManager.deleteRecording(filename);
			if (nextAction != null) nextAction();
		}
	}
	HtmlServer.sendRequestWithCallback(request.toString(), callback);
};

/**
 * Checks if a name is a valid name for a file (meaning it is unused and has no illegal characters)
 * @param {string} filename - The name to check
 * @param {function} callbackFn - type (string, boolean, boolean), a function to call with the results
 * @param {boolean} [isRecording=false] - Whether the name should be compared to recordings instead of files
 */
SaveManager.getAvailableName = function(filename, callbackFn, isRecording) {
	if (isRecording == null) {
		isRecording = false;
	}
	DebugOptions.validateNonNull(callbackFn);
	// Ask the backend if the name is ok
	const request = new HttpRequestBuilder("data/getAvailableName");
	request.addParam("filename", filename);
	SaveManager.addTypeToRequest(request, isRecording);
	HtmlServer.sendRequestWithCallback(request.toString(), function(response) {
		let json = {};
		try {
			// Response is a JSON object
			json = JSON.parse(response);
		} catch (e) {

		}
		if (json.availableName != null) {
			/* 3 fields of response:
			 * json.availableName - A name that is close to the filename and is valid (is the filename if filename is ok
			 * json.alreadySanitized - boolean indicating if filename was already sanitized (had no illegal characters)
			 * json.alreadyAvailable - boolean indicating if filename is a unique name
			 * the availableName == filename iff alreadySanitized and alreadyAvailable */
			callbackFn(json.availableName, json.alreadySanitized === true, json.alreadyAvailable === true);
		}
	});
};

/**
 * Prompts the user for a name to duplicate a file
 * @param {string} filename - The name of the file to duplicate
 * @param {function} nextAction - The name of the function to call after successful duplication
 */
SaveManager.userDuplicateFile = function(filename, nextAction) {
	SaveManager.promptDuplicate("Enter name for duplicate file", filename, nextAction);
};

/**
 * Prompts the user to duplicate a file, using the specified message in the dialog
 * @param {string} message - The messsage in the duplicate dialog
 * @param {string} filename
 * @param {function} [nextAction]
 */
SaveManager.promptDuplicate = function(message, filename, nextAction) {
	SaveManager.getAvailableName(filename, function(availableName) {
		SaveManager.promptDuplicateWithDefault(message, filename, availableName, nextAction);
	});
};

/**
 * Prompts the user to duplicate a file with the specified name prefilled
 * @param {string} message
 * @param {string} filename
 * @param {string} defaultName - The name to prefill
 * @param {function} [nextAction]
 */
SaveManager.promptDuplicateWithDefault = function(message, filename, defaultName, nextAction) {
	DialogManager.showPromptDialog("Duplicate", message, defaultName, true, function(cancelled, response) {
		if (!cancelled) {
			SaveManager.sanitizeDuplicate(response.trim(), filename, nextAction);
		}
	});
};

/**
 * Checks if the provided name is valid and duplicates if it is. Otherwise, prompts for a valid name
 * @param {string} proposedName - The name to check
 * @param {string} filename
 * @param {function} [nextAction]
 */
SaveManager.sanitizeDuplicate = function(proposedName, filename, nextAction) {
	if (proposedName === "") {
		SaveManager.promptDuplicate("Name cannot be blank. Enter a file name.", filename, nextAction);
	} else {
		SaveManager.getAvailableName(proposedName, function(availableName, alreadySanitized, alreadyAvailable) {
			if (alreadySanitized && alreadyAvailable) {
				SaveManager.duplicate(filename, availableName, nextAction);
			} else if (!alreadySanitized) {
				let message = "The following characters cannot be included in file names: \n";
				message += SaveManager.invalidCharactersFriendly.split("").join(" ");
				SaveManager.promptDuplicateWithDefault(message, filename, availableName, nextAction);
			} else if (!alreadyAvailable) {
				let message = "\"" + proposedName + "\" already exists.  Enter a different name.";
				SaveManager.promptDuplicateWithDefault(message, filename, availableName, nextAction);
			}
		});
	}
};

/**
 * Duplicates the file with the specified name
 * @param {string} filename
 * @param {string} newName
 * @param {function} [nextAction]
 */
SaveManager.duplicate = function(filename, newName, nextAction) {
	const request = new HttpRequestBuilder("data/duplicate");
	request.addParam("filename", filename);
	request.addParam("newFilename", newName);
	HtmlServer.sendRequestWithCallback(request.toString(), nextAction);
};

/**
 * Handles a request from the user to export a file
 * @param {string} filename - The name of the file to export
 * @param {number} x1
 * @param {number} x2
 * @param {number} y1
 * @param {number} y2
 */
SaveManager.userExportFile = function(filename, x1, x2, y1, y2) {
	SaveManager.exportFile(filename, x1, x2, y1, y2);
};

/**
 * Tells the backend to show an export prompt for the file at the specified location
 * @param {string} filename - The name of the file to export
 * @param {number} x1
 * @param {number} x2
 * @param {number} y1
 * @param {number} y2
 */
SaveManager.exportFile = function(filename, x1, x2, y1, y2) {
	const request = new HttpRequestBuilder("data/export");
	request.addParam("filename", filename);
	if (x1 != null && x2 != null && y1 != null && y2 != null) {
		request.addParam("tlx", x1);
		request.addParam("tly", y1);
		request.addParam("brx", x2);
		request.addParam("bry", y2);
	}
	HtmlServer.sendRequestWithCallback(request.toString());
};

/**
 * Tells the backend to save the provided data as a new document.  The backend calls CallbackManager.data.setName
 * when completed
 */
SaveManager.saveAsNew = function() {
	const request = new HttpRequestBuilder("data/new");
	const xmlDocText = XmlWriter.docToText(CodeManager.createXml());
	CodeManager.markLoading("Saving...");
	HtmlServer.sendRequestWithCallback(request.toString(), function() {

	}, function() {
		CodeManager.cancelLoading();
	}, true, xmlDocText);
};

/**
 * Called any time the document is edited.  Saves changes and creates a new document if no file is open
 */
SaveManager.markEdited = function() {
	CodeManager.updateModified();
	if (SaveManager.fileName != null) {
		SaveManager.autoSave();
	}
};

/**
 * Deprecated function called by the backend to get the contents of the open document
 * @return {object} - With fields for data and filename
 */
SaveManager.currentDoc = function() {
	if (SaveManager.fileName == null) return null;
	const result = {};
	result.data = XmlWriter.docToText(CodeManager.createXml());
	result.filename = SaveManager.fileName;
	return result;
};

/**
 * Saves the current file and prompts the user to name it if it isn't named
 * @param {string} message - The message to use when prompting to name
 * @param {function} [nextAction] - The function to call once the file is saved and named
 */
SaveManager.saveAndName = function(message, nextAction) {
	if (SaveManager.fileName == null) {
		if (nextAction != null) nextAction();
		return;
	}
	SaveManager.autoSave(nextAction);
};

/**
 * Adds a type parameter to the request indicating whether the item is a file or recording
 * @param {HttpRequestBuilder} request - The request to modify
 * @param {boolean} isRecording - Whether the item is a recording instead of a file
 */
SaveManager.addTypeToRequest = function(request, isRecording) {
	request.addParam("type", isRecording ? "recording" : "file");
};

/**
 * Returns whether a file is open
 * @return {boolean}
 */
SaveManager.fileIsOpen = function() {
	return SaveManager.fileName != null;
};
/**
 * The UndoManager is a static class that keeps a stack (as in the data structure) or recently deleted BlockStacks
 * so they can be undeleted.  It can be assigned an undo button, which it will then enable/disable as necessary.
 * The UndoManager stores the deleted BlockStacks as XML nodes.
 */
function UndoManager() {
	const UM = UndoManager;
	UM.undoButton = null;
	UM.undoStack = [];
	UM.undoLimit = 20;
}

/**
 * Assigns a button to the UndoManager, which automatically enables/disables the button and adds the appropriate
 * callback functions
 * @param {Button} button
 */
UndoManager.setUndoButton = function(button) {
	const UM = UndoManager;
	UM.undoButton = button;
	UM.undoButton.setCallbackFunction(UndoManager.undoDelete, true);
	UM.updateButtonEnabled();
};

/**
 * Deletes a BlockStack and adds it to the undo stack.  If the stack is larger than the limit, the last item it removed.
 * @param stack
 */
UndoManager.deleteStack = function(stack) {
	const UM = UndoManager;
	const doc = XmlWriter.newDoc("undoData");
	const stackData = stack.createXml(doc);
	stack.remove();
	UM.undoStack.push(stackData);
	while(UM.undoStack.length > UM.undoLimit) {
		UM.undoStack.shift();
	}
	UM.updateButtonEnabled();
};

/**
 * Pops an item from the stack and rebuilds it, placing it in the corner of the canvas
 */
UndoManager.undoDelete = function(){
	const UM = UndoManager;
	if(UM.undoStack.length === 0) return;
	let success = false;
	while (!success) {
		const stackData = UM.undoStack.pop();
		success = success || TabManager.undoDelete(stackData);
	}
	UM.updateButtonEnabled();
	SaveManager.markEdited();
};

/**
 * Updates the enabled/disabled state of the undo button based in if the stack is empty
 */
UndoManager.updateButtonEnabled = function(){
	const UM = UndoManager;
	if(UM.undoButton == null) return;
	if(UM.undoStack.length > 0) {
		UM.undoButton.enable();
	} else {
		UM.undoButton.disable();
	}
};

/**
 * Deletes the undo stack (for when a program is closed/opened)
 */
UndoManager.clearUndos = function() {
	const UM = UndoManager;
	UM.undoStack = [];
	UM.updateButtonEnabled();
};

/**
 * Block is an abstract class that represents an executable block.
 * Blocks are nearly always contained within BlockStacks or DisplayStacks.
 * Blocks are initially created outside a BlockStacks, but are immediately moved into one.
 * This is because BlockStacks must always contain at least one Block, so the Block must be created first.
 * @constructor
 * TODO: remove the type parameter and use blockShape and instead.
 * @param {number} type - The shape of the Block.  0 = Command, 1 = Reporter, 2 = Predicate, 4 = Hat, 5 = Loop, 6 = DoubleLoop.
 * @param {number} returnType - The type of data the Block returns.  Possible values stored in Block.returnTypes.
 * @param {number} x - The x coord of the Block (relative to the Tab/BlockStack/DisplayStack it is in).
 * @param {number} y - The y coord of the Block.
 * @param {string} category - The Block's category in string form.
 */
function Block(type, returnType, x, y, category) { //Type: 0 = Command, 1 = Reporter, 2 = Predicate Fix! BG
	this.blockTypeName = this.constructor.name; //Keeps track of what type of Block this is.

	this.x = x; //Store coords
	this.y = y;
	this.type = type; //Fix! remove this property
	this.bottomOpen = (type === 0 || type === 4 || type === 5 || type === 6); //Can Blocks be attached to the bottom of this Block?
	this.topOpen = (type === 0 || type === 5 || type === 6); //Can Blocks be attached to the top of this Block?
	this.returnsValue = (returnType !== Block.returnTypes.none); //Does this Block attack to Slots and return a value?
	this.returnType = returnType; //What type of value does this Block return?
	this.hasBlockSlot1 = (type === 5 || type === 6); //Is this Block like an if block that has a special BlockSlot?
	this.hasBlockSlot2 = (type === 6); //Does it have two BlockSlots?
	this.hasHat = (type === 4); //Is it a HatBlock?

	this.group = GuiElements.create.group(x, y); //Make a group to contain the part of this Block.
	this.parent = null; //A Block's parent is the Block/Slot/BlockSlot that it is attached to.  Currently, it has none.
	this.parts = []; //The parts of a Block include its LabelText, BlockIcons, and Slots.
	/** @type {Slot[]} */
	this.slots = []; //The slots array just holds the Slots.
	this.running = 0; //Running: 0 = Not started, 1 = Waiting for slots to finish, 2 = Running, 3 = Completed.
	this.category = category;
	this.isGlowing = false;
	this.active = this.checkActive(); //Indicates if the Block is full color or grayed out (as a result of a missing sensor/robot)

	this.stack = null; //It has no Stack yet.
	this.path = this.generatePath(); //This path is the main visual part of the Block. It is colored based on category.
	this.height = 0; //Will be set later when the Block's dimensions are updated.
	this.lineHeight = []; //For blocks that have parts that wrap to multiple lines.
	this.width = 0;
	this.runMem = function() {}; //serves as a place for the block to store info while running
	if (this.bottomOpen) {
		this.nextBlock = null; //Reference to the Block below this one.
	}
	if (this.returnsValue) {
		this.resultData = null; //Stores the Data to be passed on to the Slot containing this Block.
	}
	if (this.hasBlockSlot1) {
		this.topHeight = 0; //The height of just the top of the Block (where the LabelText and Slots are)
		this.blockSlot1 = new BlockSlot(this);
	}
	if (this.hasBlockSlot2) {
		//The height of the middle part of a DoubleLoopBlock (where the LabelText "else" is on the if/else Block)
		this.midHeight = 0;
		this.midLabel = new LabelText(this, this.midLabelText); //The text to appear in the middle section (i.e. "else");
		this.blockSlot2 = new BlockSlot(this);
	}
}

/**
 * Sets the possible values for Block.returnTypes.
 */
Block.setConstants = function() {
	Block.returnTypes = function() {};
	Block.returnTypes.none = 0; //A command Block always is Block.returnTypes.none.
	Block.returnTypes.num = 1;
	Block.returnTypes.string = 2;
	Block.returnTypes.bool = 3;
	Block.returnTypes.list = 4;
};

/**
 * Converts an x coord relative to the Block to an x coord relative to the screen
 * @param {number} x
 * @returns {number}
 */
Block.prototype.relToAbsX = function(x) {
	if (this.stack != null) {
		return this.stack.relToAbsX(x + this.x);
	}
	return x + this.x;
};
/**
 * Converts a y coord relative to the Block to a y coord relative to the screen
 * @param {number} y
 * @returns {number}
 */
Block.prototype.relToAbsY = function(y) {
	if (this.stack != null) {
		return this.stack.relToAbsY(y + this.y);
	}
	return y + this.y;
};
/**
 * Converts an x coord relative to the screen to an x coord relative to the Block
 * @param x
 * @returns {number}
 */
Block.prototype.absToRelX = function(x) {
	if (this.stack != null) {
		return this.stack.absToRelX(x) - this.x;
	}
	return x - this.x;
};
/**
 * Converts a y coord relative to the screen to a y coord relative to the Block
 * @param y
 * @returns {number}
 */
Block.prototype.absToRelY = function(y) {
	if (this.stack != null) {
		return this.stack.absToRelY(y) - this.y;
	}
	return y - this.y;
};
/**
 * Returns the x coord of the Block relative to the screen (not the group it is contained in).
 * @return {number} - The x coord of the Block relative to the screen.
 */
Block.prototype.getAbsX = function() {
	return this.relToAbsX(0);
};
/**
 * Returns the y coord of the Block relative to the screen.
 * @return {number} - The y coord of the Block relative to the screen.
 */
Block.prototype.getAbsY = function() {
	return this.relToAbsY(0);
};

/**
 * Creates and returns the main SVG path element for the Block.
 * @return {Node} - The main SVG path element for the Block.
 */
Block.prototype.generatePath = function() {
	const pathE = BlockGraphics.create.block(this.category, this.group, this.returnsValue, this.active);
	TouchReceiver.addListenersChild(pathE, this);
	return pathE;
};

/**
 * Adds a part (LabelText, BlockIcon, or Slot) to the Block.
 * @param {LabelText|BlockIcon|Slot} part - part to add.
 */
Block.prototype.addPart = function(part) {
	this.parts.push(part);
	if (part.isSlot) { //Slots are kept track of separately for recursive calls.
		this.slots.push(part);
	}
	part.setActive(this.active);
};

/**
 * Moves the Block and sets its this.x and this.y values.
 * @param {number} x - New x coord.
 * @param {number} y - New y coord.
 */
Block.prototype.move = function(x, y) {
	this.x = x;
	this.y = y;
	//All parts of the Block are contained within its group to allow for easy movement.
	GuiElements.move.group(this.group, x, y);
};

/**
 * Recursively stops the Block, its Slots, and any subsequent Blocks.
 */
Block.prototype.stop = function() {
	this.running = 0; //Stop this Block.
	this.runMem = {}; //Clear memory
	for (let i = 0; i < this.slots.length; i++) {
		this.slots[i].stop(); //Stop this Block's Slots.
	}
	if (this.blockSlot1 != null) {
		this.blockSlot1.stop(); //Stop the BlockSlots.
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2.stop();
	}
	if (this.bottomOpen && this.nextBlock != null) {
		this.nextBlock.stop(); //Stop the next Block.
	}
};

/**
 * Updates this currently executing Block and returns if the Block is still running
 * @return {ExecutionStatus} - Indicates if the Block is still running and should be updated again.
 */
Block.prototype.updateRun = function() {
	//If a Block is told to run and it has not started or believes it is finished (from a previous execution)...
	if (this.running === 0 || this.running === 3) {
		for (let i = 0; i < this.slots.length; i++) { //...Reset all Slots to prepare for execution
			this.slots[i].stop();
		}
		this.running = 1; //Now the Block is ready to run its Slots.
	}
	let myExecStatus; //The value to return.
	if (this.running === 1) { //If the Block is currently waiting on its Slots...
		for (let i = 0; i < this.slots.length; i++) {
			//Check to see if each Slot is done and update the first Slot that isn't done.
			let slotExecStatus = this.slots[i].updateRun();
			//If the slot is still running...
			if (slotExecStatus.isRunning()) {
				//The Block is still running and will execute again next time
				return new ExecutionStatusRunning();
			} else if (slotExecStatus.hasError()) {
				//If the slot through an error, the Block is done running, and will pass the error up the call stack.
				this.running = 3;
				return slotExecStatus;
			}
		}
		this.running = 2; //If all Slots are done running, the Block itself may now run.
		//This function is overridden by the class of the particular Block.
		//It sets the Block up for execution, and if it is a simple Block, may even complete execution.
		myExecStatus = this.startAction();
	} else if (this.running === 2) { //If the Block is currently running, update it.
		//This function is also overridden and is called repeatedly until the Block is done running.
		myExecStatus = this.updateAction();
	}
	if (!myExecStatus.isRunning()) { //If the block is done running...
		if (this.running !== 0) {
			this.running = 3; //Record that the Block is done, provided that it was started
		}
		this.clearMem(); //Clear its runMem to prevent its computations from leaking into subsequent executions.
	}
	return myExecStatus; //Return a boolean indicating if this Block is done.
};

/**
 * Will be overridden. Is triggered once when the Block is first executed. Contains the Block's actual behavior.
 * @return {ExecutionStatus} - indicating if it has finished.
 */
Block.prototype.startAction = function() {
	return new ExecutionStatusRunning(); //Still running
};

/**
 * Will be overridden. Is triggered repeatedly until the Block is done running. Contains the Block's actual behavior.
 * @return {ExecutionStatus} - The next Block to run or a boolean indicating if it has finished.
 */
Block.prototype.updateAction = function() {
	return new ExecutionStatusRunning(); //Still running //Fix! by default this should be false.
};

/**
 * Once the Block is done executing, this function is used by a Slot to retrieve the Block's result.
 * Only used if Block returns a value.
 * Once the Block returns its value, it is done and can reset its state.
 * @return {Data} - The result of the Block's execution.
 */
Block.prototype.getResultData = function() {
	DebugOptions.assert(this.returnsValue);
	if (this.running === 3) { //Only return data if the Block is done running.
		this.running = 0; //Reset the Block's state. Prevents same data from ever being re-returned
		return this.resultData; //Access stored result data and return it.
	}
	return null; //If called when the block is not done running, return null. This should never happen.
};

/**
 * Recursively moves the Block, its Slots, and subsequent Blocks to another stack.
 * @param {BlockStack} stack - The stack the Blocks will be moved to.
 */
Block.prototype.changeStack = function(stack) {
	this.stack = stack; //Move this Block to the stack
	this.group.remove(); //Remove this Block's SVG group from that of the old stack.
	stack.group.appendChild(this.group); //Add this Block's SVG group to the new stack.
	for (let i = 0; i < this.slots.length; i++) {
		this.slots[i].changeStack(stack); //Recursively tell this Block's Slots to move thir children to the new stack.
	}
	if (this.nextBlock != null) {
		this.nextBlock.changeStack(stack); //Tell the next block to move.
	}
	if (this.blockSlot1 != null) {
		this.blockSlot1.changeStack(stack); //If this block is a loop/if tell its contents to move.
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2.changeStack(stack); //If it has a second BlockSlot, move it too.
	}
};

/**
 * Each BlockStack keeps track of its bounding rectangle.  This function recursively tells the Blocks to update it.
 * Each Block checks to see if it is outside the proposed bounding rectangle and if so adjusts it.
 * This function just handles the recursive part. The actual checks and adjustment are handled by updateStackDimO
 */
Block.prototype.updateStackDim = function() {
	//Slots are updated separately by updateStackDimRI.
	if (this.blockSlot1 != null) {
		this.blockSlot1.updateStackDim(); //If this block is a loop/if tell its contents to update.
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2.updateStackDim(); //If it has a second BlockSlot, update it too.
	}
	this.updateStackDimRI(); //Update the stack dimensions using information from this Block.
	if (this.nextBlock != null) {
		this.nextBlock.updateStackDim(); //Tell the next block to update.
	}
};

/**
 * Handles more of the recursion for updateStackDim.
 * RI stands for Recursive Inside.  RI functions update slots but not subsequent Blocks or BlockSlots.
 * This allows other functions to avoid unnecessary updates when full recursion is not needed.
 * updateStackDimO handled the actual updates.
 */
Block.prototype.updateStackDimRI = function() {
	for (let i = 0; i < this.slots.length; i++) {
		this.slots[i].updateStackDim(); //Pass message on to Slots.
	}
	this.updateStackDimO(); //Update this Block.
};

/**
 * Checks to see if the Block is outside the bounding box of its Stack and if so adjusts it.
 * It is called recursively by updateStackDim and updateStackDimRI.
 * The stack has two bounding boxes. Both are used when looking for potential Blocks to snap to.
 * Reporters/predicates can snap to the large r bounding box.
 * Commands can snap to the smaller c bounding box.
 * (the r box is larger because they can be snapped to the middle of other blocks while command blocks can't)
 * The point of stack bounding boxes is that when looking for potential Blocks to snap only those inside a matching
 * stack have to be investigated.
 */
Block.prototype.updateStackDimO = function() {
	let sDim = this.stack.dim; //Loads the stack's dimension data.
	let snap = BlockGraphics.command.snap; //Loads the snap bounding box for command blocks.
	if (this.bottomOpen || this.topOpen) { //Only update the c box if this is a command block //Fix! use !this.returnsValue
		let cx1 = this.x - snap.left; //Create bounding rectangle for this particular command Block
		let cy1 = this.y - snap.top;
		let cx2 = this.x + snap.right;
		let cy2 = this.y + this.height + snap.bottom;
		if (cx1 < sDim.cx1) { //If the edge of the Block is outside the stack, adjust the stack's dims.
			sDim.cx1 = cx1;
		}
		if (cy1 < sDim.cy1) {
			sDim.cy1 = cy1;
		}
		if (cx2 > sDim.cx2) {
			sDim.cx2 = cx2;
		}
		if (cy2 > sDim.cy2) {
			sDim.cy2 = cy2;
		}
	}
	let rx1 = this.x; //The r bounding box is just the size of the Block itself.
	let ry1 = this.y;
	let rx2 = this.x + this.width;
	let ry2 = this.y + this.height;
	if (rx1 < sDim.rx1) { //If the edge of the Block is outside the stack, adjust the stack's dims.
		sDim.rx1 = rx1;
	}
	if (ry1 < sDim.ry1) {
		sDim.ry1 = ry1;
	}
	if (rx2 > sDim.rx2) {
		sDim.rx2 = rx2;
	}
	if (ry2 > sDim.ry2) {
		sDim.ry2 = ry2;
	}
	//The Stacks dimensions now include the Block.
	//Note that the r box is also the visual bounding box of the stack as well as the reporter snap bounding box.
};

/**
 * Recursively adjusts the sizes of all the parts of the Block (Slots, children, labels, etc.)
 * It does not move the parts, however.  That is done later using updateAlign once the sizing is finished.
 */
Block.prototype.updateDim = function() {
	let bG = BlockGraphics.getType(this.type); //Fix! loads dimension data from BlockGraphics.
	if (this.topOpen || this.bottomOpen) { //If this is a command block, then use the BlockGraphics for command blocks.
		bG = BlockGraphics.command; //If the block if a Loop or DoubleLoop, use the CommandBlock dimension instead.
	}
	let width = 0;
	width += bG.hMargin; //The left margin of the Block.
	let lineWidth = width;
	let height = 0;
	let currentLine = 0;
	let lineHeight = [];
	lineHeight[currentLine] = 0;
	for (let i = 0; i < this.parts.length; i++) {
		this.parts[i].updateDim(); //Tell all parts of the Block to update before using their widths for calculations.
		lineWidth += this.parts[i].width; //Fill the width of the middle of the Block
		if (this.parts[i].height > lineHeight[currentLine]) { //The height of the Block is the height of the tallest member.
			lineHeight[currentLine] = this.parts[i].height;
		}
		if (i < this.parts.length - 1 && !this.parts[i].isEndOfLine) {
			lineWidth += BlockGraphics.block.pMargin; //Add "part margin" between parts of the Block.
		}
		if (lineWidth > width) { //The block width is the width of the longest line of parts
			width = lineWidth
		}
		if (this.parts[i].isEndOfLine){
			//get ready to start a new line with the next block
			if ( (lineHeight[currentLine] + 2 * bG.vMargin) < bG.height){//If the height is less than the min height, fix it.
				lineHeight[currentLine] = bG.height - 2 * bG.vMargin;
			}
			height += lineHeight[currentLine] + bG.vMargin;
			currentLine += 1;
			lineHeight[currentLine] = 0;
			lineWidth = bG.hMargin;
		}
	}
	this.lineHeight = lineHeight; //Save the line heights for aligning parts
	width += bG.hMargin; //Add the right margin of the Block.
	height += lineHeight[currentLine] //Add the height of the last line of blocks
	height += 2 * bG.vMargin; //Add the bottom and top margins of the Block.
	if (height < bG.height) { //If the height is less than the min height, fix it.
		height = bG.height;
	}
	if (this.hasBlockSlot1) { //If it has a BlockSlot update that.
		this.topHeight = height; //The topHeight is the height of everything avove the BlockSlot.
		this.blockSlot1.updateDim(); //Update the BlockSlot.
		height += this.blockSlot1.height; //The total height, however, includes the BlockSlot.
		height += BlockGraphics.loop.bottomH; //It also includes the bottom part of the loop.
	}
	if (this.hasBlockSlot2) { //If the Block has a second BlockSlot...
		this.midLabel.updateDim(); //Update the label in between the two BlockSlots.
		this.midHeight = this.midLabel.height; //Add the Label's height to the total.
		this.midHeight += 2 * bG.vMargin; //The height between the BlockSlots also includes the margin of that area.
		if (this.midHeight < bG.height) { //If it's less than the minimum, adjust it.
			this.midHeight = bG.height;
		}
		height += this.midHeight; //Add the midHeight to the total.
		this.blockSlot2.updateDim(); //Update the secodn BlockSlot.
		height += this.blockSlot2.height; //Add its height to the total.
	}
	//If the Block was a loop or DoubleLoop now we are dealing with its actual properties (not those of command)
	bG = BlockGraphics.getType(this.type);
	if (width < bG.width) { //If it is less than the minimum width, adjust it.
		width = bG.width;
	}
	this.resize(width, height); //Resize this Block to the new widths.
	if (this.nextBlock != null) {
		this.nextBlock.updateDim(); //Pass the message to the next Block.
	}
};

/**
 * Recursively adjusts the positioning of all the parts of the Block (Slots, children, labels, etc.)
 * The BlockStack calls this function after the updateDim function, so all sizes are correct.
 * @param {number} x - The x coord this block should have when completed.
 * @param {number} y - The y coord the block should have.
 * @return {number} - The width of the current block, indicating how much the x should shift over.
 * y is measured from the top for all Blocks, x is measured from the left.
 */
Block.prototype.updateAlign = function(x, y) {
	let bG = BlockGraphics;
	this.updateAlignRI(x, y); //Update recursively within the block.
	if (this.hasBlockSlot1) { //Then tell all susequent blocks to align.
		this.blockSlot1.updateAlign(this.x + bG.loop.side, this.y + this.topHeight);
	}
	if (this.hasBlockSlot2) {
		this.blockSlot2.updateAlign(this.x + bG.loop.side, this.y + this.topHeight + this.blockSlot1.height + this.midHeight);
		this.midLabel.updateAlign(bG.loop.side, this.topHeight + this.blockSlot1.height + this.midHeight / 2);
	}
	if (this.nextBlock != null) {
		this.nextBlock.updateAlign(this.x, this.y + this.height);
	}
	return this.width;
};

/**
 * Adjusts the positioning of the Block's internal parts.  Recursively updates their children.
 * @param {number} x - The x coord this block should have when completed.
 * @param {number} y - The y coord the block should have.
 * y is measured from the top for all Blocks, x is measured from the left.
 */
Block.prototype.updateAlignRI = function(x, y) {
	this.move(x, y); //Move to the desired location
	let bG = BlockGraphics.getType(this.type);
	if (this.bottomOpen || this.topOpen) {
		bG = BlockGraphics.command;
	}
	let currentLine = 0;
	let yCoord = (this.lineHeight[currentLine] + (2 * bG.vMargin)) / 2; //Compute coords for internal parts.
	let xCoord = 0;
	if (this.hasBlockSlot1) {
		yCoord = this.topHeight / 2; //Internal parts measure their y coords from the center of the block.
	}
	xCoord += bG.hMargin;
	for (let i = 0; i < this.parts.length; i++) {
		xCoord += this.parts[i].updateAlign(xCoord, yCoord); //As each element is adjusted, shift over by the space used.
		if (this.parts[i].isEndOfLine){
			xCoord = bG.hMargin;
			currentLine += 1;
			yCoord += (this.lineHeight[currentLine] + this.lineHeight[currentLine - 1])/2
			yCoord += bG.vMargin;
		} else if (i < this.parts.length - 1) {
			xCoord += BlockGraphics.block.pMargin;
		}
	}
};

/**
 * Resizes the path of the Block to the specified width and height.  The sizes of its BlockSlots are also considered.
 * @param {number} width - The desired width of the Block.
 * @param {number} height - The desired height of the Block.
 */
Block.prototype.resize = function(width, height) {
	let BG = BlockGraphics;
	//First set width and height properties.
	this.width = width;
	this.height = height;
	//Then collect other necessary information.
	let innerHeight1 = 0;
	let innerHeight2 = 0;
	let midHeight = 0;
	if (this.hasBlockSlot1) {
		innerHeight1 = this.blockSlot1.height;
	}
	if (this.hasBlockSlot2) {
		innerHeight2 = this.blockSlot2.height;
		midHeight = this.midHeight;
	}
	//Tell BlockGraphics to change the path description to match the new properties.
	BG.update.path(this.path, 0, 0, width, height, this.type, false, innerHeight1, innerHeight2, midHeight, this.bottomOpen);
};

/**
 * Recursively searches for the Block with best fits the currently moving BlockStack.
 * Stores information about any matches in CodeManager.fit and uses data from CodeManager.move.
 * A command block attempts to find a connection between its bottom and the moving stack's top.
 * Connections to the top of the stack's findBestFit.
 */
Block.prototype.findBestFit = function() {
	let move = CodeManager.move;
	let fit = CodeManager.fit;
	let x = this.getAbsX(); //Get coords to compare.
	let y = this.getAbsY();
	let height = this.relToAbsY(this.height) - y;
	let hasMatch = false;

	if (move.returnsValue) { //If a connection between the stack and block are possible...
		for (let i = 0; i < this.slots.length; i++) {
			let slotHasMatch = this.slots[i].findBestFit();
			hasMatch = slotHasMatch || hasMatch;
		}
	} else if (move.topOpen && this.bottomOpen) { //If a connection between the stack and block are possible...
		let snap = BlockGraphics.command.snap; //Load snap bounding box
		//see if corner of moving block falls within the snap bounding box.
		let snapBLeft = x - snap.left;
		let snapBTop = y - snap.top;
		let snapBWidth = snap.left + snap.right;
		let snapBHeight = snap.top + height + snap.bottom;
		//Check if point falls in a rectangular range.
		if (move.pInRange(move.topX, move.topY, snapBLeft, snapBTop, snapBWidth, snapBHeight)) {
			let xDist = move.topX - x; //If it does, compute the distance with the distance formula.
			let yDist = move.topY - (y + height);
			let dist = xDist * xDist + yDist * yDist; //Technically this is the distance^2.
			if (!fit.found || dist < fit.dist) { //See if this fit is closer than the current best fit.
				fit.found = true; //If so, save it and other helpful infromation.
				fit.bestFit = this;
				fit.dist = dist;
			}
		}
	}
	if (this.hasBlockSlot1) { //Pass the message on recursively.
		this.blockSlot1.findBestFit();
	}
	if (this.hasBlockSlot2) {
		this.blockSlot2.findBestFit();
	}
	if (this.nextBlock != null) {
		this.nextBlock.findBestFit();
	}
	return hasMatch;
};

/**
 * Adds an indicator showing that the moving BlockStack will snap onto this Block if released.
 * The indicator is a different color/shape depending on the Block's type and if it is running.
 */
Block.prototype.highlight = function() {
	if (this.bottomOpen) {
		Highlighter.highlight(this.getAbsX(), this.relToAbsY(this.height), this.width, this.height, 0, false, this.isGlowing);
	} else { //If a block returns a value, the BlockStack can only attach to one of its slots, not the Block itself.
		DebugOptions.throw("Attempt to highlight block that has bottomOpen = false");
	}
};

/**
 * Attaches the provided Block (and all subsequent Block's) to the bottom of this Block. Then runs updateDim();
 * @param {Block} block - The first Block in the stack to attach to this Block.
 */
Block.prototype.snap = function(block) {
	//If the Block cannot have other blocks below it, any other blocks must now be disconnected.
	//Get the bottom Block in the stack to be inserted.
	let bottomStackBlock = block.getLastBlock();
	//If the stack being inserted can't have blocks below it, and there is a block after this Block...
	if (!bottomStackBlock.bottomOpen && this.nextBlock != null) {
		let bG = BlockGraphics.command;
		//Disconnect the blocks after this Block and shift them over to make room.
		this.nextBlock.unsnap().shiftOver(bG.shiftX, block.stack.getHeight() + bG.shiftY);
	}
	let stack = this.stack;
	//If the Block we are inserting is part of a stack...
	if (block.stack != null) {
		block.stack.stop();
		if (stack.isRunning) {
			// Make it glow if this stack is running
			block.glow();
		}
	}
	let upperBlock = this; //The Block which will go above the inserted stack.
	let lowerBlock = this.nextBlock; //The Block which will go below the inserted stack. Might be null.
	let topStackBlock = block; //The top Block in the stack to be inserted.

	//The top of where the stack is inserted note which Blocks are above/below them.
	upperBlock.nextBlock = topStackBlock;
	topStackBlock.parent = upperBlock;
	//The bottom of where the stack is inserted does the same.
	bottomStackBlock.nextBlock = lowerBlock;
	if (lowerBlock != null) { //There might not be a Block below the inserted stack.
		lowerBlock.parent = bottomStackBlock;
	}
	let oldG = null;
	if (block.stack != null) {
		oldG = block.stack.group; //Get a handle to the old stack's group
		block.stack.remove(); //Remove the old stack.
	}
	if (this.stack != null) {
		block.changeStack(this.stack); //Move the block over into this stack
	}
	if (oldG != null) {
		oldG.remove(); //Remove the old stack's group.
	}
	if (this.stack != null) {
		//Update the dimensions now that the movement is complete.
		this.stack.updateDim();
		//Update the arros on the sides of the screen in case the new block now extends beyond the edge
		this.stack.tab.updateArrows();
	}
};

/**
 * Disconnects this Block from the Blocks above it and returns the newly-created BlockStack. Calls updateDim on parent.
 * @return {BlockStack} - A BlockStack containing this Block and all subsequent Blocks.
 */
Block.prototype.unsnap = function() {
	//If this has a parent, then it needs to disconnect and make a new stack.  Otherwise, it returns its current stack.
	if (this.parent != null) {
		if (this.parent.isSlot || this.parent.isBlockSlot) { //Checks if it is attached to a Slot not another Block.
			this.parent.removeChild(); //Leave the Slot.
			this.parent.parent.stack.updateDim(); //Tell the stack the Slot belongs to to update its dimensions.
		} else { //This Block is connected to another Block.
			this.parent.nextBlock = null; //Disconnect from parent Block.
			this.parent.stack.updateDim(); //Tell parent's stack to update dimensions.
		}
		this.parent = null; //Delete reference to parent Block/Slot/BlockSlot.
		//Make a new BlockStack with this Block in current Tab.  Also moves over any subsequent Blocks.
		return new BlockStack(this, this.stack.getTab());
	}
	//If the Block already had no parent, just return this Block's stack.
	return this.stack;
};

/**
 * Recursively finds and returns the last Block in this BlockStack.
 * @return {Block} - The last Block in this BlockStack.
 */
Block.prototype.getLastBlock = function() {
	if (this.nextBlock == null) {
		return this; //This Block is the last one.
	} else {
		return this.nextBlock.getLastBlock(); //Try the next Block.
	}
};

/**
 * Recursively returns the height of this Block and all subsequent Blocks. Used by BlockSlots to determine height.
 * @return {number} - The height of this Block and all subsequent Blocks.
 */
Block.prototype.addHeights = function() {
	if (this.nextBlock != null) {
		return this.height + this.nextBlock.addHeights(); //Return this Block's height plus those below it.
	} else {
		return this.height; //This is the last Block. Return its height.
	}
};

/**
 * Returns a copy of this Block, its Slots, subsequent Blocks, and nested Blocks.
 * Mutually recursive with copyFrom.
 * @param {number} x - The new Block's x coord.
 * @param {number} y - The new Block's y coord.
 * @return {Block} - This Block's copy.
 */
Block.prototype.duplicate = function(x, y) {
	let myCopy = null;
	// First we use this Block's constructor to create a new block of the same type
	// If this Block is a list or variable Block, we must pass that data to the constructor
	if (this.variable != null) {
		myCopy = new this.constructor(x, y, this.variable);
	} else if (this.list != null) {
		myCopy = new this.constructor(x, y, this.list);
	} else {
		myCopy = new this.constructor(x, y);
	}
	// Then we tell the new block to copy its data from this Block
	myCopy.copyFrom(this);
	return myCopy;
};

/**
 * Takes a Block and copies its slot data.  Duplicates all blocks below the Block and in its slots.
 * Mutually recursive with duplicate.
 * @param {Block} block - The block to copy the data from.  Must be of the same type.
 */
Block.prototype.copyFrom = function(block) {
	DebugOptions.assert(block.blockTypeName === this.blockTypeName);
	for (let i = 0; i < this.slots.length; i++) { //Copy block's slots to this Block.
		this.slots[i].copyFrom(block.slots[i]);
	}
	if (this.blockSlot1 != null) { //Copy the contents of its BlockSlots.
		this.blockSlot1.copyFrom(block.blockSlot1);
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2.copyFrom(block.blockSlot2);
	}
	if (block.nextBlock != null) { //Copy subsequent Blocks.
		this.nextBlock = block.nextBlock.duplicate(0, 0);
		this.nextBlock.parent = this;
	}
};

/**
 * Returns an entirely text-based version of the Block for display in dialogs.
 * May exclude a slot and replace if with "___".
 * @param {Slot} slotToExclude - (optional) The Slot to replace with "___".
 * @return {string} - The finished text summary.
 */
Block.prototype.textSummary = function(slotToExclude) {
	let summary = "";
	for (let i = 0; i < this.parts.length; i++) {
		if (this.parts[i] === slotToExclude) {
			//Replace slot with underscores.
			summary += "___";
		} else {
			summary += this.parts[i].textSummary(); //Recursively build text summary from text summary of contents.
		}
		if (i < this.parts.length - 1) { //Add space between part descriptions.
			summary += " ";
		}
	}
	return summary;
};

/**
 * Overridden by subclasses. Alerts Block that the flag was clicked. Most Blocks won't respond to this directly.
 */
Block.prototype.eventFlagClicked = function() {

};

/**
 * Overridden by subclasses. Passes broadcast message to Block.
 */
Block.prototype.eventBroadcast = function(message) {

};

/**
 * Overridden by subclasses. Checks if a broadcast with the given message is currently running on this block.
 * Used to tell Broadcast and wait blocks if they can stop waiting.
 */
Block.prototype.checkBroadcastRunning = function(message) {
	return false;
};

/**
 * Recursively updates the available broadcast messages.
 */
Block.prototype.updateAvailableMessages = function() {
	for (let i = 0; i < this.slots.length; i++) {
		this.slots[i].updateAvailableMessages();
	}
	if (this.blockSlot1 != null) {
		this.blockSlot1.updateAvailableMessages();
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2.updateAvailableMessages();
	}
	if (this.bottomOpen && this.nextBlock != null) {
		this.nextBlock.updateAvailableMessages();
	}
};

/**
 * Deletes the Block's running memory (memory reserved for computations related to execution)
 * Also deletes the runMem of the Block's slots, but not runMem of Blocks in those Slots
 */
Block.prototype.clearMem = function() {
	//Delete all runMem.
	this.runMem = new function() {};
	for (let i = 0; i < this.slots.length; i++) {
		this.slots[i].clearMem(); //Removes resultData and resets running state to 0 (NOT recursive).
	}
};

/**
 * Returns the result of the Block's execution.
 * The data is then removed to prevent the result from being returned again.
 */
Block.prototype.getResultData = function() {
	DebugOptions.assert(this.resultData != null);
	let result = this.resultData;
	this.resultData = null;
	return result;
};

/**
 * Recursively adds a white outline to indicate that the BlockStack is running.
 */
Block.prototype.glow = function() {
	BlockGraphics.update.glow(this.path);
	this.isGlowing = true; //Used by other classes to determine things like highlight color.
	if (this.blockSlot1 != null) {
		this.blockSlot1.glow();
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2.glow();
	}
	if (this.bottomOpen && this.nextBlock != null) {
		this.nextBlock.glow();
	}
};

/**
 * Recursively removes the outline.
 */
Block.prototype.stopGlow = function() {
	BlockGraphics.update.stroke(this.path, this.category, this.returnsValue, this.active);
	this.isGlowing = false;
	if (this.blockSlot1 != null) {
		this.blockSlot1.stopGlow();
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2.stopGlow();
	}
	if (this.bottomOpen && this.nextBlock != null) {
		this.nextBlock.stopGlow();
	}
};

/**
 * Changes the Block's appearance and its Slots (but not their children) to indicate that this Block
 * is inactive and cannot be run.  Used by sensors that a device does not support and robot blocks for
 * robots that are not connected
 */
Block.prototype.makeInactive = function() {
	if (this.active) {
		this.active = false;
		BlockGraphics.update.blockActive(this.path, this.category, this.returnsValue, this.active, this.isGlowing);
		this.parts.forEach(function(slot) {
			slot.makeInactive();
		});
	}
};

/**
 * Undoes the visual changes of makeInactive.  Calls makeActive on all Slots
 */
Block.prototype.makeActive = function() {
	if (!this.active) {
		this.active = true;
		BlockGraphics.update.blockActive(this.path, this.category, this.returnsValue, this.active, this.isGlowing);
		this.parts.forEach(function(slot) {
			slot.makeActive();
		});
	}
};

/**
 * @param {boolean} active
 */
Block.prototype.setActive = function(active) {
	if (active) {
		this.makeActive();
	} else {
		this.makeInactive();
	}
};

/**
 * Returns a value indicating if this block is active.  Overrided by subclasses.
 * @return {boolean}
 */
Block.prototype.checkActive = function() {
	// Most Blocks are always active
	return true;
};

/**
 * Uses checkActive and setActive to update the Blocks appearance
 */
Block.prototype.updateActive = function() {
	this.setActive(this.checkActive());
};

/**
 * Recursively writes this Block and those below it to XML
 * @param {Document} xmlDoc - The document to write to
 * @param {Node} xmlBlocks - The <Blocks> tag in the document
 */
Block.prototype.writeToXml = function(xmlDoc, xmlBlocks) {
	xmlBlocks.appendChild(this.createXml(xmlDoc));
	if (this.bottomOpen && this.nextBlock != null) {
		this.nextBlock.writeToXml(xmlDoc, xmlBlocks);
	}
};

/**
 * Writes this Block to XML (non recursive)
 * @param {Document} xmlDoc - The document to write to
 * @return {Node}
 */
Block.prototype.createXml = function(xmlDoc) {
	let block = XmlWriter.createElement(xmlDoc, "block");
	XmlWriter.setAttribute(block, "type", this.blockTypeName);
	let slots = XmlWriter.createElement(xmlDoc, "slots");
	// Indicates that we are using the new saving system, which uses keys assigned to each Slot to identify
	// which data goes to which Slot.  The old system uses the order of appearance in the XML to match data to Slots
	XmlWriter.setAttribute(slots, "keyVal", "true");
	for (let i = 0; i < this.slots.length; i++) {
		slots.appendChild(this.slots[i].createXml(xmlDoc));
	}
	block.appendChild(slots);
	if (this.blockSlot1 != null) {
		let blockSlots = XmlWriter.createElement(xmlDoc, "blockSlots");
		blockSlots.appendChild(this.blockSlot1.createXml(xmlDoc));
		if (this.blockSlot2 != null) {
			blockSlots.appendChild(this.blockSlot2.createXml(xmlDoc));
		}
		block.appendChild(blockSlots);
	}
	return block;
};

/**
 * Reads a Block from XML and returns the Block or null if the data is corrupt
 * @param blockNode {Node} - Block node of th XML file being read
 * @return {Block|null} - The imported Block, or null if the data is corrupt
 */
Block.importXml = function(blockNode) {
	// Get the correct class of the Block
	let type = XmlWriter.getAttribute(blockNode, "type");
	let block;
	try {
		// All classes start with "B_"
		if (type.substring(0, 2) === "B_") {
			// Find the constructor's import function
			if (window[type].importXml != null) {
				// If the Block has a special import function, use that
				return window[type].importXml(blockNode);
			} else {
				// Otherwise, use the Block's constructor
				block = new window[type](0, 0);
				// Copy the data into the Block
				block.copyFromXml(blockNode);
				return block;
			}
		} else {
			// The data is corrupt
			return null;
		}
	} catch (e) {
		// The data is corrupt
		return null;
	}
};

/**
 * Copies the data from the Block tag into the Block
 * @param {Node} blockNode - The node to copy the data from
 */
Block.prototype.copyFromXml = function(blockNode) {
	let slotsNode = XmlWriter.findSubElement(blockNode, "slots");
	// Copy the data about the Slots into the Block.
	this.importSlotXml(slotsNode);
	let blockSlotsNode = XmlWriter.findSubElement(blockNode, "blockSlots");
	let blockSlotNodes = XmlWriter.findSubElements(blockSlotsNode, "blockSlot");
	// Copy data about BlockSlots
	if (this.blockSlot1 != null && blockSlotNodes.length >= 1) {
		this.blockSlot1.importXml(blockSlotNodes[0]);
	}
	if (this.blockSlot2 != null && blockSlotNodes.length >= 2) {
		this.blockSlot2.importXml(blockSlotNodes[1]);
	}
};

/**
 * Imports the data about the Slots into the Block.
 * @param {Node} slotsNode - The node to copy the data from
 */
Block.prototype.importSlotXml = function(slotsNode) {
	// Determine if we are using the key/value system or legacy, order dependant system.
	let keyVal = XmlWriter.getAttribute(slotsNode, "keyVal", "false") === "true";
	let slotNodes = XmlWriter.findSubElements(slotsNode, "slot");
	if (keyVal) {
		// Import data for each slot
		this.slots.forEach(function(slot) {
			let key = slot.getKey();
			let slotNode = XmlWriter.findNodeByKey(slotNodes, key);
			// Import data if that key exists.  Otherwise, leave the Slot at default values
			if (slot != null) {
				slot.importXml(slotNode);
			}
		});
	} else {
		// Import the data for each Slot in order
		for (let i = 0; i < slotNodes.length && i < this.slots.length; i++) {
			this.slots[i].importXml(slotNodes[i]);
		}
	}
};

/**
 * Recursively notifies the Block that a variable has changed names
 * @param {Variable} variable - The variable that was renamed
 */
Block.prototype.renameVariable = function(variable) {
	this.passRecursively("renameVariable", variable);
};

/**
 * Recursively notifies the Block that a variable has been deleted
 * @param {Variable} variable - The variable that was deleted
 */
Block.prototype.deleteVariable = function(variable) {
	this.passRecursively("deleteVariable", variable);
};

/**
 * Recursively notifies the Block that a list has changed names
 * @param {List} list - The list that was renamed
 */
Block.prototype.renameList = function(list) {
	this.passRecursively("renameList", list);
};

/**
 * Recursively notifies the Block that a list has been deleted
 * @param {List} list - The list that was deleted
 */
Block.prototype.deleteList = function(list) {
	this.passRecursively("deleteList", list);
};

/**
 * Recursively determines if a variable is in use
 * @param {Variable} variable - The variable to check
 * @return {boolean} - true iff the variable is used in at least one Block
 */
Block.prototype.checkVariableUsed = function(variable) {
	for (let i = 0; i < this.slots.length; i++) {
		if (this.slots[i].checkVariableUsed(variable)) {
			return true;
		}
	}
	if (this.blockSlot1 != null) {
		if (this.blockSlot1.checkVariableUsed(variable)) {
			return true;
		}
	}
	if (this.blockSlot2 != null) {
		if (this.blockSlot2.checkVariableUsed(variable)) {
			return true;
		}
	}
	if (this.bottomOpen && this.nextBlock != null) {
		if (this.nextBlock.checkVariableUsed(variable)) {
			return true;
		}
	}
	return false;
};

/**
 * Recursively determines if a list is in use
 * @param {List} list - The list to check
 * @return {boolean} - true iff the list is used in at least one Block
 */
Block.prototype.checkListUsed = function(list) {
	for (let i = 0; i < this.slots.length; i++) {
		if (this.slots[i].checkListUsed(list)) {
			return true;
		}
	}
	if (this.blockSlot1 != null) {
		if (this.blockSlot1.checkListUsed(list)) {
			return true;
		}
	}
	if (this.blockSlot2 != null) {
		if (this.blockSlot2.checkListUsed(list)) {
			return true;
		}
	}
	if (this.bottomOpen && this.nextBlock != null) {
		if (this.nextBlock.checkListUsed(list)) {
			return true;
		}
	}
	return false;
};

/**
 * Recursively counts the maximum selected DropDown value for a DeviceDropDown of the specified deviceClass
 * @param deviceClass - A subclass of Device.  Only DropDowns for this device are affected
 * @return {number} - The maximum value + 1 (since selections are 0-indexed)
 */
Block.prototype.countDevicesInUse = function(deviceClass) {
	// At least 1 option is available on all DropDowns
	let largest = 0;
	// Find the largest result of all calls
	for (let i = 0; i < this.slots.length; i++) {
		largest = Math.max(largest, this.slots[i].countDevicesInUse(deviceClass));
	}
	if (this.blockSlot1 != null) {
		largest = Math.max(largest, this.blockSlot1.countDevicesInUse(deviceClass));
	}
	if (this.blockSlot2 != null) {
		largest = Math.max(largest, this.blockSlot2.countDevicesInUse(deviceClass));
	}
	if (this.bottomOpen && this.nextBlock != null) {
		largest = Math.max(largest, this.nextBlock.countDevicesInUse(deviceClass));
	}
	return largest;
};

/**
 * Called when the available sensors changes. Each Block checks if it is still enabled and then passes the message.
 */
Block.prototype.updateAvailableSensors = function() {
	this.updateActive();
};

/**
 * Calls a function on all the Block's slots.  All parameters after the functionName are passed to the function
 * as arguments
 * @param functionName - The name of the function to call on each child
 */
Block.prototype.passRecursively = function(functionName) {
	let args = Array.prototype.slice.call(arguments, 1);
	for (let i = 0; i < this.slots.length; i++) {
		let currentSlot = this.slots[i];
		currentSlot[functionName].apply(currentSlot, args);
	}
	if (this.blockSlot1 != null) {
		this.blockSlot1[functionName].apply(this.blockSlot1, args);
	}
	if (this.blockSlot2 != null) {
		this.blockSlot2[functionName].apply(this.blockSlot2, args);
	}
	if (this.bottomOpen && this.nextBlock != null) {
		this.nextBlock[functionName].apply(this.nextBlock, args);
	}
};

/**
 * Recursively instructs all slots to pass a message.  The message is likely a function name that is called when
 * it reaches an object of the correct type.  Subsequent arguments are passed as well.
 * @param {string} message - Possibly the name of the function to call to send the message
 */
Block.prototype.passRecursivelyDown = function(message) {
	const myMessage = message;
	let funArgs = Array.prototype.slice.call(arguments, 1);
	// If the message implemented by this Block...

	if (myMessage === "updateAvailableSensors" && this.updateAvailableSensors != null) {
		// Implemented by all Blocks, used by Tablet Blocks
		this.updateAvailableSensors.apply(this, funArgs);
	}

	// Add "passRecursivelyDown" as the first argument
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	// Call passRecursivelyDown on all children
	this.passRecursively.apply(this, arguments);
};

/**
 * Instructs the Block to display its result of execution
 * @param {Data} data - The result to display
 */
Block.prototype.displayResult = function(data) {
	// Get the string representation of the data
	let value = data.asString().getValue();
	// Display it, not as an error
	this.displayValue(value, false);
};

/**
 * Shows a bubble below the Block with the provided message
 * @param {string} message - The message to show
 * @param {boolean} error - Indicates if the bubble should be formatted like an error
 */
Block.prototype.displayValue = function(message, error) {
	// Get the coords where to show the bubble
	let x = this.getAbsX();
	let y = this.getAbsY();
	let width = this.relToAbsX(this.width) - x;
	let height = this.relToAbsY(this.height) - y;
	// Display a bubble at the location
	ResultBubble.displayValue(message, x, y, width, height, error);
};

/**
 * Show a bubble with the error
 * @param {string} message - The error to show
 */
Block.prototype.displayError = function(message) {
	this.displayValue(message, true);
};

/**
 * Takes a subclass of Block and modifies its display function to include a suffix (used to display sensor units)
 * @param Class - The subclass of Block to modify
 * @param {string} suffix - The string to append to the normal display response
 */
Block.setDisplaySuffix = function(Class, suffix) {
	// Use setDeviceSuffixFn with a function that just returns the suffix
	Block.setDeviceSuffixFn(Class, function() {
		return suffix;
	});
};

/**
 * Takes a subclass of Block and modifies its display function to append a suffix, determined from a function
 * @param Class - The subclass of Block to modify
 * @param {function} suffixFn - function () -> string that returns the desired suffix
 */
Block.setDeviceSuffixFn = function(Class, suffixFn) {
	Class.prototype.displayResult = function(data) {
		// Only valid data is followed by a suffix
		if (data.isValid) {
			let value = data.asString().getValue();
			this.displayValue(value + " " + suffixFn(), false);
		} else {
			this.displayValue(data.asString().getValue(), false);
		}
	};
};

/**
 * Child of Block. The CommandBlock is for Blocks that return no value but have no BlockSlots.
 * @constructor
 * @param {number} x - The x coord for the Block.
 * @param {number} y - The y coord for the Block.
 * @param {string} category - The Block's category in string form. Used mainly to color it.
 * @param {boolean} bottomOpen - Can Blocks be attached to the bottom of this Block?
 */
function CommandBlock(x, y, category, bottomOpen) {
	Block.call(this, 0, Block.returnTypes.none, x, y, category); // Call constructor.
	if (bottomOpen != null && bottomOpen === false) { // if bottomOpen is false, change it from the default.
		this.bottomOpen = false;
	}
}
CommandBlock.prototype = Object.create(Block.prototype); //Everything else is the same as Block.
CommandBlock.prototype.constructor = CommandBlock;
/**
 * Child of Block. The CommandBlock is for Blocks that return values other than booleans.
 * @constructor
 * @param {number} x - The x coord for the Block.
 * @param {number} y - The y coord for the Block.
 * @param {string} category - The Block's category in string form. Used mainly to color it.
 * @param {number} returnType - (optional) The type of data the Block returns (from Block.returnTypes). Default: num.
 */
function ReporterBlock(x, y, category, returnType) {
	if (returnType == null) {
		returnType = Block.returnTypes.num; //Return nums by default.
	}
	Block.call(this, 1, returnType, x, y, category); //Call constructor.
}
ReporterBlock.prototype = Object.create(Block.prototype); //Everything else is the same as Block.
ReporterBlock.prototype.constructor = ReporterBlock;
/**
 * Child of Block. The CommandBlock is for Blocks that return booleans.
 * @constructor
 * @param {number} x - The x coord for the Block.
 * @param {number} y - The y coord for the Block.
 * @param {string} category - The Block's category in string form. Used mainly to color it.
 */
function PredicateBlock(x, y, category) {
	Block.call(this, 2, Block.returnTypes.bool, x, y, category); // Call constructor.
}
PredicateBlock.prototype = Object.create(Block.prototype); // Everything else is the same as Block.
PredicateBlock.prototype.constructor = PredicateBlock;
/**
 * Child of Block. The HatBlock is for Blocks like CommandBlock but which have rounded tops which accept no Blocks.
 * @constructor
 * @param {number} x - The x coord for the Block.
 * @param {number} y - The y coord for the Block.
 * @param {string} category - The Block's category in string form. Used mainly to color it.
 */
function HatBlock(x, y, category) {
	Block.call(this, 4, Block.returnTypes.none, x, y, category); //Call constructor.
}
HatBlock.prototype = Object.create(Block.prototype); //Everything else is the same as Block.
HatBlock.prototype.constructor = HatBlock;
/**
 * Child of Block. The DoubleLoopBlock is for Blocks like CommandBlock but with a space for additional Blocks
 * @constructor
 * @param {number} x - The x coord for the Block.
 * @param {number} y - The y coord for the Block.
 * @param {string} category - The Block's category in string form. Used mainly to color it.
 * @param {boolean} bottomOpen - Can Blocks be attached to the bottom of this Block?
 */
function LoopBlock(x, y, category, bottomOpen) {
	Block.call(this, 5, Block.returnTypes.none, x, y, category); //Call constructor.
	if (bottomOpen != null && bottomOpen === false) { //if bottomOpen is false, change it from the default.
		this.bottomOpen = false;
	}
}
LoopBlock.prototype = Object.create(Block.prototype); //Everything else is the same as Block.
LoopBlock.prototype.constructor = LoopBlock;
/**
 * Child of Block. The DoubleLoopBlock is for Blocks like CommandBlock but with two spaces for additional Blocks
 * @constructor
 * @param {number} x - The x coord for the Block.
 * @param {number} y - The y coord for the Block.
 * @param {string} category - The Block's category in string form. Used mainly to color it.
 * @param {boolean} midLabelText - i.e. "Else".  The text to label the second BlockSlot.
 */
function DoubleLoopBlock(x, y, category, midLabelText) {
	this.midLabelText = midLabelText; //Is set before constructor so Block is ready to render when constructor runs.
	Block.call(this, 6, Block.returnTypes.none, x, y, category);
}
DoubleLoopBlock.prototype = Object.create(Block.prototype);
DoubleLoopBlock.prototype.constructor = DoubleLoopBlock;
/**
 * Controls the visual aspects of a Slot.
 * Abstract class, subclasses correspond to different types of Slots.
 * @param {Slot} slot - The Slot this SlotShape is a part of.  Used for retrieving category information, etc.
 * @constructor
 */
function SlotShape(slot) {
	this.slot = slot;

	// SlotShapes are only shown when no Blocks are connected to the Slot
	this.visible = false;

	// The graphics for the shape are created when show() or buildSlot() is called
	this.built = false;

	// Some slots appear different if the Block that are attached to is inactive (gray)
	this.active = true;
}

/**
 * SlotShape has no constants yet
 */
SlotShape.setConstants = function() {

};

/**
 * Builds the slot and makes it visible
 */
SlotShape.prototype.show = function() {
	if (this.visible) return;
	this.visible = true;
	if (!this.built) this.buildSlot();
	this.slot.parent.group.appendChild(this.group);
	this.updateDim();
	this.updateAlign();
};

/**
 * Hides the slot
 */
SlotShape.prototype.hide = function() {
	if (!this.visible) return;
	this.visible = false;
	this.group.remove();
};

/**
 * Creates the Slot's graphics
 */
SlotShape.prototype.buildSlot = function() {
	if (this.built) return;
	this.built = true;
	this.group = GuiElements.create.group(0, 0);
	// Overridden by subclasses
};

/**
 * Moves the SlotShape to the coords (relative to the Block)
 * @param {number} x
 * @param {number} y
 */
SlotShape.prototype.move = function(x, y) {
	DebugOptions.validateNumbers(x, y);
	GuiElements.move.group(this.group, x, y);
};

/**
 * Computes the SlotShape's width and height properties
 */
SlotShape.prototype.updateDim = function() {
	DebugOptions.markAbstract();
};

/**
 * Moves the SlotShapes sub-parts to line up properly
 */
SlotShape.prototype.updateAlign = function() {
	DebugOptions.markAbstract();
};

/**
 * Makes the SlotShape appear active
 */
SlotShape.prototype.makeActive = function() {
	if (!this.active) {
		this.active = true;
	}
	// Subclasses may change appearance
};

/**
 * Makes the SlotShape appear inactive
 */
SlotShape.prototype.makeInactive = function() {
	if (this.active) {
		this.active = false;
	}
	// Subclasses may change appearance
};

/**
 * Sets the SlotShape to appear active/inactive
 * @param {boolean} active
 */
SlotShape.prototype.setActive = function(active) {
	if (active) {
		this.makeActive();
	} else {
		this.makeInactive();
	}
};
/**
 * Abstract subclass of SlotShape for Slots that allow values (strings/numbers) to be directly entered into the Slot
 * EditableSlotShape can be controlled by an InputSystem
 * EditableSlots have text to display the entered value and a rectangular hit box that is slightly larger than
 * the visual elements of the SlotShape
 * @param {Slot} slot
 * @param {string} initialText - The initial value to display
 * @param {object} dimConstants - An object provided by the subclass with constants for colors/margins
 * @constructor
 */
function EditableSlotShape(slot, initialText, dimConstants) {
	SlotShape.call(this, slot);
	this.text = initialText;
	this.dimConstants = dimConstants;

	// Text can be in one of three color states: selected, deselected, and grayed
	this.isGray = false;
}
EditableSlotShape.prototype = Object.create(SlotShape.prototype);
EditableSlotShape.prototype.constructor = EditableSlotShape;

EditableSlotShape.setConstants = function() {
	const ESS = EditableSlotShape;
	ESS.charHeight = BlockGraphics.valueText.font.charHeight;
	ESS.hitBox = {};
	ESS.hitBox.hMargin = BlockGraphics.hitBox.hMargin;
	ESS.hitBox.vMargin = BlockGraphics.hitBox.vMargin;
};

/**
 * Create the visual elements of the Slot, but no need to position them correctly
 */
EditableSlotShape.prototype.buildSlot = function() {
	SlotShape.prototype.buildSlot.call(this);
	this.buildBackground();

	this.textE = BlockGraphics.create.valueText(this.text, this.group);
	GuiElements.update.color(this.textE, this.dimConstants.valueText.fill);
	this.hitBoxE = BlockGraphics.create.slotHitBox(this.group);

	// When the SlotShape is touched, tell TR the Slot was touched
	TouchReceiver.addListenersSlot(this.textE, this.slot);
	TouchReceiver.addListenersSlot(this.hitBoxE, this.slot);
};

/**
 * Create the element representing the background
 */
EditableSlotShape.prototype.buildBackground = function() {
	GuiElements.markAbstract();
};

/**
 * Set the text of the SlotShape
 * @param {string} text
 */
EditableSlotShape.prototype.changeText = function(text) {
	this.text = text; //Store value
	GuiElements.update.text(this.textE, text); //Update text.
	this.updateDim();
	this.updateAlign();
};

/**
 * Make the SlotShape appear selected
 */
EditableSlotShape.prototype.select = function() {
	const dC = this.dimConstants;
	GuiElements.update.color(this.textE, dC.valueText.selectedFill);
};

/**
 * Make the SlotShape appear deselected
 */
EditableSlotShape.prototype.deselect = function() {
	const dC = this.dimConstants;
	GuiElements.update.color(this.textE, dC.valueText.fill);
};

/**
 * Make the SlotShape's text grayed out
 */
EditableSlotShape.prototype.grayOutValue = function() {
	const dC = this.dimConstants;
	GuiElements.update.color(this.textE, dC.valueText.grayedFill);
	this.isGray = true;
};

/**
 * Stop the SlotShape's text from being grayed out
 */
EditableSlotShape.prototype.unGrayOutValue = function() {
	const dC = this.dimConstants;
	GuiElements.update.color(this.textE, dC.valueText.selectedFill);
	this.isGray = false;
};

/**
 * Compute the width and height of the SlotShape.  Called agin when text changes
 */
EditableSlotShape.prototype.updateDim = function() {
	const dC = this.dimConstants;
	this.textW = GuiElements.measure.textWidth(this.textE); //Measure text element.
	let width = this.textW + dC.slotLMargin + dC.slotRMargin; //Add space for margins.
	let height = dC.slotHeight; //Has no child, so is just the default height.
	if (width < dC.slotWidth) { //Check if width is less than the minimum.
		width = dC.slotWidth;
	}
	this.width = width; //Save computations.
	this.height = height;
};

/**
 * Move all the parts of the SlotShape to the correct location
 */
EditableSlotShape.prototype.updateAlign = function() {
	const dC = this.dimConstants;
	const textX = (this.width + dC.slotLMargin - dC.slotRMargin) / 2 - this.textW / 2; //Centers the text horizontally.
	const textY = EditableSlotShape.charHeight / 2 + this.height / 2; //Centers the text vertically
	BlockGraphics.update.text(this.textE, textX, textY); //Move the text.
	const bGHB = BlockGraphics.hitBox; //Get data about the size of the hit box.
	const hitX = bGHB.hMargin; //Compute its x and y coords.
	const hitY = bGHB.vMargin;
	const hitW = this.width + bGHB.hMargin * 2; //Compute its width and height.
	const hitH = this.height + bGHB.vMargin * 2;
	GuiElements.update.rect(this.hitBoxE, hitX, hitY, hitW, hitH); //Move/resize its rectangle.
};
/**
 * Controls the graphics for a RectSlot
 * @param {Slot} slot
 * @param {string} initialText
 * @constructor
 */
function RectSlotShape(slot, initialText) {
	EditableSlotShape.call(this, slot, initialText, RectSlotShape);
}
RectSlotShape.prototype = Object.create(EditableSlotShape.prototype);
RectSlotShape.prototype.constructor = RectSlotShape;

RectSlotShape.setConstants = function() {
	const RSS = RectSlotShape;
	RSS.slotLMargin = BlockGraphics.string.slotHMargin;
	RSS.slotRMargin = BlockGraphics.string.slotHMargin;
	RSS.slotHeight = BlockGraphics.string.slotHeight;
	RSS.slotWidth = BlockGraphics.string.slotWidth;
	RSS.valueText = {};
	RSS.valueText.fill = BlockGraphics.valueText.fill;
	RSS.valueText.grayedFill = BlockGraphics.valueText.grayedFill;
	RSS.valueText.selectedFill = BlockGraphics.valueText.selectedFill;

	RSS.slotSelectedFill = BlockGraphics.reporter.slotSelectedFill;
	RSS.slotFill = BlockGraphics.reporter.slotFill;
};

/**
 * @inheritDoc
 */
RectSlotShape.prototype.buildSlot = function() {
	EditableSlotShape.prototype.buildSlot.call(this);
};

/**
 * @inheritDoc
 */
RectSlotShape.prototype.buildBackground = function() {
	this.slotE = BlockGraphics.create.slot(this.group, 3);
	TouchReceiver.addListenersSlot(this.slotE, this.slot);
};

/**
 * @inheritDoc
 */
RectSlotShape.prototype.updateDim = function() {
	EditableSlotShape.prototype.updateDim.call(this);
};

/**
 * @inheritDoc
 */
RectSlotShape.prototype.updateAlign = function() {
	EditableSlotShape.prototype.updateAlign.call(this);
	BlockGraphics.update.path(this.slotE, 0, 0, this.width, this.height, 3, true); //Fix! BG
};

/**
 * @inheritDoc
 */
RectSlotShape.prototype.select = function() {
	const RSS = RectSlotShape;
	EditableSlotShape.prototype.select.call(this);
	GuiElements.update.color(this.slotE, RSS.slotSelectedFill);
};

/**
 * @inheritDoc
 */
RectSlotShape.prototype.deselect = function() {
	const RSS = RectSlotShape;
	EditableSlotShape.prototype.deselect.call(this);
	GuiElements.update.color(this.slotE, RSS.slotFill);
};
/**
 * Controls the graphics of a HexSlot
 * @param {Slot} slot
 * @constructor
 */
function HexSlotShape(slot) {
	SlotShape.call(this, slot);
}
HexSlotShape.prototype = Object.create(SlotShape.prototype);
HexSlotShape.prototype.constructor = HexSlotShape;

HexSlotShape.setConstants = function() {
	const HSS = HexSlotShape;
	const bG = BlockGraphics.predicate;
	HSS.slotWidth = bG.slotWidth;
	HSS.slotHeight = bG.slotHeight;
};

/**
 * @inheritDoc
 */
HexSlotShape.prototype.buildSlot = function() {
	const HSS = HexSlotShape;
	SlotShape.prototype.buildSlot.call(this);
	this.slotE = BlockGraphics.create.slot(this.group, 2, this.slot.parent.category, this.active);
	TouchReceiver.addListenersSlot(this.slotE, this.slot); //Adds event listeners.
};

/**
 * @inheritDoc
 */
HexSlotShape.prototype.updateDim = function() {
	const HSS = HexSlotShape;
	this.width = HSS.slotWidth;
	this.height = HSS.slotHeight;
};

/**
 * @inheritDoc
 */
HexSlotShape.prototype.updateAlign = function() {
	BlockGraphics.update.path(this.slotE, 0, 0, this.width, this.height, 2, true);
};

/**
 * @inheritDoc
 */
HexSlotShape.prototype.makeActive = function() {
	if (!this.active) {
		this.active = true;
		BlockGraphics.update.hexSlotGradient(this.slotE, this.slot.parent.category, this.active);
	}
};

/**
 * @inheritDoc
 */
HexSlotShape.prototype.makeInactive = function() {
	if (this.active) {
		this.active = false;
		BlockGraphics.update.hexSlotGradient(this.slotE, this.slot.parent.category, this.active);
	}
};
/**
 * Controls the graphics for a RoundSlot
 * @param {Slot} slot
 * @param {string} initialText
 * @constructor
 */
function RoundSlotShape(slot, initialText) {
	EditableSlotShape.call(this, slot, initialText, RoundSlotShape);
}
RoundSlotShape.prototype = Object.create(EditableSlotShape.prototype);
RoundSlotShape.prototype.constructor = RoundSlotShape;

RoundSlotShape.setConstants = function() {
	const RSS = RoundSlotShape;
	const bG = BlockGraphics.reporter;
	RSS.slotLMargin = bG.slotHMargin;
	RSS.slotRMargin = bG.slotHMargin;
	RSS.slotHeight = bG.slotHeight;
	RSS.slotWidth = bG.slotWidth;

	RSS.valueText = {};
	RSS.valueText.fill = BlockGraphics.valueText.fill;
	RSS.valueText.grayedFill = BlockGraphics.valueText.grayedFill;
	RSS.valueText.selectedFill = BlockGraphics.valueText.selectedFill;

	RSS.slotSelectedFill = bG.slotSelectedFill;
	RSS.slotFill = bG.slotFill;
};

/**
 * @inheritDoc
 */
RoundSlotShape.prototype.buildSlot = function() {
	EditableSlotShape.prototype.buildSlot.call(this);
};

/**
 * @inheritDoc
 */
RoundSlotShape.prototype.buildBackground = function() {
	this.slotE = BlockGraphics.create.slot(this.group, 1);
	TouchReceiver.addListenersSlot(this.slotE, this.slot);
};

/**
 * @inheritDoc
 */
RoundSlotShape.prototype.updateDim = function() {
	EditableSlotShape.prototype.updateDim.call(this);
};

/**
 * @inheritDoc
 */
RoundSlotShape.prototype.updateAlign = function() {
	EditableSlotShape.prototype.updateAlign.call(this);
	BlockGraphics.update.path(this.slotE, 0, 0, this.width, this.height, 1, true); //Fix! BG
};

/**
 * @inheritDoc
 */
RoundSlotShape.prototype.select = function() {
	const RSS = RoundSlotShape;
	EditableSlotShape.prototype.select.call(this);
	GuiElements.update.color(this.slotE, RSS.slotSelectedFill);
};

/**
 * @inheritDoc
 */
RoundSlotShape.prototype.deselect = function() {
	const RSS = RoundSlotShape;
	EditableSlotShape.prototype.deselect.call(this);
	GuiElements.update.color(this.slotE, RSS.slotFill);
};
/**
 * Controls the DropDown graphic for a DropSlot
 * @param {Slot} slot
 * @param {string} initialText
 * @constructor
 */
function DropSlotShape(slot, initialText) {
	EditableSlotShape.call(this, slot, initialText, DropSlotShape);
}
DropSlotShape.prototype = Object.create(EditableSlotShape.prototype);
DropSlotShape.prototype.constructor = DropSlotShape;
DropSlotShape.setConstants = function() {
	const DSS = DropSlotShape;
	const bG = BlockGraphics.dropSlot;
	DSS.bgColor = bG.bg;
	DSS.bgOpacity = bG.bgOpacity;
	DSS.selectedBgOpacity = bG.selectedBgOpacity;
	DSS.triColor = bG.triColor;
	DSS.selectedTriColor = bG.selectedTriColor;
	DSS.triW = bG.triW;
	DSS.triH = bG.triH;

	DSS.slotLMargin = bG.slotHMargin;
	DSS.textMargin = DSS.slotLMargin;
	DSS.slotRMargin = DSS.slotLMargin + DSS.textMargin + DSS.triW;
	DSS.slotHeight = bG.slotHeight;
	DSS.slotWidth = bG.slotWidth;

	DSS.valueText = {};
	DSS.valueText.fill = bG.textFill;
	DSS.valueText.grayedFill = BlockGraphics.valueText.grayedFill;
	DSS.valueText.selectedFill = bG.textFill;
};

/**
 * @inheritDoc
 */
DropSlotShape.prototype.buildSlot = function() {
	EditableSlotShape.prototype.buildSlot.call(this);
};

/**
 * @inheritDoc
 */
DropSlotShape.prototype.buildBackground = function() {
	this.bgE = this.generateBg();
	this.triE = this.generateTri();
};

/**
 * Creates the dark, semi-transparent background of the Slot
 * @return {Node} - The rectangle for the background
 */
DropSlotShape.prototype.generateBg = function() {
	const DSS = DropSlotShape;
	const bgE = GuiElements.create.rect(this.group);
	GuiElements.update.color(bgE, DSS.bgColor);
	GuiElements.update.opacity(bgE, DSS.bgOpacity);
	TouchReceiver.addListenersSlot(bgE, this.slot);
	return bgE;
};

/**
 * Creates the triangle for the side of the DropSlotShape
 * @return {Node} - an SVG path object
 */
DropSlotShape.prototype.generateTri = function() {
	const DSS = DropSlotShape;
	const triE = GuiElements.create.path(this.group);
	GuiElements.update.color(triE, DSS.triColor);
	TouchReceiver.addListenersSlot(triE, this.slot);
	return triE;
};

/**
 * @inheritDoc
 */
DropSlotShape.prototype.updateDim = function() {
	EditableSlotShape.prototype.updateDim.call(this);
};

/**
 * @inheritDoc
 */
DropSlotShape.prototype.updateAlign = function() {
	const DSS = DropSlotShape;
	// Align the text and hit box of the Slot
	EditableSlotShape.prototype.updateAlign.call(this);

	// Compute the location of the triangle
	const triX = this.width - DSS.slotRMargin + DSS.textMargin;
	const triY = this.height / 2 - DSS.triH / 2;
	GuiElements.update.triangle(this.triE, triX, triY, DSS.triW, 0 - DSS.triH);

	// Align the background
	GuiElements.update.rect(this.bgE, 0, 0, this.width, this.height);
};

/**
 * @inheritDoc
 */
DropSlotShape.prototype.select = function() {
	const DSS = DropSlotShape;
	EditableSlotShape.prototype.select.call(this);
	GuiElements.update.opacity(this.bgE, DSS.selectedBgOpacity);
	GuiElements.update.color(this.triE, DSS.selectedTriColor);
};

/**
 * @inheritDoc
 */
DropSlotShape.prototype.deselect = function() {
	const DSS = DropSlotShape;
	EditableSlotShape.prototype.deselect.call(this);
	GuiElements.update.opacity(this.bgE, DSS.bgOpacity);
	GuiElements.update.color(this.triE, DSS.triColor);
};
/**
 * An interface for parts of a Block such as LabelText, BlockIcons, and Slots.
 * @param {Block} parent - The Block this part is a member of
 * @constructor
 */
function BlockPart(parent){
	DebugOptions.markAbstract();
	this.parent = parent;
	this.isSlot = false;
	this.width = NaN;
	this.height = NaN;
	this.isEndOfLine = false; //Set to true if the next block part should rap to next line
}

/**
 * Move the part to the specified location and returns where the next part should be.
 * Called by the Block any time it has changed size/shape
 * @param {number} x - The x coord the part should have relative to the Block it is in
 * @param {number} y - The y coord ths part should have measured from the center of the part
 * @return {number} - The width of the part, indicating how much the next item in the Block should be shifted over.
 */
BlockPart.prototype.updateAlign = function(x, y) {
	DebugOptions.markAbstract();
	return this.width;
};

/**
 * Makes this part recalculate its dimensions, which it stores in this.width and this.height for the Block to retrieve.
 */
BlockPart.prototype.updateDim = function() {
	DebugOptions.markAbstract();
	this.width = NaN;
	this.height = NaN;
};

/**
 * Creates a text representation of the part
 * @return {string}
 */
BlockPart.prototype.textSummary = function() {
	DebugOptions.markAbstract();
	return "";
};

/**
 * Makes the part appear active
 */
BlockPart.prototype.makeActive = function() {

};

/**
 * Makes the part appear inactive
 */
BlockPart.prototype.makeInactive = function() {

};

/**
 * @param {boolean} active
 */
BlockPart.prototype.setActive = function(active) {
	if(active){
		this.makeActive();
	} else {
		this.makeInactive();
	}
};

/**
 * Slot is an abstract class that represents a space on a Block where data can be entered and other Blocks can be
 * attached.
 * Every Slot has a parent Block which it relies on heavily.
 * Slots can be edited in different ways, as indicated by their shape.
 * Slots can accept different types of Blocks and can automatically convert Data into a certain type.
 * Block implementations first update their Slots (compute their values) before accessing them during execution.
 * Each Slot has a slotShape, as determined by the subclass that manages the appearance of the slot when nothing
 * is snapped to it.
 * Slots must implement highlight(); textSummary(); and getDataNotFromChild();
 * @constructor
 * @param {Block} parent - The Block this Slot is a part of. Slots can't change their parents.
 * @param {string} key - The name of the Slot. Used for reading and writing save files.
 * @param {number} snapType - [none, numStrBool, bool, list, any] The type of Blocks which can be attached to the Slot.
 * @param {number} outputType - [any, num, string, bool, list] The type of Data the Slot should convert to.
 */
function Slot(parent, key, snapType, outputType){
	DebugOptions.validateNonNull(parent, key, snapType, outputType);
	//Key always includes "_" and is of the form DataType_description. See BlockDefs for examples
	DebugOptions.assert(key.includes("_"));
	//Store data passed by constructor.
	this.snapType = snapType;
	this.outputType = outputType;
	this.parent = parent; //Parent Block.
	this.key = key;
	this.hasChild = false; //Nothing is attached yet.
	this.child = null; //Stores attached Block.
	this.width = 0; //Will be computed later using updateDim
	this.height = 0;
	this.x = 0;
	this.y = 0;

	//All Block parts have this property.  Used to allow Blocks to identify if their parent is a Slot
	this.isSlot = true;
	this.running = 0; //Running: 0 = Not started 2 = Running 3 = Completed //TODO: Switch to enum
	this.resultIsFromChild = false; //The result to return comes from a child Block, not a direct input.
	this.resultData = null; //passed to Block for use in implementation.
	/** @type {SlotShape} */
	this.slotShape = undefined;
}
Slot.prototype = Object.create(BlockPart.prototype);
Slot.prototype.constructor = Slot;

Slot.setConstants = function(){
	//The type of Blocks which can be attached to the Slot.
	Slot.snapTypes = {};
	Slot.snapTypes.none = 0; //Nothing can attach (dropdowns often)
	Slot.snapTypes.numStrBool = 1; //Blocks with return type num, string, or bool can attach (will be auto cast).
	Slot.snapTypes.bool = 2; //Only Blocks that return bool can attach.
	Slot.snapTypes.list = 3; //Only Blocks that return lists can attach.
	Slot.snapTypes.any = 4; //Any type of Block can attach (used for the = Block).
	//The type of Data the Slot should convert to before outputting. Guarantees the Block gets the type it wants.
	Slot.outputTypes = {};
	Slot.outputTypes.any = 0; //No conversion will occur.
	Slot.outputTypes.num = 1; //Convert to num.
	Slot.outputTypes.string = 2; //Convert to string.
	Slot.outputTypes.bool = 3; //Convert to bool.
	Slot.outputTypes.list = 4; //Convert to list.
};

/** Recursively updates dimensions and those of children. */
Slot.prototype.updateDim = function(){
	if(this.hasChild){
		//Width is determined by child if it has one.
		this.child.updateDim(); //Pass on message.
		this.width = this.child.width;
		this.height = this.child.height;
	}
	else{
		//Otherwise, the size of the slot graphic is used.
		this.width = this.slotShape.width;
		this.height = this.slotShape.height;
	}
};

/**
 * Recursively updates Slot's alignment and alignment of children.
 * @param {number} x - The x coord the Slot should have when completed relative to the Block it is in.
 * @param {number} y - The y coord ths Slot should have measured from the center of the Slot.
 * @return {number} - The width of the Slot, indicating how much the next item should be shifted over.
 * TODO: Measure y from top of Slot to make it consistent with Block.
 */
Slot.prototype.updateAlign = function(x, y){
	DebugOptions.validateNumbers(x, y);
	if(this.hasChild){
		//The x and y coords the child should have.
		//TODO: Use relToAbs for this
		const xCoord = x + this.parent.x; //converts coord from inside this Block's g to outside g
		const yCoord = y + this.parent.y - this.height / 2; //Converts y to make it relative to top of Block.
		this.x = x; //Sets this Slot's x.
		this.y = y - this.height / 2; //Converts y to make it relative to top of Block.
		return this.child.updateAlign(xCoord, yCoord); //Update child.
		//This Slot itself does not need to change visibly because it is covered by a Block.
	}
	else{
		this.x = x; //Sets this Slot's x.
		this.y = y - this.height / 2; //Converts y to make it relative to top of Block.
		this.slotShape.move(this.x, this.y); //Moves the graphic to the correct position
		return this.width;
	}
};

/**
 * Attaches a Block to the Slot.  Changes the Block's stack to that of the Slot
 * @param {Block} block - The Block to attach.
 * TODO: Stop code that is currently running.
 */
Slot.prototype.snap = function(block){
	DebugOptions.validateNonNull(block);
	block.parent = this; //Set the Block's parent.
	if(this.hasChild){ //If the Slot already has a child, detach it and move it out of the way.
		const prevChild = this.child;
		prevChild.unsnap(); //Detach the old Block.
		prevChild.stack.shiftOver(block.stack.dim.rw, block.stack.dim.rh); //Move it over. //Fix! stack.dim
	}
	this.hasChild = true;
	this.child = block; //Set child.
	this.slotShape.hide(); //Slot graphics are covered and should be hidden.
	if(block.stack != null) {
		const oldG = block.stack.group; //Old group can be deleted.
		block.stack.remove(); //TODO: use delete() instead.
		block.changeStack(this.parent.stack); //Move Block into this stack.
		oldG.remove();
	}
	if(this.parent.stack != null) {
		this.parent.stack.updateDim(); //Update parent's dimensions.
	}
};

/**
 * Recursively changes the stack of the Slot's children.
 * @param {BlockStack} stack - The stack to change to.
 */
Slot.prototype.changeStack = function(stack){
	DebugOptions.validateNonNull(stack);
	if(this.hasChild){
		this.child.changeStack(stack); //Pass the message.
	}
};

/**
 * Recursively stops the Slot and its children.
 */
Slot.prototype.stop = function(){
	this.clearMem(); //Stop Slot.
	if(this.hasChild){
		this.child.stop(); //Stop children.
	}
};

/**
 * Update's the Slot's execution. Returns if it is still running.
 * @return {ExecutionStatus} - Is the Slot still running or has crashed?
 */
Slot.prototype.updateRun = function(){
	if(this.running === 3){ //If the Slot has finished running, no need to update.
		return new ExecutionStatusDone(); //Done running
	}
	if(this.hasChild){
		let childExecStatus = this.child.updateRun();
		if(!childExecStatus.isRunning()){ //Update the child first until it is done.
			if(childExecStatus.hasError()){
				this.running = 3;
				return childExecStatus;
			} else{
				this.running = 3; //Copy data from child and finish execution.
				this.resultData = this.convertData(childExecStatus.getResult()); //Convert it to the proper type.
				this.resultIsFromChild = true;
				return new ExecutionStatusDone();
			}
		}
		else{
			this.running = 2; //Waiting for child to finish.
			return new ExecutionStatusRunning(); //Still running
		}
	}
	else{
		//The result is not from the child, so the getData function will figure out what to do.
		this.running = 3;
		this.resultIsFromChild = false;
		return new ExecutionStatusDone(); //Done running
	}
};

/**
 * Overridden by subclasses. Returns the result of the Slot's execution.
 * @return {Data} - The result of the Slot's execution.
 */
Slot.prototype.getData = function(){
	if(this.running === 3){
		//If the Slot finished executing, resultIsFromChild determines where to read the result from.
		if(this.resultIsFromChild){
			return this.resultData;
		}
		else{
			return this.getDataNotFromChild();
		}
	}
	//If it isn't done executing and has a child, throw an error.
	DebugOptions.assert(!this.hasChild);
	DebugOptions.assert(false);
};

/**
 * Returns the result if the slot has no child
 * @abstract
 */
Slot.prototype.getDataNotFromChild = function(){
	GuiElements.markAbstract();
};

/** Recursively updates the dimensions of the BlockStack. */
Slot.prototype.updateStackDim = function(){
	if(this.hasChild){
		this.child.updateStackDim(); //Pass on message.
	}
};

/** Removes the child and makes the Slot's graphics visible again. */
Slot.prototype.removeChild = function(){
	this.hasChild = false;
	this.child = null;
	this.slotShape.show();
};

/**
 * Checks if the moving BlockStack fits within this Slot. Then recursively passes message on to children.
 * Returns nothing. Results stored in CodeManager.fit.
 * @return {boolean} - true iff this Slot or one of its descendants can accept the moving blocks
 */
Slot.prototype.findBestFit = function(){
	// Only the highest eligible slot on the connection tree is allowed to accept the blocks.
	let childHasMatch = false;
	// The slot is a leaf unless one of its decedents is a leaf.
	if(this.hasChild){
		childHasMatch = this.child.findBestFit(); // Pass on the message.
	}
	if(childHasMatch){
		// Don't bother checking this slot if it already has a matching decedents.
		return true;
	}

	// shorthand
	const move = CodeManager.move;
	const fit = CodeManager.fit;

	// Use coords relative to screen.
	const x = this.getAbsX();
	const y = this.getAbsY();
	const myHeight = this.getAbsHeight();
	const myWidth = this.getAbsWidth();

	// Is the BlockStack's type compatible with the Slot?
	const typeMatches = this.checkFit(move.returnType);

	// Does the bounding box of the BlockStack overlap with the bounding box of the Slot?
	const width = move.bottomX - move.topX;
	const height = move.bottomY - move.topY;
	const locationMatches = move.rInRange(move.topX, move.topY, width, height, x,y, myWidth, myHeight);

	// If so, use distance to find the best fit
	if(typeMatches && locationMatches){
		const xDist = move.touchX - (x + this.width / 2); //Compute the distance.
		const yDist = move.touchY - (y + this.height / 2);
		const dist = xDist * xDist + yDist * yDist;
		if(!fit.found || dist < fit.dist){
			fit.found = true; //Store the match.
			fit.bestFit = this;
			fit.dist = dist;
		}
		// Found match
		return true;
	}
	// No compatible descendants
	return false;
};

/**
 * Determines if a Block's return type is compatible with this Slot's snap type.
 * @param {number} outputType - [none, num, string, bool, list] The return type of the Block.
 * @return {boolean} - Is the return type compatible with the snap type?
 */
Slot.prototype.checkFit = function(outputType){
	DebugOptions.validateNonNull(outputType);
	const sT = Slot.snapTypes;
	const rT = Block.returnTypes;
	const snapType = this.snapType;
	if(snapType === sT.none){
		//If the Slot accepts nothing, it isn't compatible.
		return false;
	}
	else if(snapType === sT.any){
		//If the Slot accepts anything, it is compatible.
		return true;
	}
	else if(snapType === sT.numStrBool){
		//Num, string, or bool is compatible.
		return outputType === rT.num || outputType === rT.string || outputType === rT.bool;
	}
	else if(snapType === sT.bool){
		//Only bool is compatible.
		return outputType === rT.bool;
	}
	else if(snapType === sT.list){
		//Only list is compatible.
		return outputType === rT.list;
	}
	else{
		//Should never be called.
		DebugOptions.assert(false);
		return false;
	}
};

// These functions convert between screen (absolute) coordinates and local (relative) coordinates.
/**
 * @param {number} x
 * @returns {number}
 */
Slot.prototype.relToAbsX = function(x){
	return this.parent.relToAbsX(x + this.x);
};
/**
 * @param {number} y
 * @returns {number}
 */
Slot.prototype.relToAbsY = function(y){
	return this.parent.relToAbsY(y + this.y);
};
/**
 * @param {number} x
 * @returns {number}
 */
Slot.prototype.absToRelX = function(x){
	return this.parent.absToRelX(x) - this.x;
};
/**
 * @param {number} y
 * @returns {number}
 */
Slot.prototype.absToRelY = function(y){
	return this.parent.absToRelY(y) - this.y;
};
/**
 * Returns the x coord of the Slot relative to the screen (not the group it is contained in).
 * @return {number} - The x coord of the Slot relative to the screen.
 */
Slot.prototype.getAbsX = function(){
	return this.relToAbsX(0);
};
/**
 * Returns the y coord of the Slot relative to the screen (not the group it is contained in).
 * @return {number} - The y coord of the Slot relative to the screen.
 */
Slot.prototype.getAbsY = function(){//Fix for tabs
	return this.relToAbsY(0);
};
/**
 * @returns {number}
 */
Slot.prototype.getAbsWidth = function(){
	return this.relToAbsX(this.width) - this.getAbsX();
};
/**
 * @returns {number}
 */
Slot.prototype.getAbsHeight = function(){
	return this.relToAbsY(this.height) - this.getAbsY();
};

/**
 * Copies data and blocks from a Slot into this Slot
 * @param {Slot} slot - The slot to copy from
 */
Slot.prototype.copyFrom = function(slot){
	DebugOptions.validateNonNull(slot);
	if(slot.hasChild){
		this.snap(slot.child.duplicate(0,0));
	}
};

/** Clears the result data of the Slot and resets its running state. Is called by Block's clearMem function. */
Slot.prototype.clearMem = function(){
	this.resultData = null;
	this.running = 0;
};

/**
 * Converts the provided data to match the Slot's output type and returns it.
 * TODO: make NumSlot override this and lock value to min/max.  Perhaps combine with sanitize
 * @param {Data} data - The Data to convert.
 * @return {Data} - The converted Data.
 */
Slot.prototype.convertData = function(data){
	DebugOptions.validateNonNull(data);
	const outType = this.outputType;
	const oT = Slot.outputTypes;
	if(outType === oT.any){
		//If any type will do, just return it.
		return data;
	}
	else if(outType === oT.num){
		//Convert to a num.
		return data.asNum();
	}
	else if(outType === oT.string){
		//Convert to a string.
		return data.asString();
	}
	else if(outType === oT.bool){
		//Convert to a bool.
		return data.asBool();
	}
	else if(outType === oT.list){
		//Convert to a list.
		return data.asList();
	}
	//Should not be called.
	DebugOptions.assert(false);
	return null;
};

/** Overridden by subclasses. Updates the available broadcast messages. */
Slot.prototype.updateAvailableMessages = function(){

};

/**
 * Recursively renames a variable
 * @param {Variable} variable
 */
Slot.prototype.renameVariable = function(variable){
	this.passRecursively("renameVariable",variable);
};

/**
 * Recursively deletes a variable
 * @param {Variable} variable
 */
Slot.prototype.deleteVariable = function(variable){
	this.passRecursively("deleteVariable",variable);
};

/**
 * Recursively renames a list
 * @param {List} list
 */
Slot.prototype.renameList = function(list){
	this.passRecursively("renameList",list);
};

/**
 * Deletes a list
 * @param {List} list
 */
Slot.prototype.deleteList = function(list){
	this.passRecursively("deleteList",list);
};

/**
 * Recursively counts devices in use of a certain device type
 * @param deviceClass - A subclass of the Device class
 * @returns {number}
 */
Slot.prototype.countDevicesInUse = function(deviceClass){
	if(this.hasChild){
		return this.child.countDevicesInUse(deviceClass);
	}
	return 0;
};

/**
 * Calls the given function on its children, children's children, etc.
 * Intercepts messages intended for this object and calls them
 * @param {string} message - The message to send
 */
Slot.prototype.passRecursivelyDown = function(message){
	const myMessage = message;
	let funArgs = Array.prototype.slice.call(arguments, 1);
	if(myMessage === "updateConnectionStatus" && this.updateConnectionStatus != null) {
		// Implemented by DeviceDropSlots
		this.updateConnectionStatus.apply(this, funArgs);
	}
	if(myMessage === "renameRecording" && this.renameRecording != null) {
		// Implemented by SoundDropSlots
		this.renameRecording.apply(this, funArgs);
	}
	if(myMessage === "deleteRecording" && this.deleteRecording != null) {
		// Implemented by SoundDropSlots
		this.deleteRecording.apply(this, funArgs);
	}

	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);

	if(myMessage === "showDeviceDropDowns" && this.showDeviceDropDowns != null) {
		// Implemented by DeviceDropSlots
		this.showDeviceDropDowns.apply(this, funArgs);
	}
	if(myMessage === "hideDeviceDropDowns" && this.hideDeviceDropDowns != null) {
		// Implemented by DeviceDropSlots
		this.hideDeviceDropDowns.apply(this, funArgs);
	}
};

/**
 * Calls the given function on its children
 * @param {string} functionName - The name of the function being called
 */
Slot.prototype.passRecursively = function(functionName){
	const args = Array.prototype.slice.call(arguments, 1);
	if(this.hasChild){
		this.child[functionName].apply(this.child, args);
	}
};

/**
 * Checks if the given variable is ever referenced
 * @param {Variable} variable - The variable to check
 * @returns {boolean} - Returns if the variable is used by the Slot's descendants
 */
Slot.prototype.checkVariableUsed = function(variable){
	if(this.hasChild){
		return this.child.checkVariableUsed(variable);
	}
	return false;
};

/**
 * Checks if the given list is ever referenced
 * @param {List} list - The list to check
 * @returns {boolean} - Returns if the list is used by the Slot's descendants
 */
Slot.prototype.checkListUsed = function(list){
	if(this.hasChild){
		return this.child.checkListUsed(list);
	}
	return false;
};

/**
 * Appends information about this Slot to the document
 * @param {Document} xmlDoc - The document to append to
 * @return {Node} - The XML node of the Slot
 */
Slot.prototype.createXml = function(xmlDoc){
	DebugOptions.validateNonNull(xmlDoc);
	const slot = XmlWriter.createElement(xmlDoc,"slot");
	XmlWriter.setAttribute(slot,"key",this.key);
	if(this.hasChild){
		const child = XmlWriter.createElement(xmlDoc,"child");
		child.appendChild(this.child.createXml(xmlDoc));
		slot.appendChild(child);
	}
	return slot;
};

/**
 * Imports the data from the node to this Slot
 * @param {Node} slotNode
 * @return {Slot} - A reference to this Slot
 */
Slot.prototype.importXml = function(slotNode) {
	DebugOptions.validateNonNull(slotNode);
	const childNode = XmlWriter.findSubElement(slotNode, "child");
	const blockNode = XmlWriter.findSubElement(childNode, "block");
	if(blockNode != null) {
		const childBlock = Block.importXml(blockNode);
		if(childBlock != null) {
			this.snap(childBlock);
		}
	}
	return this;
};

/**
 * Returns this Slot's key
 * @returns {string}
 */
Slot.prototype.getKey = function(){
	return this.key;
};

/**
 * Draws a white border around the slot to indicate that the blocks being dragged will snap to it if released.
 * @abstract
 */
Slot.prototype.highlight = function(){
	DebugOptions.markAbstract();
};

/**
 * Creates a string representing the slot and its content
 * @return {string}
 * @abstract
 */
Slot.prototype.textSummary = function(){
	DebugOptions.markAbstract();
};

/**
 * Makes the Slot appear active
 */
Slot.prototype.makeActive = function(){
	this.slotShape.makeActive();
};

/**
 * Makes the Slot appear inactive
 */
Slot.prototype.makeInactive = function(){
	this.slotShape.makeInactive();
};

/**
 * Makes the slot appear active/inactive
 * @param {boolean} active - Whether the Slot should appear active
 */
Slot.prototype.setActive = function(active){
	if(active){
		this.makeActive();
	} else {
		this.makeInactive();
	}
};

/**
 * Called when the SlotShape is tapped
 */
Slot.prototype.onTap = function() {

};

/**
 * Returns whether this Slot is an EditableSlot
 * @return {boolean}
 */
Slot.prototype.isEditable = function() {
	return false;
};
/**
 * HexSlot is a subclass of Slot. Unlike Slot, it can actually be instantiated.
 * It creates a hexagonal Slot that can hold Blocks but not be edited via InputPad or dialog.
 * Its input type and output type is always bool.
 * @constructor
 * @param {Block} parent - The Block this Slot is a part of.
 * @param {string} key - The name of the Slot. Used for reading and writing save files.
 * @param {number} snapType - [none,numStrBool,bool,list,any] The type of Blocks which can be attached to the HexSlot.
 */
function HexSlot(parent, key, snapType) {
	Slot.call(this, parent, key, snapType, Slot.outputTypes.bool); //Call constructor.
	this.slotShape = new HexSlotShape(this);
	this.slotShape.show();
}
HexSlot.prototype = Object.create(Slot.prototype);
HexSlot.prototype.constructor = HexSlot;

/**
 * @inheritDoc
 * TODO: fix BlockGraphics
 */
HexSlot.prototype.highlight = function() {
	const slotGraphicShowing = !this.hasChild;
	Highlighter.highlight(this.getAbsX(), this.getAbsY(), this.width, this.height, 2, slotGraphicShowing);
};

/**
 * @inheritDoc
 * @return {string}
 */
HexSlot.prototype.textSummary = function() {
	//Angle brackets are used because it is a HexSlot.
	if (this.hasChild) { //If it has a child, just use an ellipsis.
		return "<...>";
	} else { //Otherwise, it is empty.
		return "<>";
	}
};

/**
 * @inheritDoc
 * @return {Data}
 */
HexSlot.prototype.getDataNotFromChild = function() {
	return new BoolData(false, false); //The Slot is empty. Return default value of false.
};
/**
 * EditableSlot is an abstract class representing Slots that can have a value directly entered into them
 * in addition to accepting Blocks.
 * Subclasses must implement createInputSystem() and formatTextSummary()
 * @param {Block} parent
 * @param {string} key
 * @param {number} inputType
 * @param {number} snapType
 * @param {number} outputType - [any, num, string, select] The type of data that can be directly entered
 * @param {Data} data - The initial value of the Slot
 * @constructor
 */
function EditableSlot(parent, key, inputType, snapType, outputType, data) {
	Slot.call(this, parent, key, snapType, outputType);
	this.inputType = inputType;
	this.enteredData = data;
	this.editing = false;
	//TODO: make the slotShape be an extra argument
}
EditableSlot.prototype = Object.create(Slot.prototype);
EditableSlot.prototype.constructor = EditableSlot;

EditableSlot.setConstants = function() {
	/* The type of Data that can be directly entered into the Slot. */
	EditableSlot.inputTypes = {};
	EditableSlot.inputTypes.any = 0;
	EditableSlot.inputTypes.num = 1;
	EditableSlot.inputTypes.string = 2;
	EditableSlot.inputTypes.select = 3;
};

/**
 * @param {string} text - The text to set the slotShape to display
 * @param {boolean} updateDim - Should the Stack be told to update after this?
 */
EditableSlot.prototype.changeText = function(text, updateDim) {
	this.slotShape.changeText(text);
	if (updateDim && this.parent.stack != null) {
		this.parent.stack.updateDim(); //Update dimensions.
	}
};

/**
 * Tells the Slot to display an InputSystem so it can be edited. Also sets the slotShape to appear selected
 */
EditableSlot.prototype.edit = function() {
	DebugOptions.assert(!this.hasChild);
	if (!this.editing) {
		this.editing = true;
		this.slotShape.select();
		const inputSys = this.createInputSystem();
		inputSys.show(this.slotShape, this.updateEdit.bind(this), this.finishEdit.bind(this), this.enteredData);
	}
};

/**
 * @inheritDoc
 */
EditableSlot.prototype.onTap = function() {
	this.edit();
};

/**
 * Generates and displays an interface to modify the Slot's value
 */
EditableSlot.prototype.createInputSystem = function() {
	DebugOptions.markAbstract();
};

/**
 * Called by the InputSystem to change the Slot's data and displayed text
 * @param {Data} data - The Data the Slot should set its value to
 * @param {string} [visibleText] - The text the Slot should display as its value. Should correspond to Data.
 */
EditableSlot.prototype.updateEdit = function(data, visibleText) {
	DebugOptions.assert(this.editing);
	if (visibleText == null) {
		visibleText = this.dataToString(data);
	}
	this.enteredData = data;
	this.changeText(visibleText, true);
	SaveManager.markEdited();
};

/**
 * Called when an InputSystem finishes editing the Slot
 * @param {Data} data - The Data the Slot should be set to
 */
EditableSlot.prototype.finishEdit = function(data) {
	DebugOptions.assert(this.editing);
	if (this.editing) {
		this.setData(data, true, true); //Sanitize data, updateDims
		this.slotShape.deselect();
		this.editing = false;
		SaveManager.markEdited();
	}
};

/**
 * Returns whether the Slot is being edited
 * @return {boolean}
 */
EditableSlot.prototype.isEditing = function() {
	return this.editing;
};

/**
 * Assigns the Slot's Data and updates its text.w
 * @param {Data} data - The Data to set to
 * @param {boolean} sanitize - indicates whether the Data should be run through sanitizeData first
 * @param {boolean} updateDim - indicates if the Stack should updateDim after this
 */
EditableSlot.prototype.setData = function(data, sanitize, updateDim) {
	if (sanitize) {
		data = this.sanitizeData(data);
	}
	if (data == null) return;
	this.enteredData = data;
	this.changeText(this.dataToString(this.enteredData), updateDim);
};

/**
 * Converts the Slot's data to a displayable string. Subclasses override this method to apply formatting.
 * @param {Data} data
 * @return {string}
 */
EditableSlot.prototype.dataToString = function(data) {
	return data.asString().getValue();
};

/**
 * Validates that the Data is compatible with this Slot. May attempt to fix invalid Data.
 * By default, this function just converts the data to the correct type. Subclasses override this method.
 * Makes use of inputType
 * @param {Data|null} data - The Data to sanitize
 * @return {Data|null} - The sanitized Data or null if the Data cannot be sanitized
 */
EditableSlot.prototype.sanitizeData = function(data) {
	if (data == null) return null;
	const inputTypes = EditableSlot.inputTypes;
	// Only valid Data of the correct type is allowed
	if (this.inputType === inputTypes.string) {
		data = data.asString();
	} else if (this.inputType === inputTypes.num) {
		data = data.asNum();
	} else if (this.inputType === inputTypes.select) {
		data = data.asSelection();
	}
	if (data.isValid) {
		return data;
	}
	return null;
};

/**
 * @inheritDoc
 * @return {string}
 */
EditableSlot.prototype.textSummary = function() {
	let result = "...";
	if (!this.hasChild) { //If it has a child, just use an ellipsis.
		result = this.dataToString(this.enteredData);
	}
	return this.formatTextSummary(result);
};

/**
 * Takes a textSummary and performs string manipulation to format it according to the Slot type
 * @param {string} textSummary
 * @return {string}
 */
EditableSlot.prototype.formatTextSummary = function(textSummary) {
	DebugOptions.markAbstract();
};

/**
 * Reads the Data from the Slot, assuming that the Slot has no children.
 * @return {Data} - The Data stored in the Slot
 */
EditableSlot.prototype.getDataNotFromChild = function() {
	return this.enteredData;
};

/**
 * Converts the Slot and its children into XML, storing the value in the enteredData as well
 * @inheritDoc
 * @param {Document} xmlDoc
 * @return {Node}
 */
EditableSlot.prototype.createXml = function(xmlDoc) {
	let slot = Slot.prototype.createXml.call(this, xmlDoc);
	let enteredData = XmlWriter.createElement(xmlDoc, "enteredData");
	enteredData.appendChild(this.enteredData.createXml(xmlDoc));
	slot.appendChild(enteredData);
	return slot;
};

/**
 * @inheritDoc
 * @param {Node} slotNode
 * @return {EditableSlot}
 */
EditableSlot.prototype.importXml = function(slotNode) {
	Slot.prototype.importXml.call(this, slotNode);
	const enteredDataNode = XmlWriter.findSubElement(slotNode, "enteredData");
	const dataNode = XmlWriter.findSubElement(enteredDataNode, "data");
	if (dataNode != null) {
		const data = Data.importXml(dataNode);
		if (data != null) {
			this.setData(data, true, false);
		}
	}
	return this;
};

/**
 * @inheritDoc
 * @param {EditableSlot} slot
 */
EditableSlot.prototype.copyFrom = function(slot) {
	Slot.prototype.copyFrom.call(this, slot);
	this.setData(slot.enteredData, false, false);
};

/**
 * @inheritDoc
 * @return {boolean}
 */
EditableSlot.prototype.isEditable = function() {
	return true;
};
/**
 * RectSlots generally hold strings and are edited through a prompt dialog
 * @param {Block} parent
 * @param {string} key
 * @param {number} snapType
 * @param {number} outputType
 * @param {Data} data
 * @constructor
 */
function RectSlot(parent, key, snapType, outputType, data){
	EditableSlot.call(this, parent, key, EditableSlot.inputTypes.string, snapType, outputType, data);
	this.slotShape = new RectSlotShape(this, this.dataToString(data));
	this.slotShape.show();
}
RectSlot.prototype = Object.create(EditableSlot.prototype);
RectSlot.prototype.constructor = RectSlot;

/**
 * @inheritDoc
 */
RectSlot.prototype.highlight = function(){ //TODO: Fix BlockGraphics
	let isSlot = !this.hasChild;
	Highlighter.highlight(this.getAbsX(),this.getAbsY(),this.width,this.height,3,isSlot);
};

/**
 * @inheritDoc
 * @param {string} textSummary
 * @return {string}
 */
RectSlot.prototype.formatTextSummary = function(textSummary) {
	return "[" + textSummary + "]";
};

/**
 * @inheritDoc
 * @return {InputDialog}
 */
RectSlot.prototype.createInputSystem = function(){
	return new InputDialog(this.parent.textSummary(this), true);
};
/**
 * RoundSlots are Slots that generally hold numbers and are edited using the InputPad.  They can have special optios
 * on the InputPad that allow specific NumData, StringData, or SelectionData to be entered.
 * TODO: Make RoundSlot and DropSlot subclasses of a shared class to remove redundant code
 * @param {Block} parent
 * @param {string} key
 * @param {number} inputType
 * @param {number} snapType
 * @param {number} outputType
 * @param {Data} data
 * @param {boolean} positive - Whether the Slot should be limited to positive inputs
 * @param {boolean} integer - Whether the Slot should be limited to integer inputs
 * @constructor
 */
function RoundSlot(parent, key, inputType, snapType, outputType, data, positive, integer) {
	EditableSlot.call(this, parent, key, inputType, snapType, outputType, data);
	this.slotShape = new RoundSlotShape(this, this.dataToString(data));
	this.slotShape.show();
	// A list of additional options to show on the InputPad
	this.optionsList = [];
	this.positive = positive;
	this.integer = integer;
	// Text for the label that appears at te top of the pad
	this.labelText = "";
}
RoundSlot.prototype = Object.create(EditableSlot.prototype);
RoundSlot.prototype.constructor = RoundSlot;

/**
 * @inheritDoc
 */
RoundSlot.prototype.highlight = function() {
	const isSlot = !this.hasChild; //TODO: Fix! unclear.
	Highlighter.highlight(this.getAbsX(), this.getAbsY(), this.width, this.height, 1, isSlot);
};

/**
 * @inheritDoc
 * @param {string} textSummary
 * @return {string}
 */
RoundSlot.prototype.formatTextSummary = function(textSummary) {
	return "(" + textSummary + ")";
};

/**
 * Adds an additional option to be selected from the InputPad
 * @param {Data} data
 * @param {string} displayText
 */
RoundSlot.prototype.addOption = function(data, displayText) {
	if (displayText == null) {
		displayText = null;
	}
	const option = {};
	option.displayText = displayText;
	option.data = data;
	this.optionsList.push(option);
};

/**
 * Adds additional options to the InputPad's SelectPad
 * @param {InputWidget.SelectPad} selectPad - the SelectPad that will be added to this Slot's InputPad
 */
RoundSlot.prototype.populatePad = function(selectPad) {
	this.optionsList.forEach(function(option) {
		selectPad.addOption(option.data, option.displayText);
	});
};

/**
 * @inheritDoc
 * @return {InputPad}
 */
RoundSlot.prototype.createInputSystem = function() {
	const x1 = this.getAbsX();
	const y1 = this.getAbsY();
	const x2 = this.relToAbsX(this.width);
	const y2 = this.relToAbsY(this.height);
	const inputPad = new InputPad(x1, x2, y1, y2);

	// Add label to the top of the pad
	if (this.labelText !== "") {
		inputPad.addWidget(new InputWidget.Label(this.labelText));
	}

	const selectPad = new InputWidget.SelectPad();
	this.populatePad(selectPad);
	if (!selectPad.isEmpty()) {
		inputPad.addWidget(selectPad);
	}

	inputPad.addWidget(new InputWidget.NumPad(this.positive, this.integer));
	return inputPad;
};

/**
 * Creates SelectionData from the provided value, if that value is a valid option. Otherwise returns null
 * @param {number|boolean|string} value
 * @return {SelectionData|null}
 */
RoundSlot.prototype.selectionDataFromValue = function(value) {
	for (let i = 0; i < this.optionsList.length; i++) {
		const option = this.optionsList[i];
		if (option.data.getValue() === value) {
			return option.data;
		}
	}
	return null;
};

/**
 * @inheritDoc
 * @param {Data} data
 * @return {Data|null}
 */
RoundSlot.prototype.sanitizeData = function(data) {
	// Convert Data to the correct type
	data = EditableSlot.prototype.sanitizeData.call(this, data);
	if (data == null) return null;
	if (data.isSelection()) {
		// Never trust the displayText of user-provided SelectionData. Instead, look it up based on value
		const value = data.getValue();
		return this.selectionDataFromValue(value);
	}
	// If the Data is not SelectionData and it's of the correct type, it must be valid
	return data;
};

/**
 * Sets the labelText to the provided string
 * @param {string} text
 */
RoundSlot.prototype.addLabelText = function(text) {
	this.labelText = text;
};
/**
 * DropSlots have their data selected using the InputPad and often hold SelectionData
 * TODO: reduce redundancy with RoundSlot
 * @param {Block} parent
 * @param {string} key
 * @param {number|null} [inputType=select]
 * @param {number|null} [snapType=none]
 * @param {Data} [data=SelectionData.empty()] - The initial Data
 * @param {boolean} [nullable] - Whether empty SelectionData be allowed. By default, is true iff Data == null
 * @constructor
 */
function DropSlot(parent, key, inputType, snapType, data, nullable) {
	if (inputType == null) {
		inputType = EditableSlot.inputTypes.select;
	}
	if (snapType == null) {
		snapType = Slot.snapTypes.none;
	}
	if (data == null) {
		// If no Data was provided, it must be nullable
		DebugOptions.assert(nullable !== false);
		nullable = true;
		data = SelectionData.empty();
	} else if (nullable == null) {
		// If data was provided and nullable is not defined, set it to false
		nullable = false;
	}
	EditableSlot.call(this, parent, key, inputType, snapType, Slot.outputTypes.any, data);
	this.slotShape = new DropSlotShape(this, this.dataToString(data));
	this.slotShape.show();
	this.optionsList = [];
	this.nullable = nullable;
}
DropSlot.prototype = Object.create(EditableSlot.prototype);
DropSlot.prototype.constructor = DropSlot;

/**
 * @inheritDoc
 * TODO: fix BlockGraphics
 */
DropSlot.prototype.highlight = function() {
	const isSlot = !this.hasChild;
	Highlighter.highlight(this.getAbsX(), this.getAbsY(), this.width, this.height, 3, isSlot);
};

/**
 * @inheritDoc
 * @param {string} textSummary
 * @return {string}
 */
DropSlot.prototype.formatTextSummary = function(textSummary) {
	return "[" + textSummary + "]";
};

/**
 * Adds an option that opens a dialog so the user can enter text
 * @param {string} displayText - The text used to display the option
 */
DropSlot.prototype.addEnterText = function(displayText) {
	const option = {};
	option.displayText = displayText;
	option.isAction = true;
	this.optionsList.push(option);
};

/**
 * Adds an option, that when selected set the Slot to the provided value
 * @param {Data} data
 * @param {string} [displayText=null]
 */
DropSlot.prototype.addOption = function(data, displayText) {
	if (displayText == null) {
		displayText = null;
	}
	const option = {};
	option.displayText = displayText;
	option.data = data;
	option.isAction = false;
	this.optionsList.push(option);
};

/**
 * Adds the options to the InputPad's SelectPad
 * @param {InputWidget.SelectPad} selectPad - The pad to add the options to
 */
DropSlot.prototype.populatePad = function(selectPad) {
	this.optionsList.forEach(function(option) {
		// All actions are Edit Text actions
		if (option.isAction) {
			selectPad.addAction(option.displayText, function(callbackFn) {
				// When selected, the item shows a text entry dialog
				const inputDialog = new InputDialog(this.parent.textSummary(this), true);
				inputDialog.show(this.slotShape, function() {}, function(data, cancelled) {
					// When the dialog is closed, the item runns the callback with the data the user entered
					callbackFn(data, !cancelled);
				}, this.enteredData);
			}.bind(this)); //TODO: clean up edit text options
		} else {
			selectPad.addOption(option.data, option.displayText);
		}
	}.bind(this));
};

/**
 * Creates an InputPad with a SelectPad with this Slot's options
 * @return {InputPad}
 */
DropSlot.prototype.createInputSystem = function() {
	const x1 = this.getAbsX();
	const y1 = this.getAbsY();
	const x2 = this.relToAbsX(this.width);
	const y2 = this.relToAbsY(this.height);
	const inputPad = new InputPad(x1, x2, y1, y2);

	const selectPad = new InputWidget.SelectPad();
	this.populatePad(selectPad);
	inputPad.addWidget(selectPad);

	return inputPad;
};

/**
 * Creates SelectionData from the provided value, if that value is a valid option. Otherwise returns null
 * @param {number|boolean|string} value
 * @return {SelectionData|null}
 */
DropSlot.prototype.selectionDataFromValue = function(value) {
	for (let i = 0; i < this.optionsList.length; i++) {
		const option = this.optionsList[i];
		if (!option.isAction && option.data.getValue() === value) {
			return option.data;
		}
	}
	return null;
};

/**
 * Overrided by subclasses to sanitize other types of Data. By default, all non-selection Data is valid
 * @param {Data} data
 * @return {Data|null}
 */
DropSlot.prototype.sanitizeNonSelectionData = function(data) {
	return data;
};

/**
 * @inheritDoc
 * @param {Data} data
 * @return {Data|null}
 */
DropSlot.prototype.sanitizeData = function(data) {
	data = EditableSlot.prototype.sanitizeData.call(this, data);
	if (data == null) return null;
	if (data.isSelection()) {
		const value = data.getValue();
		if (value === "" && this.nullable) {
			return SelectionData.empty();
		}
		return this.selectionDataFromValue(value);
	}
	return this.sanitizeNonSelectionData(data);
};
/**
 * DropSlots have their data selected using the InputPad and often hold SelectionData
 * TODO: reduce redundancy with RoundSlot
 * @param {Block} parent
 * @param {string} key
 * @param {number|null} [inputType=select]
 * @param {number|null} [snapType=none]
 * @param {Data} [data=SelectionData.empty()] - The initial Data
 * @param {boolean} [nullable] - Whether empty SelectionData be allowed. By default, is true iff Data == null
 * @constructor
 */
function DropSlot(parent, key, inputType, snapType, data, nullable) {
	if (inputType == null) {
		inputType = EditableSlot.inputTypes.select;
	}
	if (snapType == null) {
		snapType = Slot.snapTypes.none;
	}
	if (data == null) {
		// If no Data was provided, it must be nullable
		DebugOptions.assert(nullable !== false);
		nullable = true;
		data = SelectionData.empty();
	} else if (nullable == null) {
		// If data was provided and nullable is not defined, set it to false
		nullable = false;
	}
	EditableSlot.call(this, parent, key, inputType, snapType, Slot.outputTypes.any, data);
	this.slotShape = new DropSlotShape(this, this.dataToString(data));
	this.slotShape.show();
	this.optionsList = [];
	this.nullable = nullable;
}
DropSlot.prototype = Object.create(EditableSlot.prototype);
DropSlot.prototype.constructor = DropSlot;

/**
 * @inheritDoc
 * TODO: fix BlockGraphics
 */
DropSlot.prototype.highlight = function() {
	const isSlot = !this.hasChild;
	Highlighter.highlight(this.getAbsX(), this.getAbsY(), this.width, this.height, 3, isSlot);
};

/**
 * @inheritDoc
 * @param {string} textSummary
 * @return {string}
 */
DropSlot.prototype.formatTextSummary = function(textSummary) {
	return "[" + textSummary + "]";
};

/**
 * Adds an option that opens a dialog so the user can enter text
 * @param {string} displayText - The text used to display the option
 */
DropSlot.prototype.addEnterText = function(displayText) {
	const option = {};
	option.displayText = displayText;
	option.isAction = true;
	this.optionsList.push(option);
};

/**
 * Adds an option, that when selected set the Slot to the provided value
 * @param {Data} data
 * @param {string} [displayText=null]
 */
DropSlot.prototype.addOption = function(data, displayText) {
	if (displayText == null) {
		displayText = null;
	}
	const option = {};
	option.displayText = displayText;
	option.data = data;
	option.isAction = false;
	this.optionsList.push(option);
};

/**
 * Adds the options to the InputPad's SelectPad
 * @param {InputWidget.SelectPad} selectPad - The pad to add the options to
 */
DropSlot.prototype.populatePad = function(selectPad) {
	this.optionsList.forEach(function(option) {
		// All actions are Edit Text actions
		if (option.isAction) {
			selectPad.addAction(option.displayText, function(callbackFn) {
				// When selected, the item shows a text entry dialog
				const inputDialog = new InputDialog(this.parent.textSummary(this), true);
				inputDialog.show(this.slotShape, function() {}, function(data, cancelled) {
					// When the dialog is closed, the item runns the callback with the data the user entered
					callbackFn(data, !cancelled);
				}, this.enteredData);
			}.bind(this)); //TODO: clean up edit text options
		} else {
			selectPad.addOption(option.data, option.displayText);
		}
	}.bind(this));
};

/**
 * Creates an InputPad with a SelectPad with this Slot's options
 * @return {InputPad}
 */
DropSlot.prototype.createInputSystem = function() {
	const x1 = this.getAbsX();
	const y1 = this.getAbsY();
	const x2 = this.relToAbsX(this.width);
	const y2 = this.relToAbsY(this.height);
	const inputPad = new InputPad(x1, x2, y1, y2);

	const selectPad = new InputWidget.SelectPad();
	this.populatePad(selectPad);
	inputPad.addWidget(selectPad);

	return inputPad;
};

/**
 * Creates SelectionData from the provided value, if that value is a valid option. Otherwise returns null
 * @param {number|boolean|string} value
 * @return {SelectionData|null}
 */
DropSlot.prototype.selectionDataFromValue = function(value) {
	for (let i = 0; i < this.optionsList.length; i++) {
		const option = this.optionsList[i];
		if (!option.isAction && option.data.getValue() === value) {
			return option.data;
		}
	}
	return null;
};

/**
 * Overrided by subclasses to sanitize other types of Data. By default, all non-selection Data is valid
 * @param {Data} data
 * @return {Data|null}
 */
DropSlot.prototype.sanitizeNonSelectionData = function(data) {
	return data;
};

/**
 * @inheritDoc
 * @param {Data} data
 * @return {Data|null}
 */
DropSlot.prototype.sanitizeData = function(data) {
	data = EditableSlot.prototype.sanitizeData.call(this, data);
	if (data == null) return null;
	if (data.isSelection()) {
		const value = data.getValue();
		if (value === "" && this.nullable) {
			return SelectionData.empty();
		}
		return this.selectionDataFromValue(value);
	}
	return this.sanitizeNonSelectionData(data);
};
/**
 * VarDropSlot are used to select a variable from a list.  They also provide an option to create a new variable.
 * @param {string} key
 * @param {Block} parent
 * @constructor
 */
function VarDropSlot(parent, key) {
	const variables = CodeManager.variableList;
	// When created, a variable slot shows the most recently created variable as its value
	let data = SelectionData.empty();
	if (variables.length > 0) {
		const lastVar = variables[variables.length - 1];
		data = lastVar.getSelectionData();
	}
	// Variable Blocks are nullable, even though they have a default value
	DropSlot.call(this, parent, key, null, null, data, true);
}
VarDropSlot.prototype = Object.create(DropSlot.prototype);
VarDropSlot.prototype.constructor = VarDropSlot;

/**
 * @inheritDoc
 * @param {InputWidget.SelectPad} selectPad
 */
VarDropSlot.prototype.populatePad = function(selectPad) {
	// Add each variable as an option
	CodeManager.variableList.forEach(function(variable) {
		selectPad.addOption(variable.getSelectionData());
	});
	// Add the Create variable option
	selectPad.addAction("Create variable", function(callback) {
		// When selected, tell the CodeManager to open a dialog to create a variable
		CodeManager.newVariable(function(variable) {
			// If successful, save the newly created variable as the value
			callback(variable.getSelectionData(), true);
		}, function() {
			// Otherwise, leave the pad open
			callback(null, false);
			// TODO: could just remove the above line entirely
		})
	});
};

/**
 * @inheritDoc
 * @param {boolean|string|number|Variable} value
 * @return {SelectionData|null}
 */
VarDropSlot.prototype.selectionDataFromValue = function(value) {
	DebugOptions.validateNonNull(value);
	// If the value is a Variable, use its SelectionData
	if (value.constructor === Variable) return value.getSelectionData();
	// Otherwise, assume the value is a string and look it up in CodeManager
	// TODO: perhaps verify the value is a string
	const variable = CodeManager.findVar(value);
	if (variable == null) return null;
	// If we find something, use that
	return variable.getSelectionData();
};

/**
 * @inheritDoc
 * @param {Variable} variable
 */
VarDropSlot.prototype.renameVariable = function(variable) {
	// If the variable that was renamed is the same as this Slot's value...
	if (this.enteredData != null && this.enteredData.getValue() === variable) {
		// Change the name appearing on this Slot
		this.setData(variable.getSelectionData(), false, true);
	}
};

/**
 * @inheritDoc
 * @param {Variable} variable
 */
VarDropSlot.prototype.deleteVariable = function(variable) {
	// If the variable that was renamed is the same as this Slot's value...
	if (this.enteredData != null && this.enteredData.getValue() === variable) {
		// Change the Data to empty
		this.setData(SelectionData.empty(), false, true);
	}
};

/**
 * @inheritDoc
 * @param {Variable} variable
 * @return {boolean}
 */
VarDropSlot.prototype.checkVariableUsed = function(variable) {
	// Returns that this variable is in use if it matches this Slot's value
	return this.enteredData != null && this.enteredData.getValue() === variable;
};
/**
 * ListDropSlot are used to select a List.  They also provide an option to create a new List.
 * @param {Block} parent
 * @param {string} key
 * @param {number} [snapType=none] - [none, list] Some slots allow ListData bocks like Split to be attached
 * @constructor
 */
function ListDropSlot(parent, key, snapType) {
	if (snapType == null) {
		snapType = Slot.snapTypes.none
	}
	// When created, a list slot shows the most recently created list as its value
	const lists = CodeManager.listList;
	let data = SelectionData.empty();
	if (lists.length > 0) {
		const lastList = lists[lists.length - 1];
		data = lastList.getSelectionData();
	}
	DropSlot.call(this, parent, key, null, snapType, data, true);
}
ListDropSlot.prototype = Object.create(DropSlot.prototype);
ListDropSlot.prototype.constructor = ListDropSlot;

/**
 * @inheritDoc
 * @param {InputWidget.SelectPad} selectPad
 */
ListDropSlot.prototype.populatePad = function(selectPad) {
	// Add each list as an option
	CodeManager.listList.forEach(function(list) {
		selectPad.addOption(list.getSelectionData());
	});
	// Add the Create list option
	selectPad.addAction("Create list", function(callback) {
		// When selected, tell the CodeManager to open a dialog to create a list
		CodeManager.newList(function(list) {
			// If successful, save the newly created variable as the value
			callback(list.getSelectionData(), true);
		}, function() {
			// Otherwise, leave the pad open
			callback(null, false);
			// TODO: could just remove the above line entirely
		})
	});
};

/**
 * @inheritDoc
 * @param {boolean|string|number|List} value
 * @return {SelectionData|null}
 */
ListDropSlot.prototype.selectionDataFromValue = function(value) {
	DebugOptions.validateNonNull(value);
	// If the value is a List, use its SelectionData
	if (value.constructor === List) return value.getSelectionData();
	// Otherwise, assume the value is a string and look it up in CodeManager
	// TODO: perhaps verify the value is a string
	const list = CodeManager.findList(value);
	if (list == null) return null;
	// If we find something, use that
	return list.getSelectionData();
};

/**
 * @inheritDoc
 * @param {List} list
 */
ListDropSlot.prototype.renameList = function(list) {
	if (this.enteredData != null && this.enteredData.getValue() === list) {
		this.setData(list.getSelectionData(), false, true);
	}
	this.passRecursively("renameList", list);
};

/**
 * @inheritDoc
 * @param {List} list
 */
ListDropSlot.prototype.deleteList = function(list) {
	if (!this.enteredData.isEmpty() && this.enteredData.getValue() === list) {
		this.setData(SelectionData.empty(), false, true);
	}
	this.passRecursively("deleteList", list);
};

/**
 * @inheritDoc
 * @param {List} list
 */
ListDropSlot.prototype.checkListUsed = function(list) {
	if (this.hasChild) {
		return DropSlot.prototype.checkListUsed.call(this, list);
	} else if (this.enteredData != null && this.enteredData.getValue() === list) {
		return true;
	}
	return false;
};

/**
 * PortSlots select a port for Robot input/output Blocks.  They store the Data as NumData (not SelectionData)
 * for legacy support
 * @param {Block} parent
 * @param {string} key
 * @param {number} maxPorts - The number of ports to list as options
 * @constructor
 */
function PortSlot(parent, key, maxPorts) {
	DropSlot.call(this, parent, key, EditableSlot.inputTypes.any, Slot.snapTypes.none, new NumData(1));
	this.maxPorts = maxPorts;
	for (let portNum = 1; portNum <= this.maxPorts; portNum++) {
		this.addOption(new NumData(portNum), "port " + portNum.toString());
	}
}
PortSlot.prototype = Object.create(DropSlot.prototype);
PortSlot.prototype.constructor = PortSlot;

/**
 * PortSlots only allow NumData integers from 1 to maxPorts
 * @param {Data} data
 * @return {Data|null}
 */
PortSlot.prototype.sanitizeData = function(data) {
	data = EditableSlot.prototype.sanitizeData.call(this, data);
	if (data == null) return null;
	const value = data.asNum().getValueInR(1, this.maxPorts, true, true);
	return new NumData(value, data.isValid);
};
/**
 * A DropSlot which lists available broadcasts (obtained from CodeManager.broadcastList) and allows the creation
 * of new broadcasts (through an Enter Text option). Reporter blocks that return strings can e attached to the Slot
 * unless it is within a HatBlock
 * @param {Block} parent
 * @param {string} key
 * @param {boolean} [isHatBlock=false] - Whether the slot is in a HatBlock and should include a "any message" option
 * @constructor
 */
function BroadcastDropSlot(parent, key, isHatBlock) {
	if (isHatBlock == null) {
		isHatBlock = false;
	}
	let snapType = Slot.snapTypes.numStrBool;
	if (isHatBlock) {
		snapType = Slot.snapTypes.none;
	}
	DropSlot.call(this, parent, key, EditableSlot.inputTypes.any, snapType);
	if (isHatBlock) {
		this.addOption(new SelectionData("any message", "any_message"));
	}
}
BroadcastDropSlot.prototype = Object.create(DropSlot.prototype);
BroadcastDropSlot.prototype.constructor = BroadcastDropSlot;

/**
 * @inheritDoc
 * @param {InputWidget.SelectPad} selectPad
 */
BroadcastDropSlot.prototype.populatePad = function(selectPad) {
	DropSlot.prototype.populatePad.call(this, selectPad);
	// Refresh the list of messages
	CodeManager.updateAvailableMessages();
	const messages = CodeManager.broadcastList;
	// Add an option for each message
	messages.forEach(function(message) {
		// Broadcasts are surrounded in quotes
		// TODO: make use of quotes around strings more consistent
		selectPad.addOption(new StringData(message), '"' + message + '"');
	});
	// Add an Edit Text option
	selectPad.addAction("new", function(callbackFn) {
		// When the option is selected, show a dialog
		const inputDialog = new InputDialog(this.parent.textSummary(this), false);
		inputDialog.show(this.slotShape, function() {}, function(data, cancelled) {
			// When the dialog is closed, notify the InputSystem of the result using a callback
			callbackFn(data, !cancelled);
		}, this.enteredData);
	}.bind(this));
};

/**
 * @inheritDoc
 * Adds the selected message to the list of available messages. Does not use recursion since BroadCastDropSlots
 * only appear on CommandBlocks/HatBlocks are therefore can't be stacked in each other
 */
BroadcastDropSlot.prototype.updateAvailableMessages = function() {
	if (this.enteredData !== null && this.enteredData.type === Data.types.string) {
		CodeManager.addBroadcastMessage(this.enteredData.getValue());
	}
};

/**
 * For a BroadcastDropSlot, non-selection Data must be StringData
 * @param {Data} data
 * @return {Data|null}
 */
BroadcastDropSlot.prototype.sanitizeNonSelectionData = function(data) {
	data = data.asString();
	if (!data.isValid) return null;
	return data;
};

/**
 * BroadCastDropSlots wrap broadcasts in quotes
 * @inheritDoc
 * @param {Data} data
 * @return {string}
 */
BroadcastDropSlot.prototype.dataToString = function(data) {
	let result = EditableSlot.prototype.dataToString.call(this, data);
	if (data.type === Data.types.string) {
		result = "\"" + result + "\"";
	}
	return result;
};
/**
 * DeviceDropSlots appear on Blocks that control robots.  When only one robot is connected, they appear as an ordinary
 * label, but when multiple robots are connected, tey act as a DropSlot, displaying options for each connected robot.
 * @param {Block} parent
 * @param {string} key
 * @param deviceClass - A subclass of Device indicating the type of robot the Slot is selecting from
 * @param {boolean} [shortText=false] - Whether the Slot should abbreviate the name of the Device using its initials
 * @constructor
 */
function DeviceDropSlot(parent, key, deviceClass, shortText) {
	// When the Slot's value changes, its parent Block must re-check if it is active
	this.assignUpdateActive(parent);
	if (shortText == null) {
		shortText = false;
	}
	this.shortText = shortText;
	this.prefixText = deviceClass.getDeviceTypeName(shortText) + " ";
	// The values of the SelectionData are 0 - indexed, but they appear as 1 - indexed
	const data = new SelectionData(this.prefixText + 1, 0);
	DropSlot.call(this, parent, key, EditableSlot.inputTypes.select, Slot.snapTypes.none, data, false);

	this.deviceClass = deviceClass;

	// The Slot also has label text to display, depending on how many devices are available
	this.labelText = new LabelText(this.parent, this.prefixText.trim());
	this.labelMode = false;
	// Check to see which state it should start in
	const deviceCount = deviceClass.getManager().getSelectableDeviceCount();
	if (deviceCount <= 1) {
		this.switchToLabel();
	} else {
		this.labelText.hide();
	}

	// The parent Block may not be active if the device in the DropSlot is not connected
	this.parent.updateActive();
}
DeviceDropSlot.prototype = Object.create(DropSlot.prototype);
DeviceDropSlot.prototype.constructor = DeviceDropSlot;

/**
 * Modifies the checkActive function of the parent so that the selected device on the DropSlot must be connected
 * in order for the Block to be active
 * TODO: This is a bit strange and perhaps should be done in the Block's constructor in BlockDefs
 * @param {Block} parent - This Block's parent
 */
DeviceDropSlot.prototype.assignUpdateActive = function(parent){
	const me = this;
	// Get a copy of the old checkActive function
	const oldFn = parent.checkActive.bind(parent);
	parent.checkActive = function(){
		// The new checkActive function runs the old function and makes sure this device is connected
		const index = me.getDataNotFromChild().getValue();
		return oldFn() && me.deviceClass.getManager().deviceIsConnected(index);
	};
};

/**
 * When the Slot's value changes, the parent Block may become active/inactive
 * @inheritDoc
 * @param {Data} data
 * @param {boolean} sanitize
 * @param {boolean} updateDim
 */
DeviceDropSlot.prototype.setData = function(data, sanitize, updateDim){
	DropSlot.prototype.setData.call(this, data, sanitize, updateDim);
	this.parent.updateActive();
};

/**
 * When the connection status of a robot changes, the parent Block may become active/inactive
 */
DeviceDropSlot.prototype.updateConnectionStatus = function(){
	this.parent.updateActive();
};

/**
 * The DropSlot asks the deviceManager to determine how many devices to show
 * @inheritDoc
 * @param {InputWidget.SelectPad} selectPad - the pad to populate
 */
DeviceDropSlot.prototype.populatePad = function(selectPad) {
	let deviceCount = this.deviceClass.getManager().getSelectableDeviceCount();
	deviceCount = Math.max(1, deviceCount);
	for (let i = 0; i < deviceCount; i++) {
		// We'll store a 0-indexed value but display it +1.
		selectPad.addOption(new SelectionData(this.prefixText + (i + 1), i));
		// TODO: should probably use the full name when showing the list
	}
};

/**
 * Changes the appearance of the Slot so it looks like a label instead of a Slot
 */
DeviceDropSlot.prototype.switchToLabel = function() {
	if (!this.labelMode) {
		this.labelMode = true;
		this.labelText.show();
		this.slotShape.hide();
		// When there's a label, only one device is connected
		this.setData(new SelectionData(this.prefixText + 1, 0), false, true);
	}
};

/**
 * Changes the appearance of the Slot so it looks like a slot instead of a label
 */
DeviceDropSlot.prototype.switchToSlot = function() {
	if (this.labelMode) {
		this.labelMode = false;
		this.labelText.hide();
		this.slotShape.show();
	}
};

/**
 * @inheritDoc
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
DeviceDropSlot.prototype.updateAlign = function(x, y) {
	if (this.labelMode) {
		return LabelText.prototype.updateAlign.call(this.labelText, x, y);
	} else {
		return DropSlot.prototype.updateAlign.call(this, x, y);
	}
};

/**
 * @inheritDoc
 */
DeviceDropSlot.prototype.updateDim = function() {
	if (this.labelMode) {
		LabelText.prototype.updateDim.call(this.labelText);
		this.width = this.labelText.width;
	} else {
		DropSlot.prototype.updateDim.call(this);
	}
};

/**
 * Receives the recursively passed message and acts on it
 * @param deviceClass - A subclass of Device
 */
DeviceDropSlot.prototype.hideDeviceDropDowns = function(deviceClass) {
	if(this.deviceClass === deviceClass) {
		this.switchToLabel();
	}
};

/**
 * Receives the recursively passed message and acts on it
 * @param deviceClass - A subclass of Device
 */
DeviceDropSlot.prototype.showDeviceDropDowns = function(deviceClass) {
	if(this.deviceClass === deviceClass) {
		this.switchToSlot();
	}
};

/**
 * Called by DeviceManager and used to determine how many devices to list.
 * @inheritDoc
 * @param deviceClass - A subclass of Device
 * @return {number} - The minimum number of devices to show in the DeviceDropSlots, according to this Slot
 */
DeviceDropSlot.prototype.countDevicesInUse = function(deviceClass) {
	if (this.deviceClass === deviceClass) {
		const myVal = this.getDataNotFromChild().getValue();
		return myVal + 1;
	} else {
		return 0;
	}
};

/**
 * DeviceDropSlots always have a value that is SelectionData with an integer value
 * @inheritDoc
 * @param {number|string|boolean} value
 * @return {SelectionData}
 */
DeviceDropSlot.prototype.selectionDataFromValue = function(value){
	const numData = (new StringData(value).asNum());
	if(!numData.isValid) return null;
	const numVal = numData.getValueWithC(true, true);
	// Prevents rendering huge lists
	if(numVal >= 30) return null; // TODO: implement connection limit
	return new SelectionData(this.prefixText + (numVal + 1), numVal);
};

/**
 * No Data other than SelectionData is valid
 * @inheritDoc
 * @param {Data} data
 * @return {Data|null}
 */
DeviceDropSlot.prototype.sanitizeNonSelectionData = function(data){
	return null;
};

DeviceDropSlot.prototype.makeActive = function() {
	DropSlot.prototype.makeActive.call(this);
	this.labelText.makeActive();
};

DeviceDropSlot.prototype.makeInactive = function() {
	DropSlot.prototype.makeActive.call(this);
	this.labelText.makeInactive();
};
/**
 * SoundDropSlots select a sound or recording from a list. Uses the SoundInputPad instead of InputPad
 * @param {Block} parent
 * @param {string} key
 * @param {boolean} isRecording - Whether this Slot should list build in sounds or recordings
 * @constructor
 */
function SoundDropSlot(parent, key, isRecording) {
	DropSlot.call(this, parent, key);
	this.isRecording = isRecording;
}
SoundDropSlot.prototype = Object.create(DropSlot.prototype);
SoundDropSlot.prototype.constructor = SoundDropSlot;

/**
 * @inheritDoc
 * @return {SoundInputPad}
 */
SoundDropSlot.prototype.createInputSystem = function() {
	const x1 = this.getAbsX();
	const y1 = this.getAbsY();
	const x2 = this.relToAbsX(this.width);
	const y2 = this.relToAbsY(this.height);
	return new SoundInputPad(x1, x2, y1, y2, this.isRecording);
};

/**
 * Only selectionData is valid
 * @inheritDoc
 * @param {Data} data
 * @return {Data|null}
 * TODO: Technically this isn't necessary since the inputType is selection anyway
 */
SoundDropSlot.prototype.sanitizeNonSelectionData = function(data) {
	return null
};
SoundDropSlot.prototype.selectionDataFromValue = function(value) {
	if (this.isRecording) {
		// If it is a recording, use the name of the recording as the display name
		return new SelectionData(value, value);
	} else {
		// Otherwise, look up the correct name and use that
		let sound = Sound.lookupById(value);
		if (sound != null) return new SelectionData(sound.name, sound.id);
		// If the sound can't be found (maybe it isn't in this version of he app), use the value as the display name
		return new SelectionData(value, value);
	}
};
SoundDropSlot.prototype.renameRecording = function(oldName, newName) {
	if (!this.isRecording) return;
	if(this.enteredData.getValue() === oldName) {
		this.setData(new SelectionData(newName, newName), true, true);
		//TODO: should be fine to make sanitize false
	}
};
SoundDropSlot.prototype.deleteRecording = function(recording) {
	if (!this.isRecording) return;
	if(this.enteredData.getValue() === recording) {
		this.setData(SelectionData.empty(), true, true);
	}
};
/**
 * BoolSlot is a subclass of HexSlot.
 * It creates a RectSlot optimized for use with booleans.
 * It has a snapType of bool.
 * @constructor
 * @param {Block} parent
 * @param {string} key
 */
function BoolSlot(parent,key){
	//Make HexSlot.
	HexSlot.call(this,parent,key,Slot.snapTypes.bool);
}
BoolSlot.prototype = Object.create(HexSlot.prototype);
BoolSlot.prototype.constructor = BoolSlot;
/**
 * NumSlot is a subclass of RoundSlot.
 * It creates a RoundSlot optimized for use with numbers.
 * It automatically converts any results into NumData and has a snapType of numStrBool.
 * @constructor
 * @param {Block} parent
 * @param {string} key
 * @param {number} value
 * @param {boolean} [positive] - Determines if the NumPad will have the plus/minus Button disabled.
 * @param {boolean} [integer] - Determines if the NumPad will have the decimal point Button disabled.
 */
function NumSlot(parent, key, value, positive, integer) {
	// Optional parameters are false by default.
	if (positive == null) {
		positive = false;
	}
	if (integer == null) {
		integer = false;
	}
	const inputType = EditableSlot.inputTypes.num;
	const snapType = Slot.snapTypes.numStrBool;
	const outputType = Slot.outputTypes.num;

	// Make RoundSlot.
	RoundSlot.call(this, parent, key, inputType, snapType, outputType, new NumData(value), positive, integer);

	// Limits can be set later
	this.minVal = null;
	this.maxVal = null;
}
NumSlot.prototype = Object.create(RoundSlot.prototype);
NumSlot.prototype.constructor = NumSlot;

/**
 * Configures the Slot to bound its input to the provided min and max. Used by sanitizeData, and shown on
 * the InputPad with the provided displayUnits in the form "DisplayUnits (min - max)"
 * @param {number|null} [min] - The minimum value or null if no bound
 * @param {number|null} [max] - The maximum value or null if no bound
 * @param {string|null} [displayUnits] - The units/label to show before the min/max or null if none
 */
NumSlot.prototype.addLimits = function(min, max, displayUnits) {
	this.minVal = min;
	this.maxVal = max;
	if(min == null || max == null) return;
	if (displayUnits == null) {
		this.labelText = "(" + min + " - " + max + ")";
	} else {
		this.labelText = displayUnits + " (" + min + " - " + max + ")";
	}
};

/**
 * @inheritDoc
 * @param {Data|null} data
 * @return {Data|null}
 */
NumSlot.prototype.sanitizeData = function(data) {
	// Forces Data to NumData
	data = RoundSlot.prototype.sanitizeData.call(this, data);
	if (data == null) return null;
	const value = data.asNum().getValueInR(this.minVal, this.maxVal, this.positive, this.integer);
	return new NumData(value, data.isValid);
};
/**
 * StringSlot is a subclass of RectSlot.
 * It creates a RectSlot optimized for use with strings.
 * It automatically converts any results into StringData and has a snapType of numStrBool.
 * @constructor
 * @param {Block} parent
 * @param {string} key
 * @param {string} value - The initial string stored in the Slot.
 */
function StringSlot(parent, key, value) {
	//Make RectSlot.
	RectSlot.call(this, parent, key, Slot.snapTypes.numStrBool, Slot.outputTypes.string, new StringData(value));
}
StringSlot.prototype = Object.create(RectSlot.prototype);
StringSlot.prototype.constructor = StringSlot;
/**
 * NumOrStringSlots are used in the equals Block, as they make it easy to enter numbers but do allow text to be entered
 * @param {Block} parent
 * @param {string} key
 * @param {Data} data
 * @constructor
 */
function NumOrStringSlot(parent, key, data){
	const inputType = EditableSlot.inputTypes.any;
	const snapType = Slot.snapTypes.numStrBool;
	const outputType = Slot.outputTypes.any;
	RoundSlot.call(this, parent, key, inputType, snapType, outputType, data, false, false);
}
NumOrStringSlot.prototype = Object.create(RoundSlot.prototype);
NumOrStringSlot.prototype.constructor = NumOrStringSlot;

/**
 * @inheritDoc
 * @param {InputWidget.SelectPad} selectPad
 */
NumOrStringSlot.prototype.populatePad = function(selectPad){
	selectPad.addAction("Enter text", function(callbackFn){
		// When "Enter text" is selected, create a new inputDialog
		const inputDialog = new InputDialog(this.parent.textSummary(this), true);
		inputDialog.show(this.slotShape, function(){}, function(data, cancelled){
			// When the inputDialog is closed, tell the selectPad to set the data to the result of the inputDialog.
			// CLose the selectPad if the inputDialog wasn't canceled.
			callbackFn(data, !cancelled);
		}, this.enteredData);
	}.bind(this)); //TODO: clean up edit text options
};
/**
 * IndexSlots are used to select indexes in Lists. They have special options for "last" "random" and "all"
 * @param {Block} parent
 * @param {string} key
 * @param {boolean} includeAll - indicates whether "all" should be an option
 * @constructor
 */
function IndexSlot(parent, key, includeAll) {
	// inputType doesn't matter as much since we have our own sanitize function
	const inputType = EditableSlot.inputTypes.any;
	const snapType = Slot.snapTypes.numStrBool;
	// Both SelectionData and NumData must be allowed
	const outputType = Slot.outputTypes.any;
	// Default value is 1
	RoundSlot.call(this, parent, key, inputType, snapType, outputType, new NumData(1), true, true);

	// Add selectable options
	this.addOption(new SelectionData("last", "last"));
	this.addOption(new SelectionData("random", "random"));
	if (includeAll) {
		this.addOption(new SelectionData("all", "all"));
	}
}
IndexSlot.prototype = Object.create(RoundSlot.prototype);
IndexSlot.prototype.constructor = IndexSlot;

/**
 * @inheritDoc
 * @param {Data|null} data
 * @return {Data|null}
 */
IndexSlot.prototype.sanitizeData = function(data) {
	// Checks to ensure SelectionData is valid
	data = RoundSlot.prototype.sanitizeData.call(this, data);
	if (data == null) return null;
	if (!data.isSelection()) {
		// If it isn't selectionData, make sure it is a positive integer, fixing it as necessary
		const numData = data.asNum();
		if (!numData.isValid) return null;
		let value = numData.getValueWithC(true, true);
		value = Math.max(1, value);
		return new NumData(value);
	}
	return data;
};
/**
 * ToggleSlot is a subclass of BoolSlot. Though not a subclass of EditableSlot,
 * it is editable in that you can toggle the boolean value.
 *
 * @constructor
 * @param {Block} parent
 * @param {string} key
 */
 //TODO: make this a subclass of EditableSlot?
 function ToggleSlot(parent,key){
 	//Make BoolSlot.
 	BoolSlot.call(this,parent,key);

  this.isTrue = false
 }
 ToggleSlot.prototype = Object.create(BoolSlot.prototype);
 ToggleSlot.prototype.constructor = ToggleSlot;

 ToggleSlot.prototype.onTap = function() {
   this.isTrue = !this.isTrue
   if (this.isTrue) {
     this.slotShape.slotE.setAttributeNS(null, "fill", Colors.red);
   } else {
     BlockGraphics.update.hexSlotGradient(this.slotShape.slotE, this.parent.category, this.slotShape.active);
   }
 }

 ToggleSlot.prototype.getDataNotFromChild = function() {
 	return new BoolData(this.isTrue, true); //The Slot is empty. Return stored value
 };

 /**
  * Converts the Slot and its children into XML, storing the value in the isTrue as well
  * @inheritDoc
  * @param {Document} xmlDoc
  * @return {Node}
  *//*
 ToggleSlot.prototype.createXml = function(xmlDoc) {
 	let slot = Slot.prototype.createXml.call(this, xmlDoc);
 	let isTrue = XmlWriter.createElement(xmlDoc, "isTrue");
 	isTrue.appendChild(this.isTrue.createXml(xmlDoc));
 	slot.appendChild(isTrue);
 	return slot;
};*/

/**
 * BlockSlots are included in Blocks like if/else and loops to hold a stack of Blocks inside the slot. They are very
 * different from Slots, and are not a subclass of Slot. They do pass messages recursively to their children, and
 * compute the height of the stack of children they contain.
 * @param {Block} parent - The Block this Slot is part of
 * @constructor
 */
function BlockSlot(parent) {
	this.parent = parent;
	this.child = null;
	this.hasChild = false;
	this.height = 0;
	this.x = 0;
	this.y = 0;
	this.isBlockSlot = true;   // Used so Blocks can identify if their parent is a BlockSlot
	this.isRunning = false;
	this.currentBlock = null;   // Currently executing Block in the slot
}

/**
 * @return {number}
 */
BlockSlot.prototype.getAbsX = function() {
	return this.parent.stack.relToAbsX(this.x);
};
/**
 * @return {number}
 */
BlockSlot.prototype.getAbsY = function() {
	return this.parent.stack.relToAbsY(this.y);
};

/**
 * Recursively computes the height of the BlockSlot
 */
BlockSlot.prototype.updateDim = function() {
	if (this.hasChild) {
		this.child.updateDim();
		this.height = this.child.addHeights();
	} else {
		this.height = BlockGraphics.loop.bottomH;
	}
};

/**
 * Moves the BlockSlot and children to the specified coords and recursively updates their alignment
 * @param {number} x
 * @param {number} y
 */
BlockSlot.prototype.updateAlign = function(x, y) {
	this.x = x;
	this.y = y;
	if (this.hasChild) {
		this.child.updateAlign(x, y);
	}
};

/**
 * Connects the specified to this BlockSlot, potentially displacing the BlockSlot's existing children
 * @param {Block} block - The Block to add to this BlockSlot
 */
BlockSlot.prototype.snap = function(block) {
	// Displace existing block, if more Blocks can't go below this one
	if (!block.getLastBlock().bottomOpen && this.child != null) {
		const BG = BlockGraphics.command;
		this.child.unsnap().shiftOver(BG.shiftX, block.stack.getHeight() + BG.shiftY);
	}

	// Set the stack's execution status and glow
	const stack = this.parent.stack;
	if (stack != null && block.stack != null) {
		block.stack.stop();
		if(stack.isRunning) {
			block.glow();
		}
	}

	// Fix relationships between Blocks
	block.parent = this;
	if (this.hasChild) {
		const lastBlock = block.getLastBlock();
		const prevChild = this.child;
		lastBlock.nextBlock = prevChild;
		prevChild.parent = lastBlock;
	}
	this.hasChild = true;
	this.child = block;

	if (block.stack != null) {
		// Remove the old BlockStack and transfer the Block to this one
		const oldG = block.stack.group;
		block.stack.remove();
		block.changeStack(this.parent.stack);
		oldG.remove();
	}
	if (stack != null) {
		// Update the positions of everything
		this.parent.stack.updateDim();
	}
};

/**
 * Recursively change's this BlockSlot's children's stacks to the specified stack
 * @param {BlockStack} stack
 */
BlockSlot.prototype.changeStack = function(stack) {
	if (this.hasChild) {
		this.child.changeStack(stack);
	}
};

/**
 * Recursively tells children to update the stack dimensions
 */
BlockSlot.prototype.updateStackDim = function() {
	if (this.hasChild) {
		this.child.updateStackDim();
	}
};

/**
 * Sets this BlockSlot to have no children
 */
BlockSlot.prototype.removeChild = function() {
	this.hasChild = false;
	this.child = null;
};

/**
 * Checks if the moving Block could fit in this BlockStack and then passes the findBestFit message recursively
 */
BlockSlot.prototype.findBestFit = function() {
	const move = CodeManager.move;
	const fit = CodeManager.fit;
	const x = this.getAbsX();
	const y = this.getAbsY();
	// Check if the Block fits in this BlockSlot (above the top Block in it, if any)
	if (move.topOpen) {
		const snap = BlockGraphics.command.snap;
		if (move.pInRange(move.topX, move.topY, x - snap.left, y - snap.top, snap.left + snap.right, snap.top + snap.bottom)) {
			const xDist = move.topX - x;
			const yDist = move.topY - y;
			const dist = xDist * xDist + yDist * yDist;
			if (!fit.found || dist < fit.dist) {
				fit.found = true;
				fit.bestFit = this;
				fit.dist = dist;
			}
		}
	}
	// Check if it fits in this BlockSlot's children
	if (this.hasChild) {
		this.child.findBestFit();
	}
};

/**
 * Adds indicator that moving Block will snap to this BlockSlot if released
 */
BlockSlot.prototype.highlight = function() {
	Highlighter.highlight(this.getAbsX(), this.getAbsY(), 0, 0, 0, false, this.parent.isGlowing);
};

/**
 * Duplicates Blocks from the provided blockSlot into this BlockSlot recursively
 * @param {BlockSlot} blockSlot
 */
BlockSlot.prototype.copyFrom = function(blockSlot) {
	if (blockSlot.hasChild) {
		this.snap(blockSlot.child.duplicate(0, 0));
	}
};

/**
 * Prepares this BlockSlot for execution
 */
BlockSlot.prototype.startRun = function() {
	if (!this.isRunning && this.hasChild) {
		this.isRunning = true;
		this.currentBlock = this.child;
	}
};

/**
 * Recursively stops this BlockSlot and its children's execution
 */
BlockSlot.prototype.stop = function() {
	if (this.isRunning && this.hasChild) {
		this.child.stop();
	}
	this.isRunning = false;
};

/**
 * Updates execution of the BlockSlot
 * @return {ExecutionStatus} - Indicates whether this BlockSlot is still executing
 */
BlockSlot.prototype.updateRun = function() {
	if (this.isRunning) {
		if (this.currentBlock.stack !== this.parent.stack) {
			//If the current Block has been removed, don't run it.
			this.isRunning = false;
			return new ExecutionStatusDone();
		}
		// Run the current Block
		let execStatus = this.currentBlock.updateRun();
		if (!execStatus.isRunning()) {
			// If the current Block is done, show an error or move on to the next one
			if (execStatus.hasError()) {
				this.isRunning = false;
				return execStatus;
			} else {
				this.currentBlock = this.currentBlock.nextBlock;
			}
		}
		if (this.currentBlock != null) {
			return new ExecutionStatusRunning();
		} else {
			// Done with all Blocks in the BlockSlot
			this.isRunning = false;
			return new ExecutionStatusDone();
		}
	} else {
		return new ExecutionStatusDone();
	}
};

/**
 * Recursively makes children glow
 */
BlockSlot.prototype.glow = function() {
	if (this.hasChild) {
		this.child.glow();
	}
};

/**
 * Recursively makes children stop glowing
 */
BlockSlot.prototype.stopGlow = function() {
	if (this.hasChild) {
		this.child.stopGlow();
	}
};

/**
 * Recursively updates the available broadcast messages.
 */
BlockSlot.prototype.updateAvailableMessages = function() {
	if (this.hasChild) {
		this.child.updateAvailableMessages();
	}
};

/**
 * Creates XML for this BlockSlot
 * @param {Document} xmlDoc - The document to modify
 * @return {Node} - The XML representing this BlockSlot
 */
BlockSlot.prototype.createXml = function(xmlDoc) {
	const blockSlot = XmlWriter.createElement(xmlDoc, "blockSlot");
	if (this.hasChild) {
		const blocks = XmlWriter.createElement(xmlDoc, "blocks");
		this.child.writeToXml(xmlDoc, blocks);
		blockSlot.appendChild(blocks);
	}
	return blockSlot;
};

/**
 * Copies data from XML into this BlockSlot
 * @param {Node} blockSlotNode
 */
BlockSlot.prototype.importXml = function(blockSlotNode) {
	const blocksNode = XmlWriter.findSubElement(blockSlotNode, "blocks");
	const blockNodes = XmlWriter.findSubElements(blocksNode, "block");
	if (blockNodes.length > 0) {
		let firstBlock = null;
		let i = 0;
		while (firstBlock == null && i < blockNodes.length) {
			// Get the first Block to import correctly
			firstBlock = Block.importXml(blockNodes[i]);
			i++;
		}
		if (firstBlock == null) {
			// No Blocks imported correctly
			return;
		}
		this.snap(firstBlock);
		let previousBlock = firstBlock;
		// Import the rest of the Blocks
		while (i < blockNodes.length) {
			const newBlock = Block.importXml(blockNodes[i]);
			if (newBlock != null) {
				previousBlock.snap(newBlock);
				previousBlock = newBlock;
			}
			i++;
		}
	}
};

/**
 * @param {Variable} variable
 */
BlockSlot.prototype.renameVariable = function(variable) {
	this.passRecursively("renameVariable", variable);
};

/**
 * @param {Variable} variable
 */
BlockSlot.prototype.deleteVariable = function(variable) {
	this.passRecursively("deleteVariable", variable);
};

/**
 * @param {List} list
 */
BlockSlot.prototype.renameList = function(list) {
	this.passRecursively("renameList", list);
};

/**
 * @param {List} list
 */
BlockSlot.prototype.deleteList = function(list) {
	this.passRecursively("deleteList", list);
};

/**
 * @param {Variable} variable
 */
BlockSlot.prototype.checkVariableUsed = function(variable) {
	if (this.hasChild) {
		return this.child.checkVariableUsed(variable);
	}
	return false;
};

/**
 * @param {List} list
 */
BlockSlot.prototype.checkListUsed = function(list) {
	if (this.hasChild) {
		return this.child.checkListUsed(list);
	}
	return false;
};

/**
 * @param deviceClass - a subclass of Device
 */
BlockSlot.prototype.countDevicesInUse = function(deviceClass) {
	if (this.hasChild) {
		return this.child.countDevicesInUse(deviceClass);
	}
	return 0;
};

/**
 * @param {string} message
 */
BlockSlot.prototype.passRecursivelyDown = function(message) {
	Array.prototype.unshift.call(arguments, "passRecursivelyDown");
	this.passRecursively.apply(this, arguments);
};

/**
 * @param {string} functionName
 */
BlockSlot.prototype.passRecursively = function(functionName) {
	const args = Array.prototype.slice.call(arguments, 1);
	if (this.hasChild) {
		this.child[functionName].apply(this.child, args);
	}
};
/**
 * Displays text on a block.  For example, the say for secs block has 3 LabelText objects: "say", "for", "secs".
 * @param {Block} parent - The Block this LabelText is a member of
 * @param {string} text - The text to display
 * @constructor
 */
function LabelText(parent, text) {
	DebugOptions.validateNonNull(parent, text);
	this.text = text;
	this.width = 0;   // Computed later with updateDim
	this.height = BlockGraphics.labelText.font.charHeight;
	this.x = 0;
	this.y = 0;
	this.parent = parent;
	this.textE = this.generateText(text);
	this.isSlot = false;   // All BlockParts have this property
	this.visible = true;
}
LabelText.prototype = Object.create(BlockPart.prototype);
LabelText.prototype.constructor = LabelText;

/**
 * @param {number} x - The x coord the text should have relative to the Block it is in
 * @param {number} y - The y coord ths text should have measured from the center of the text
 * @return {number} - The width of the text, indicating how much the next item should be shifted over.
 */
LabelText.prototype.updateAlign = function(x, y) {
	this.move(x, y + this.height / 2);
	return this.width;
};

/**
 * Computes the dimensions of the text and stores them in this.height and this.width
 */
LabelText.prototype.updateDim = function() {
	// Dimensions are only computed once, since text can't change
	if (this.width === 0) {
		GuiElements.layers.temp.appendChild(this.textE);
		this.width = GuiElements.measure.textWidth(this.textE);
		this.textE.remove();
		this.parent.group.appendChild(this.textE);
	}
};

/**
 * Creates text in the SVG from the specified string
 * @param {string} text - The text to create
 * @return {Node} - The SVG text element
 */
LabelText.prototype.generateText = function(text) {
	const obj = BlockGraphics.create.labelText(text, this.parent.group);
	TouchReceiver.addListenersChild(obj, this.parent);
	return obj;
};

/**
 * Moves text to coords and stores them in this.x and this.y
 * @param {number} x
 * @param {number} y
 */
LabelText.prototype.move = function(x, y) {
	this.x = x;
	this.y = y;
	BlockGraphics.update.text(this.textE, x, y);
};

/**
 * Creates a string representation of the label
 * @return {string}
 */
LabelText.prototype.textSummary = function() {
	return this.text;
};

/**
 * Unhides the label
 */
LabelText.prototype.show = function() {
	if (!this.visible) {
		this.parent.group.appendChild(this.textE);
		this.visible = true;
	}
};

/**
 * Removes the label from the SVG
 */
LabelText.prototype.hide = function() {
	if (this.visible) {
		this.textE.remove();
		this.visible = false;
	}
};

/**
 * Intended to permanently remove label from SVG
 */
LabelText.prototype.remove = function() {
	this.textE.remove();
};

LabelText.prototype.makeActive = function() {
	GuiElements.update.color(this.textE, BlockGraphics.labelText.fill);
};

LabelText.prototype.makeInactive = function() {
	GuiElements.update.color(this.textE, BlockGraphics.labelText.disabledFill);
};
/**
 * Adds a colored icon that can be used as part of a Block. Used in the "when flag tapped" Block
 * @param {Block} parent - The Block this icon is a part of
 * @param pathId - entry of VectorPaths corresponding to the icon to use
 * @param {string} color - Hex representation of the color to use
 * @param {string} altText - Text representation of icon is used for creating text summary
 * @param {number} height - Height of the icon. Icon will automatically center vertically
 * @constructor
 */
function BlockIcon(parent, pathId, color, altText, height) {
	DebugOptions.validateNonNull(parent, pathId, color, altText);
	DebugOptions.validateNumbers(height);
	this.pathId = pathId;
	this.color = color;
	this.altText = altText;
	this.width = VectorIcon.computeWidth(pathId, height);
	this.height = height;
	this.x = 0;
	this.y = 0;
	this.parent = parent;
	this.icon = new VectorIcon(0, 0, pathId, color, height, this.parent.group);
	TouchReceiver.addListenersChild(this.icon.pathE, this.parent);
	this.isSlot = false;
}
BlockIcon.prototype = Object.create(BlockPart.prototype);
BlockIcon.prototype.constructor = BlockIcon;

/**
 * @param {number} x - The x coord the icon should have relative to the Block it is in
 * @param {number} y - The y coord ths icon should have measured from the center of the icon
 * @return {number} - The width of the icon, indicating how much the next item should be shifted over.
 */
BlockIcon.prototype.updateAlign = function(x, y) {
	DebugOptions.validateNumbers(x, y);
	this.move(x, y - this.height / 2);
	return this.width;
};

/**
 * BlockIcons are of constant size, so updateDim does nothing
 */
BlockIcon.prototype.updateDim = function() {

};

/**
 * Moves the icon and sets this.x and this.y to the specified coordinates
 * @param {number} x
 * @param {number} y
 */
BlockIcon.prototype.move = function(x, y) {
	DebugOptions.validateNumbers(x, y);
	this.x = x;
	this.y = y;
	this.icon.move(x, y);
};

/**
 * Creates a text representation of the BlockIcon
 * @return {string}
 */
BlockIcon.prototype.textSummary = function() {
	return this.altText;
};
/* This file contains templates for Blocks that control robots.  Each robot has its own BlockDefs file, but many
 * of the defined Blocks are just subclasses of the Blocks here.
 */

/**
 * A Block that polls a sensor
 * @param {number} x
 * @param {number} y
 * @param deviceClass - A subclass of Device indicating the type of robot
 * @param {string} sensorType - Needed for the http request
 * @param {string} displayName - Name present on Block
 * @param {number} numberOfPorts - Used to populate PortSlot
 * @constructor
 */
function B_DeviceWithPortsSensorBase(x, y, deviceClass, sensorType, displayName, numberOfPorts){
	ReporterBlock.call(this,x,y,deviceClass.getDeviceTypeId());
	this.deviceClass = deviceClass;
	this.sensorType = sensorType;
	this.displayName = displayName; //TODO: perhapse remove this
	this.numberOfPorts = numberOfPorts;
	this.addPart(new DeviceDropSlot(this,"DDS_1", deviceClass));
	this.addPart(new LabelText(this,displayName));
	this.addPart(new PortSlot(this,"PortS_1", numberOfPorts));
}
B_DeviceWithPortsSensorBase.prototype = Object.create(ReporterBlock.prototype);
B_DeviceWithPortsSensorBase.prototype.constructor = B_DeviceWithPortsSensorBase;
/* Sends the request for the sensor data. */
B_DeviceWithPortsSensorBase.prototype.startAction=function(){
	let deviceIndex = this.slots[0].getData().getValue();
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let mem = this.runMem;
	let port = this.slots[1].getData().getValue();
	if (port != null && port > 0 && port <= this.numberOfPorts) {
		mem.requestStatus = {};
		mem.requestStatus.finished = false;
		mem.requestStatus.error = false;
		mem.requestStatus.result = null;
		device.readSensor(mem.requestStatus, this.sensorType, port);
		return new ExecutionStatusRunning();
	} else {
		this.displayError("Invalid port number");
		return new ExecutionStatusError(); // Invalid port, exit early
	}
};
/* Returns the result of the request */
B_DeviceWithPortsSensorBase.prototype.updateAction=function(){
	const status = this.runMem.requestStatus;
	if (status.finished) {
		if(status.error){
			this.displayError(this.deviceClass.getNotConnectedMessage(status.code, status.result));
			return new ExecutionStatusError();
		} else {
			const result = new StringData(status.result);
			const num = result.asNum().getValue();
			const rounded = Math.round(num);
			return new ExecutionStatusResult(new NumData(rounded));
		}
	}
	return new ExecutionStatusRunning(); // Still running
};


/**
 * A Block that sets an output
 * @param {number} x
 * @param {number} y
 * @param deviceClass - A subclass of Device indicating the type of robot
 * @param {string} outputType - Needed for the http request
 * @param {string} displayName - Name present on Block
 * @param {number} numberOfPorts - Used to populate PortSlot
 * @param {string} valueKey - Needed for the http request. The key used to send the value in the slot
 * @param {number} minVal - The minimum value the output can take
 * @param {number} maxVal - The maximum value the output can take
 * @param {string} displayUnits - The units to display on the inputPad
 * @constructor
 */
function B_DeviceWithPortsOutputBase(x, y, deviceClass, outputType, displayName, numberOfPorts, valueKey,
									 minVal, maxVal, displayUnits){
	CommandBlock.call(this,x,y,deviceClass.getDeviceTypeId());
	this.deviceClass = deviceClass;
	this.outputType = outputType;
	this.displayName = displayName;
	this.numberOfPorts = numberOfPorts;
	this.minVal = minVal;
	this.maxVal = maxVal;
	this.positive = minVal >= 0;
	this.valueKey = valueKey;
	this.displayUnits = displayUnits;
	this.addPart(new DeviceDropSlot(this,"DDS_1", deviceClass));
	this.addPart(new LabelText(this,displayName));
	this.addPart(new PortSlot(this,"PortS_1", numberOfPorts)); //Four sensor ports.
	const numSlot = new NumSlot(this,"NumS_out", 0, this.positive, true);
	numSlot.addLimits(this.minVal, this.maxVal, displayUnits);
	this.addPart(numSlot);
}
B_DeviceWithPortsOutputBase.prototype = Object.create(CommandBlock.prototype);
B_DeviceWithPortsOutputBase.prototype.constructor = B_DeviceWithPortsOutputBase;
/* Sends the request */
B_DeviceWithPortsOutputBase.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let mem = this.runMem;
	let port = this.slots[1].getData().getValue();
	let value = this.slots[2].getData().getValueInR(this.minVal, this.maxVal, this.positive, true);
	if (port != null && port > 0 && port <= this.numberOfPorts) {
		mem.requestStatus = {};
		mem.requestStatus.finished = false;
		mem.requestStatus.error = false;
		mem.requestStatus.result = null;
		device.setOutput(mem.requestStatus, this.outputType, port, value, this.valueKey);
		return new ExecutionStatusRunning();
	} else {
		this.displayError("Invalid port number");
		return new ExecutionStatusError(); // Invalid port, exit early
	}
};
/* Waits until the request completes */
B_DeviceWithPortsOutputBase.prototype.updateAction = function() {
	if(this.runMem.requestStatus.finished){
		if(this.runMem.requestStatus.error){
			let status = this.runMem.requestStatus;
			this.displayError(this.deviceClass.getNotConnectedMessage(status.code, status.result));
			return new ExecutionStatusError();
		}
		return new ExecutionStatusDone();
	}
	else{
		return new ExecutionStatusRunning();
	}
};


/**
 * Block that sets a Tri-LED
 * @param {number} x
 * @param {number} y
 * @param deviceClass - A subclass of Device indicating the type of robot
 * @param {number} numberOfPorts - Number of Tri-LED ports on the device
 * @constructor
 */
function B_DeviceWithPortsTriLed(x, y, deviceClass, numberOfPorts) {
	CommandBlock.call(this, x, y, deviceClass.getDeviceTypeId());
	this.deviceClass = deviceClass;
	this.numberOfPorts = numberOfPorts;
	this.addPart(new DeviceDropSlot(this,"DDS_1", deviceClass, false)); //true for short text label
	this.addPart(new LabelText(this, "TRI-LED"));
	const portSlot = new PortSlot(this,"PortS_1", numberOfPorts); //Positive integer.
	portSlot.isEndOfLine = true;
	this.addPart(portSlot);
	this.addPart(new LabelText(this, "R"));
	const ledSlot1 = new NumSlot(this,"NumS_r", 0, true, true); //Positive integer.
	ledSlot1.addLimits(0, 100, "Intensity");
	this.addPart(ledSlot1);
	this.addPart(new LabelText(this, "G"));
	const ledSlot2 = new NumSlot(this,"NumS_g", 0, true, true); //Positive integer.
	ledSlot2.addLimits(0, 100, "Intensity");
	this.addPart(ledSlot2);
	this.addPart(new LabelText(this, "B"));
	const ledSlot3 = new NumSlot(this,"NumS_b", 0, true, true); //Positive integer.
	ledSlot3.addLimits(0, 100, "Intensity");
	this.addPart(ledSlot3);
}
B_DeviceWithPortsTriLed.prototype = Object.create(CommandBlock.prototype);
B_DeviceWithPortsTriLed.prototype.constructor = B_DeviceWithPortsTriLed;
/* Sends the request */
B_DeviceWithPortsTriLed.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let mem = this.runMem;
	mem.requestStatus = {};
	let port = this.slots[1].getData().getValue(); // Positive integer.
	let valueR = this.slots[2].getData().getValueInR(0, 100, true, true); //Positive integer.
	let valueG = this.slots[3].getData().getValueInR(0, 100, true, true); //Positive integer.
	let valueB = this.slots[4].getData().getValueInR(0, 100, true, true); //Positive integer.
	if (port != null && port > 0 && port <= this.numberOfPorts) {
		device.setTriLed(mem.requestStatus, port, valueR, valueG, valueB);
		return new ExecutionStatusRunning();
	} else {
		this.displayError("Invalid port number");
		return new ExecutionStatusError(); // Invalid port, exit early
	}
};
/* Waits for the request to finish. */
B_DeviceWithPortsTriLed.prototype.updateAction = function() {
	if(this.runMem.requestStatus.finished){
		if(this.runMem.requestStatus.error){
			let status = this.runMem.requestStatus;
			this.displayError(this.deviceClass.getNotConnectedMessage(status.code, status.result));
			return new ExecutionStatusError();
		}
		return new ExecutionStatusDone();
	}
	else{
		return new ExecutionStatusRunning();
	}
};

/* This file contains the implementations of hummingbird blocks
 */
function B_HummingbirdOutputBase(x, y, outputType, displayName, numberOfPorts, valueKey, minVal, maxVal, displayUnits) {
	B_DeviceWithPortsOutputBase.call(this, x, y, DeviceHummingbird, outputType, displayName, numberOfPorts, valueKey,
		minVal, maxVal, displayUnits);
}
B_HummingbirdOutputBase.prototype = Object.create(B_DeviceWithPortsOutputBase.prototype);
B_HummingbirdOutputBase.prototype.constructor = B_HummingbirdOutputBase;



function B_HBServo(x, y) {
	B_HummingbirdOutputBase.call(this, x, y, "servo", "Servo", 4, "angle", 0, 180, "Angle");
}
B_HBServo.prototype = Object.create(B_HummingbirdOutputBase.prototype);
B_HBServo.prototype.constructor = B_HBServo;



function B_HBMotor(x, y) {
	B_HummingbirdOutputBase.call(this, x, y, "motor", "Motor", 2, "speed", -100, 100, "Speed");
}
B_HBMotor.prototype = Object.create(B_HummingbirdOutputBase.prototype);
B_HBMotor.prototype.constructor = B_HBMotor;



function B_HBVibration(x, y) {
	B_HummingbirdOutputBase.call(this, x, y, "vibration", "Vibration", 2, "intensity", 0, 100, "Intensity");
}
B_HBVibration.prototype = Object.create(B_HummingbirdOutputBase.prototype);
B_HBVibration.prototype.constructor = B_HBVibration;



function B_HBLed(x, y) {
	B_HummingbirdOutputBase.call(this, x, y, "led", "LED", 4, "intensity", 0, 100, "Intensity");
}
B_HBLed.prototype = Object.create(B_HummingbirdOutputBase.prototype);
B_HBLed.prototype.constructor = B_HBLed;



function B_HummingbirdSensorBase(x, y, sensorType, displayName) {
	B_DeviceWithPortsSensorBase.call(this, x, y, DeviceHummingbird, sensorType, displayName, 4);
}
B_HummingbirdSensorBase.prototype = Object.create(B_DeviceWithPortsSensorBase.prototype);
B_HummingbirdSensorBase.prototype.constructor = B_HummingbirdSensorBase;



function B_HBLight(x, y) {
	B_HummingbirdSensorBase.call(this, x, y, "light", "Light");
}
B_HBLight.prototype = Object.create(B_HummingbirdSensorBase.prototype);
B_HBLight.prototype.constructor = B_HBLight;



function B_HBTempC(x, y) {
	B_HummingbirdSensorBase.call(this, x, y, "temperature", "Temperature C");
}
B_HBTempC.prototype = Object.create(B_HummingbirdSensorBase.prototype);
B_HBTempC.prototype.constructor = B_HBTempC;
Block.setDisplaySuffix(B_HBTempC, String.fromCharCode(176) + "C");



function B_HBDistCM(x, y) {
	B_HummingbirdSensorBase.call(this, x, y, "distance", "Distance CM");
}
B_HBDistCM.prototype = Object.create(B_HummingbirdSensorBase.prototype);
B_HBDistCM.prototype.constructor = B_HBDistCM;
Block.setDisplaySuffix(B_HBDistCM, "cm");



function B_HBKnob(x, y) {
	B_HummingbirdSensorBase.call(this, x, y, "sensor", "Knob");
}
B_HBKnob.prototype = Object.create(B_HummingbirdSensorBase.prototype);
B_HBKnob.prototype.constructor = B_HBKnob;



function B_HBSound(x, y) {
	B_HummingbirdSensorBase.call(this, x, y, "sound", "Sound");
}
B_HBSound.prototype = Object.create(B_HummingbirdSensorBase.prototype);
B_HBSound.prototype.constructor = B_HBSound;


function B_HBTriLed(x, y) {
	B_DeviceWithPortsTriLed.call(this, x, y, DeviceHummingbird, 2);
}
B_HBTriLed.prototype = Object.create(B_DeviceWithPortsTriLed.prototype);
B_HBTriLed.prototype.constructor = B_HBTriLed;


/* Special Blocks */


function B_HBTempF(x, y) {
	B_HummingbirdSensorBase.call(this, x, y, "temperature", "Temperature F");
}
B_HBTempF.prototype = Object.create(B_HummingbirdSensorBase.prototype);
B_HBTempF.prototype.constructor = B_HBTempF;
/* Waits for the request to finish then converts C to F. */
B_HBTempF.prototype.updateAction = function() {
	const status = B_DeviceWithPortsSensorBase.prototype.updateAction.call(this);
	if (status.hasError() || status.isRunning()) {
		return status;
	} else {
		let resultC = status.getResult();
		if (resultC != null && resultC.isValid) {
			let result = new NumData(Math.round(resultC.getValue() * 1.8 + 32));
			return new ExecutionStatusResult(result);
		} else {
			return status;
		}
	}
};
Block.setDisplaySuffix(B_HBTempF, String.fromCharCode(176) + "F");



function B_HBDistInch(x, y) {
	B_HummingbirdSensorBase.call(this, x, y, "distance", "Distance Inch");
}
B_HBDistInch.prototype = Object.create(B_HummingbirdSensorBase.prototype);
B_HBDistInch.prototype.constructor = B_HBDistInch;
/* Waits for the request to finish then converts cm to in. */
B_HBDistInch.prototype.updateAction = function() {
	const status = B_DeviceWithPortsSensorBase.prototype.updateAction.call(this);
	if (status.hasError() || status.isRunning()) {
		return status;
	} else {
		let resultMm = status.getResult();
		if (resultMm != null && resultMm.isValid) {
			let result = new NumData((resultMm.getValue() / 2.54).toFixed(0) * 1);
			return new ExecutionStatusResult(result);
		} else {
			return status;
		}
	}
};
Block.setDisplaySuffix(B_HBDistInch, "inches");
/* This file contains the implementations of MicroBit blocks
 */

//MARK: micro:bit outputs in case they're needed later.

function B_MicroBitOutputBase(x, y, outputType, displayName, numberOfPorts, valueKey, minVal, maxVal, displayUnits) {
	B_DeviceWithPortsOutputBase.call(this, x, y, DeviceMicroBit, outputType, displayName, numberOfPorts, valueKey,
		minVal, maxVal, displayUnits);
}
B_MicroBitOutputBase.prototype = Object.create(B_DeviceWithPortsOutputBase.prototype);
<<<<<<< HEAD
B_MicroBitOutputBase.prototype.constructor = B_HummingbirdBitOutputBase;
=======
B_MicroBitOutputBase.prototype.constructor = B_MicroBitOutputBase;
>>>>>>> 4a497dd4bb1d206bec66147198ea8b2f33fe75e1



//MARK: outputs
function B_MicroBitLedArray(x, y, deviceClass) {
  CommandBlock.call(this,x,y,deviceClass.getDeviceTypeId());
	this.deviceClass = deviceClass;
	this.displayName = "LED Array";

  this.addPart(new DeviceDropSlot(this,"DDS_1", this.deviceClass));
  const label = new LabelText(this,this.displayName);
  label.isEndOfLine = true;
	this.addPart(label);

  for (let i = 0; i < 5; i++ ){
    this.addPart(new ToggleSlot(this, "Toggle_led1" + i));
    this.addPart(new ToggleSlot(this, "Toggle_led2" + i));
    this.addPart(new ToggleSlot(this, "Toggle_led3" + i));
    this.addPart(new ToggleSlot(this, "Toggle_led4" + i));
    const lastLed = new ToggleSlot(this, "Toggle_led5" + i);
    lastLed.isEndOfLine = true;
    this.addPart(lastLed);
  }


}
B_MicroBitLedArray.prototype = Object.create(CommandBlock.prototype);
B_MicroBitLedArray.prototype.constructor = B_MicroBitLedArray;
/* Sends the request */
B_MicroBitLedArray.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}

  let ledStatusString = "";
  for (let i = 0; i < 25; i++){
    if (this.slots[i + 1].getData().getValue()){
      ledStatusString += "1";
    } else {
      ledStatusString += "0";
    }
  }

	let mem = this.runMem;
  mem.requestStatus = {};
	mem.requestStatus.finished = false;
	mem.requestStatus.error = false;
	mem.requestStatus.result = null;

	device.setLedArray(mem.requestStatus, ledStatusString);
	return new ExecutionStatusRunning();
}
/* Waits until the request completes */
B_MicroBitLedArray.prototype.updateAction = B_DeviceWithPortsOutputBase.prototype.updateAction


<<<<<<< HEAD
/*Code that I added
=======
//Code that I added
>>>>>>> 4a497dd4bb1d206bec66147198ea8b2f33fe75e1
// ASK WHAT SHOULD THE 2nd field of NumOrStringSlot be??


function B_MBPrint(x, y, deviceClass, numberOfPorts) {
	CommandBlock.call(this, x, y, deviceClass.getDeviceTypeId());
	this.deviceClass = deviceClass;
    this.dislayName = "Print Block"
	this.addPart(new DeviceDropSlot(this,"DDS_1", deviceClass, true));
	this.addPart(new LabelText(this, "Print (Hi or 90)"));
	// Default message that is displayed
	this.addPart(new StringSlot(this, "StrS_msg", "Hello"));
}

B_MBPrint.prototype = Object.create(B_MicroBitOutputBase.prototype);
B_MBPrint.prototype.constructor = B_MBPrint;

// Sends the request
B_MBPrint.prototype.startAction = function() {

    const mem = this.runMem;
    mem.request = "tablet/pressure";
    mem.requestStatus = function() {};
    HtmlServer.sendRequest(mem.request, mem.requestStatus);
    return new ExecutionStatusRunning(); // Still running

};


//Waits for the request to finish.

B_MBPrint.prototype.updateAction = function() {
if(this.runMem.requestStatus.finished){
		if(this.runMem.requestStatus.error){
			let status = this.runMem.requestStatus;
			this.displayError(this.deviceClass.getNotConnectedMessage(status.code, status.result));
			return new ExecutionStatusError();
		}
		return new ExecutionStatusDone();
	}
	else{
		return new ExecutionStatusRunning();
	}
};




<<<<<<< HEAD
//end of code that I added */


/* Try #2 at the micro:bit print block

function B_MBPrintOutputBase(x, y, deviceClass, outputType, displayName, numberOfPorts, valueKey){

	CommandBlock.call(this,x,y,deviceClass.getDeviceTypeId());
	this.deviceClass = deviceClass;
	this.outputType = outputType;
	this.displayName = displayName;
	this.numberOfPorts = numberOfPorts;

	this.valueKey = valueKey;

	this.addPart(new DeviceDropSlot(this,"DDS_1", deviceClass));
	this.addPart(new LabelText(this,displayName));

    // NOTE: The second field has to be equal to the KEY. Also see: StringSlot implementation.
	this.addPart(new StringSlot(this, "StrS_1", "HELLO"));
}

B_MBPrintOutputBase.prototype = Object.create(CommandBlock.prototype);
B_MBPrintOutputBase.prototype.constructor = B_MBPrintOutputBase;


// Sends the request
B_MBPrintOutputBase.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let mem = this.runMem;

	// Port is always set to 1 in the case of the micro:bit. Ask?
	let port = 1;

	if (port != null && port > 0 && port <= this.numberOfPorts) {
		mem.requestStatus = {};
		mem.requestStatus.finished = false;
		mem.requestStatus.error = false;
		mem.requestStatus.result = null;
		device.setOutput(mem.requestStatus, this.outputType, port, value, this.valueKey);
		return new ExecutionStatusRunning();
	} else {
		this.displayError("Invalid port number");
		return new ExecutionStatusError(); // Invalid port, exit early
	}
};

// Waits until the request completes
B_MBPrintOutputBase.prototype.updateAction = function() {
	if(this.runMem.requestStatus.finished){
		if(this.runMem.requestStatus.error){
			let status = this.runMem.requestStatus;
			this.displayError(this.deviceClass.getNotConnectedMessage(status.code, status.result));
			return new ExecutionStatusError();
		}
		return new ExecutionStatusDone();
	}
	else{
		return new ExecutionStatusRunning();
	}
};



function B_MBPrint(x, y) {
	B_MBPrintOutputBase.call(this, x, y, 2, "Print", 1, "Text");
}
B_MBPrint.prototype = Object.create(B_MBPrintOutputBase.prototype);
B_MBPrint.prototype.constructor = B_MBPrint;







// End of Try #2 at micro:bit block */


// Try #3 at micro:bit blocks





function B_MBPrint(x, y){
	CommandBlock.call(this, x, y, DeviceMicroBit.getDeviceTypeId());
	this.deviceClass = DeviceMicroBit;
	this.displayName = "Print (Hi or 90)";


	this.addPart(new DeviceDropSlot(this,"DDS_1", this.deviceClass));
	this.addPart(new LabelText(this,this.displayName));
	// StrS_1 refers to the first string slot.
	this.addPart(new StringSlot(this, "StrS_1", "HELLO"));

}

B_MBPrint.prototype = Object.create(CommandBlock.prototype);
B_MBPrint.prototype.constructor = B_MBPrint;

/* Sends the request */
B_MBPrint.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}

	let mem = this.runMem;
	let note = this.slots[1].getData();

	mem.requestStatus = {};
	mem.requestStatus.finished = false;
	mem.requestStatus.error = false;
	mem.requestStatus.result = null;

	return new ExecutionStatusRunning();
};

/* Waits until the request completes */
B_MBPrint.prototype.updateAction = B_DeviceWithPortsOutputBase.prototype.updateAction;



// End of Try #3 at micro:bit blocks.



// Try #1 of creating the micro:bit accelerometer and magnetometer blocks

function B_MBAccelerometerMagnetometer(x, y){
	CommandBlock.call(this, x, y, DeviceMicroBit.getDeviceTypeId());
	this.deviceClass = DeviceMicroBit;
	this.displayName = "";

    this.addPart(new LabelText(this, this.displayName));
    // Device menu
    this.addPart(new DeviceDropSlot(this,"DDS_1", this.deviceClass));

    //There are no ports for the accelerometer/magnetometer.

    const pickBlock = new DropSlot(this, "SDS_1", null, null, new SelectionData("Accelerometer", "accelerometer"));
    pickBlock.addOption(new SelectionData("Magnetometer", "magnetometer"));
    pickBlock.addOption(new SelectionData("Accelerometer", "accelerometer"));
    this.addPart(pickBlock);

    const pickAxis = new DropSlot(this, "SDS_2", null, null, new SelectionData("X", "x"));
    pickAxis.addOption(new SelectionData("X", "x"));
    pickAxis.addOption(new SelectionData("Y", "y"));
    pickAxis.addOption(new SelectionData("Z", "z"));
    this.addPart(pickAxis);

};


B_MBAccelerometerMagnetometer.prototype = Object.create(CommandBlock.prototype);
B_MBAccelerometerMagnetometer.prototype.constructor = B_MBAccelerometerMagnetometer;

/*
B_MBAccelerometerMagnetometer.prototype.startAction=function(){

    let deviceIndex = this.slots[0].getData().getValue();
    let blockSelection = this.slots[1].getData().getValue();

	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let mem = this.runMem;
	let axis = this.slots[2].getData().getValue();

	mem.requestStatus = {};
	mem.requestStatus.finished = false;
	mem.requestStatus.error = false;
	mem.requestStatus.result = null;
	//device.readSensor(mem.requestStatus, blockSelection, axis);

	return new ExecutionStatusRunning();

};
*/

B_MBAccelerometerMagnetometer.prototype.updateAction = B_DeviceWithPortsSensorBase.prototype.updateAction;
B_MBAccelerometerMagnetometer.prototype.startAction = B_DeviceWithPortsSensorBase.prototype.startAction;


// End of Try #1 of creating the micro:bit accelerometer and magnetometer blocks
=======
//end of code that I added
>>>>>>> 4a497dd4bb1d206bec66147198ea8b2f33fe75e1

function B_MBLedArray(x,y){
  B_MicroBitLedArray.call(this, x, y, DeviceMicroBit);
}
B_MBLedArray.prototype = Object.create(B_MicroBitLedArray.prototype);
B_MBLedArray.prototype.constructor = B_MBLedArray;

//MARK: inputs
function B_MBButton(x, y) {
	B_DeviceWithPortsSensorBase.call(this, x, y, DeviceMicroBit, "button", "Button", 2);
}
B_MBButton.prototype = Object.create(B_DeviceWithPortsSensorBase.prototype);
B_MBButton.prototype.constructor = B_MBButton;

function B_MBButton(x, y) {
	B_DeviceWithPortsSensorBase.call(this, x, y, DeviceMicroBit, "button", "Button", 2);
}
B_MBButton.prototype = Object.create(B_DeviceWithPortsSensorBase.prototype);
B_MBButton.prototype.constructor = B_MBButton;


// This is the micro:bit print block. Need to figure out how to enter both text and numbers.
// outputType is 2, because we want it to be a string.

/*
function B_MBPrint(x, y) {
	B_MicroBitOutputBase.call(this, x, y, 2, "Print", 0, "text", 0, 100, "Intensity");
}
B_MBPrint.prototype = Object.create(B_MicroBitOutputBase.prototype);
B_MBPrint.prototype.constructor = B_MBPrint;
*/
<<<<<<< HEAD
=======

>>>>>>> 4a497dd4bb1d206bec66147198ea8b2f33fe75e1
/* This file contains the implementations of hummingbird bit blocks
 */

 //MARK: hummingbird bit outputs
function B_HummingbirdBitOutputBase(x, y, outputType, displayName, numberOfPorts, valueKey, minVal, maxVal, displayUnits) {
	B_DeviceWithPortsOutputBase.call(this, x, y, DeviceHummingbirdBit, outputType, displayName, numberOfPorts, valueKey,
		minVal, maxVal, displayUnits);
}
B_HummingbirdBitOutputBase.prototype = Object.create(B_DeviceWithPortsOutputBase.prototype);
B_HummingbirdBitOutputBase.prototype.constructor = B_HummingbirdBitOutputBase;

function B_BBPositionServo(x, y) {
	B_HummingbirdBitOutputBase.call(this, x, y, "servo", "Position Servo", 4, "angle", 0, 180, "Angle");

  this.addPart(new LabelText(this,'\xBA'));
}
B_BBPositionServo.prototype = Object.create(B_HummingbirdBitOutputBase.prototype);
B_BBPositionServo.prototype.constructor = B_BBPositionServo;

function B_BBRotationServo(x, y) {
	B_HummingbirdBitOutputBase.call(this, x, y, "servo", "Rotation Servo", 4, "percent", -100, 100, "Percent");

  this.addPart(new LabelText(this,"%"));
}
B_BBRotationServo.prototype = Object.create(B_HummingbirdBitOutputBase.prototype);
B_BBRotationServo.prototype.constructor = B_BBRotationServo;

function B_BBLed(x, y) {
	B_HummingbirdBitOutputBase.call(this, x, y, "led", "LED", 4, "intensity", 0, 100, "Intensity");

  this.addPart(new LabelText(this,"%"));
}
B_BBLed.prototype = Object.create(B_HummingbirdBitOutputBase.prototype);
B_BBLed.prototype.constructor = B_BBLed;

function B_BBTriLed(x, y) {
	B_DeviceWithPortsTriLed.call(this, x, y, DeviceHummingbirdBit, 2);
}
B_BBTriLed.prototype = Object.create(B_DeviceWithPortsTriLed.prototype);
B_BBTriLed.prototype.constructor = B_BBTriLed;



function B_BBBuzzer(x, y){
	CommandBlock.call(this,x,y,DeviceHummingbirdBit.getDeviceTypeId());
	this.deviceClass = DeviceHummingbirdBit;
	this.displayName = "Play note";
  this.minNote = 0
  this.maxNote = 127
  this.minBeat = 0
  this.maxBeat = 16

	this.addPart(new DeviceDropSlot(this,"DDS_1", this.deviceClass));
	this.addPart(new LabelText(this,this.displayName));
	const noteSlot = new NumSlot(this,"Note_out", 60, true, true);
	noteSlot.addLimits(this.minNote, this.maxNote, "Note");
	this.addPart(noteSlot);
  this.addPart(new LabelText(this,"for"));
  const beatsSlot = new NumSlot(this,"Beats_out", 1, true, false);
  beatsSlot.addLimits(this.minBeat, this.maxBeat, "Beats");
  this.addPart(beatsSlot);
  this.addPart(new LabelText(this,"Beats"));
}
B_BBBuzzer.prototype = Object.create(CommandBlock.prototype);
B_BBBuzzer.prototype.constructor = B_BBBuzzer;
/* Sends the request */
B_BBBuzzer.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let mem = this.runMem;
	let note = this.slots[1].getData().getValueInR(this.minNote, this.maxNote, true, true)
	let beats = this.slots[2].getData().getValueInR(this.minBeat, this.maxBeat, true, false);
  let soundDuration = CodeManager.beatsToMs(beats);

	mem.requestStatus = {};
	mem.requestStatus.finished = false;
	mem.requestStatus.error = false;
	mem.requestStatus.result = null;

	device.setBuzzer(mem.requestStatus, note, soundDuration);
	return new ExecutionStatusRunning();
};
/* Waits until the request completes */
B_BBBuzzer.prototype.updateAction = B_DeviceWithPortsOutputBase.prototype.updateAction

//MARK: microbit outputs



function B_BBLedArray(x,y){
  B_MicroBitLedArray.call(this, x, y, DeviceHummingbirdBit);
}
B_BBLedArray.prototype = Object.create(B_MicroBitLedArray.prototype);
B_BBLedArray.prototype.constructor = B_BBLedArray;


//MARK: hummingbird bit sensors
function B_HummingbirdBitSensorBase(x, y, sensorType, displayName) {
	B_DeviceWithPortsSensorBase.call(this, x, y, DeviceHummingbirdBit, sensorType, displayName, 4);
}
B_HummingbirdBitSensorBase.prototype = Object.create(B_DeviceWithPortsSensorBase.prototype);
B_HummingbirdBitSensorBase.prototype.constructor = B_HummingbirdBitSensorBase;

function B_BBKnob(x, y) {
	B_HummingbirdBitSensorBase.call(this, x, y, "sensor", "Knob");
}
B_BBKnob.prototype = Object.create(B_HummingbirdBitSensorBase.prototype);
B_BBKnob.prototype.constructor = B_BBKnob;

function B_BBSensors(x, y){
	ReporterBlock.call(this,x,y,DeviceHummingbirdBit.getDeviceTypeId());
	this.deviceClass = DeviceHummingbirdBit;
	this.displayName = ""; //TODO: perhapse remove this
	this.numberOfPorts = 3;

  // Default option for sensor is Light.
  const dS = new DropSlot(this, "SDS_1", null, null, new SelectionData("Light", "light"));
  //const dS = new DropSlot(this, "SDS_1", null, null, new SelectionData("", 0));
  dS.addOption(new SelectionData("Distance (cm)", "distance"));
  dS.addOption(new SelectionData("Dial", "dial"));
  dS.addOption(new SelectionData("Light", "light"));
  dS.addOption(new SelectionData("Sound", "sound"));
  dS.addOption(new SelectionData("Other (V)", "other"));

	this.addPart(new DeviceDropSlot(this,"DDS_1", this.deviceClass));
	this.addPart(new LabelText(this,this.displayName));
  this.addPart(dS);
	this.addPart(new PortSlot(this,"PortS_1", this.numberOfPorts));
}
B_BBSensors.prototype = Object.create(ReporterBlock.prototype);
B_BBSensors.prototype.constructor = B_BBSensors;
/* Sends the request for the sensor data. */
B_BBSensors.prototype.startAction=function(){
	let deviceIndex = this.slots[0].getData().getValue();
  let sensorSelection = this.slots[1].getData().getValue();
  console.log(sensorSelection)
	let device = this.deviceClass.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(this.deviceClass.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let mem = this.runMem;
	let port = this.slots[2].getData().getValue();
	if (port != null && port > 0 && port <= this.numberOfPorts) {
		mem.requestStatus = {};
		mem.requestStatus.finished = false;
		mem.requestStatus.error = false;
		mem.requestStatus.result = null;
		device.readSensor(mem.requestStatus, sensorSelection, port);
		return new ExecutionStatusRunning();
	} else {
		this.displayError("Invalid port number");
		return new ExecutionStatusError(); // Invalid port, exit early
	}
};
/* Returns the result of the request */
B_BBSensors.prototype.updateAction = B_DeviceWithPortsSensorBase.prototype.updateAction;

//MARK: microbit sensor
function B_BBButton(x, y) {
	B_DeviceWithPortsSensorBase.call(this, x, y, DeviceHummingbirdBit, "button", "Button", 2);
}
B_BBButton.prototype = Object.create(B_DeviceWithPortsSensorBase.prototype);
B_BBButton.prototype.constructor = B_BBButton;



function B_BBAccelerometerMagnetometer(x, y){
	CommandBlock.call(this, x, y, DeviceHummingbirdBit.getDeviceTypeId());
	this.deviceClass = DeviceHummingbirdBit;
	this.displayName = "";

    this.addPart(new LabelText(this, this.displayName));
    // Device menu
    this.addPart(new DeviceDropSlot(this,"DDS_1", this.deviceClass));

    //There are no ports for the accelerometer/magnetometer.

    const pickBlock = new DropSlot(this, "SDS_1", null, null, new SelectionData("Accelerometer", "accelerometer"));
    pickBlock.addOption(new SelectionData("Magnetometer", "magnetometer"));
    pickBlock.addOption(new SelectionData("Accelerometer", "accelerometer"));
    this.addPart(pickBlock);

    const pickAxis = new DropSlot(this, "SDS_2", null, null, new SelectionData("X", "x"));
    pickAxis.addOption(new SelectionData("X", "x"));
    pickAxis.addOption(new SelectionData("Y", "y"));
    pickAxis.addOption(new SelectionData("Z", "z"));
    this.addPart(pickAxis);

};


B_BBAccelerometerMagnetometer.prototype = Object.create(CommandBlock.prototype);
B_BBAccelerometerMagnetometer.prototype.constructor = B_BBAccelerometerMagnetometer;

B_BBAccelerometerMagnetometer.prototype.updateAction = B_DeviceWithPortsSensorBase.prototype.updateAction;
B_BBAccelerometerMagnetometer.prototype.startAction = B_DeviceWithPortsSensorBase.prototype.startAction;



/* This file contains implementations of flutter Blocks */


/* Output blocks */
function B_FlutterServo(x, y) {
	B_DeviceWithPortsOutputBase.call(this, x, y, DeviceFlutter, "servo", "Servo", 3, "angle", 0, 180, "Angle");
}
B_FlutterServo.prototype = Object.create(B_DeviceWithPortsOutputBase.prototype);
B_FlutterServo.prototype.constructor = B_FlutterServo;



function B_FlutterTriLed(x, y) {
	B_DeviceWithPortsTriLed.call(this, x, y, DeviceFlutter, 3);
}
B_FlutterTriLed.prototype = Object.create(B_DeviceWithPortsTriLed.prototype);
B_FlutterTriLed.prototype.constructor = B_FlutterTriLed;



function B_FlutterBuzzer(x, y) {
	CommandBlock.call(this, x, y, "flutter");
	this.addPart(new DeviceDropSlot(this, "DDS_1", DeviceFlutter, true));
	this.addPart(new LabelText(this, "Buzzer"));
	this.addPart(new LabelText(this, "Volume"));
	const numSlot = new NumSlot(this, "NumS_vol", 20, true, true);
	numSlot.addLimits(0, 100);
	this.addPart(numSlot);
	this.addPart(new LabelText(this, "Frequency"));
	const numSlot2 = new NumSlot(this, "NumS_freq", 10000, true, true);
	numSlot2.addLimits(0, 20000);
	this.addPart(numSlot2);
}
B_FlutterBuzzer.prototype = Object.create(CommandBlock.prototype);
B_FlutterBuzzer.prototype.constructor = B_FlutterBuzzer;
/* Sends request */
B_FlutterBuzzer.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = DeviceFlutter.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(DeviceFlutter.getNotConnectedMessage());
		return new ExecutionStatusError(); // Flutter was invalid, exit early
	}
	let volume = this.slots[1].getData().getValueInR(0, 100, true, true);
	let frequency = this.slots[2].getData().getValueInR(0, 20000, true, true);
	this.runMem.requestStatus = {};
	device.setBuzzer(this.runMem.requestStatus, volume, frequency);
	return new ExecutionStatusRunning();
};
/* Waits for request to finish */
B_FlutterBuzzer.prototype.updateAction = function() {
	if (this.runMem.requestStatus.finished) {
		if (this.runMem.requestStatus.error) {
			const status = this.runMem.requestStatus;
			this.displayError(DeviceFlutter.getNotConnectedMessage(status.code, status.result));
			return new ExecutionStatusError();
		}
		return new ExecutionStatusDone();
	} else {
		return new ExecutionStatusRunning();
	}
};



/* Input Blocks */
function B_FlutterSensorBase(x, y, sensorType, displayName) {
	B_DeviceWithPortsSensorBase.call(this, x, y, DeviceFlutter, sensorType, displayName, 3);
}
B_FlutterSensorBase.prototype = Object.create(B_DeviceWithPortsSensorBase.prototype);
B_FlutterSensorBase.constructor = B_FlutterSensorBase;



function B_FlutterLight(x, y) {
	B_FlutterSensorBase.call(this, x, y, "light", "Light");
}
B_FlutterLight.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterLight.prototype.constructor = B_FlutterLight;



function B_FlutterTempC(x, y) {
	B_FlutterSensorBase.call(this, x, y, "temperature", "Temperature C");
}
B_FlutterTempC.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterTempC.prototype.constructor = B_FlutterTempC;
Block.setDisplaySuffix(B_FlutterTempC, String.fromCharCode(176) + "C");



function B_FlutterDistCM(x, y) {
	B_FlutterSensorBase.call(this, x, y, "distance", "Distance CM");
}
B_FlutterDistCM.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterDistCM.prototype.constructor = B_FlutterDistCM;
Block.setDisplaySuffix(B_FlutterDistCM, "cm");



function B_FlutterKnob(x, y) {
	B_FlutterSensorBase.call(this, x, y, "sensor", "Knob");
}
B_FlutterKnob.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterKnob.prototype.constructor = B_FlutterKnob;



function B_FlutterSoil(x, y) {
	B_FlutterSensorBase.call(this, x, y, "soil", "Soil Moisture");
}
B_FlutterSoil.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterSoil.prototype.constructor = B_FlutterSoil;



function B_FlutterSound(x, y) {
	B_FlutterSensorBase.call(this, x, y, "sound", "Sound");
}
B_FlutterSound.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterSound.prototype.constructor = B_FlutterSound;



function B_FlutterTempF(x, y) {
	B_FlutterSensorBase.call(this, x, y, "temperature", "Temperature F");
}
B_FlutterTempF.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterTempF.prototype.constructor = B_FlutterTempF;
/* Waits for the request to finish then converts C to F. */
B_FlutterTempF.prototype.updateAction = function() {
	const status = B_FlutterSensorBase.prototype.updateAction.call(this);
	if (status.hasError() || status.isRunning()) {
		return status;
	} else {
		let resultC = status.getResult();
		if (resultC != null && resultC.isValid) {
			let result = new NumData(Math.round(resultC.getValue() * 1.8 + 32));
			return new ExecutionStatusResult(result);
		} else {
			return status;
		}
	}
};
Block.setDisplaySuffix(B_FlutterTempF, String.fromCharCode(176) + "F");



function B_FlutterDistInch(x, y) {
	B_FlutterSensorBase.call(this, x, y, "distance", "Distance Inch");
}
B_FlutterDistInch.prototype = Object.create(B_FlutterSensorBase.prototype);
B_FlutterDistInch.prototype.constructor = B_FlutterDistInch;
/* Waits for the request to finish then converts cm to in. */
B_FlutterDistInch.prototype.updateAction = function() {
	const status = B_FlutterSensorBase.prototype.updateAction.call(this);
	if (status.hasError() || status.isRunning()) {
		return status;
	} else {
		let resultMm = status.getResult();
		if (resultMm != null && resultMm.isValid) {
			let result = new NumData((resultMm.getValue() / 2.54).toFixed(0) * 1);
			return new ExecutionStatusResult(result);
		} else {
			return status;
		}
	}
};
Block.setDisplaySuffix(B_FlutterDistInch, "inches");
// This is a block for debugging only.
function B_FinchSetAll(x, y) {
	CommandBlock.call(this, x, y, "finch");
	this.addPart(new DeviceDropSlot(this,"DDS_1", DeviceFinch));
	this.addPart(new LabelText(this,"Set All"));
	this.addPart(new StringSlot(this, "StrS_data", "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"));
}
B_FinchSetAll.prototype = Object.create(CommandBlock.prototype);
B_FinchSetAll.prototype.constructor = B_FinchSetAll;
/* Sends request */
B_FinchSetAll.prototype.startAction = function() {
	let deviceIndex = this.slots[0].getData().getValue();
	let device = DeviceFinch.getManager().getDevice(deviceIndex);
	if (device == null) {
		this.displayError(DeviceFinch.getNotConnectedMessage());
		return new ExecutionStatusError(); // Finch was invalid, exit early
	}
	const status = this.runMem.requestStatus = {};
	device.setAll(status, this.slots[1].getData().getValue());
	return new ExecutionStatusRunning();
};
/* Waits for request to finish */
B_FinchSetAll.prototype.updateAction = function() {
	if (this.runMem.requestStatus.finished) {
		if (this.runMem.requestStatus.error) {
			const status = this.runMem.requestStatus;
			this.displayError(DeviceFlutter.getNotConnectedMessage(status.code, status.result));
			return new ExecutionStatusError();
		}
		return new ExecutionStatusDone();
	} else {
		return new ExecutionStatusRunning();
	}
};
/* This file contains the implementations for Blocks in the control category.
 * Each has a constructor which adds the parts specific to the Block and overrides methods relating to execution.
 */
function B_WhenFlagTapped(x, y) {
	HatBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "when"));
	// Add flag icon with height 15
	this.addPart(new BlockIcon(this, VectorPaths.flag, TitleBar.flagFill, "flag", 15));
	this.addPart(new LabelText(this, "tapped"));
}
B_WhenFlagTapped.prototype = Object.create(HatBlock.prototype);
B_WhenFlagTapped.prototype.constructor = B_WhenFlagTapped;
/* Triggers stack to start running. */
B_WhenFlagTapped.prototype.eventFlagClicked = function() {
	this.stack.startRun();
};
/* Does nothing */
B_WhenFlagTapped.prototype.startAction = function() {
	return new ExecutionStatusDone();
};



function B_WhenIReceive(x, y) {
	HatBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "when I receive"));
	// Creates a BroadcastDropSlot that does nt allow snapping
	this.addPart(new BroadcastDropSlot(this, "BDS_msg", true));
}
B_WhenIReceive.prototype = Object.create(HatBlock.prototype);
B_WhenIReceive.prototype.constructor = B_WhenIReceive;
B_WhenIReceive.prototype.eventBroadcast = function(message) {
	// Get data from Slot (returns instantly since snapping is not allowed)
	const data = this.slots[0].getDataNotFromChild();
	let shouldRun = false;
	if (data.isSelection()) {
		const selection = data.getValue();
		if(selection === "any_message") {
			shouldRun = true;
		}
	} else if (data.asString().getValue() === message) {
		shouldRun = true;
	}
	if (shouldRun) {
		this.stack.stop();
		this.stack.startRun(null, message);
	}
};
/* Does nothing */
B_WhenIReceive.prototype.startAction = function() {
	return new ExecutionStatusDone();
};



function B_Wait(x, y) {
	// Derived from CommandBlock
	// Category ("control") determines colors
	CommandBlock.call(this, x, y, "control");
	// Build Block out of things found in the BlockParts folder
	this.addPart(new LabelText(this, "wait"));
	this.addPart(new NumSlot(this, "NumS_dur", 1, true)); // Must be positive.
	this.addPart(new LabelText(this, "secs"));
}
B_Wait.prototype = Object.create(CommandBlock.prototype);
B_Wait.prototype.constructor = B_Wait;
/* Records current time. */
B_Wait.prototype.startAction = function() {
	// Each Block has runMem to store information for that execution
	const mem = this.runMem;
	mem.startTime = new Date().getTime();
	// Extract a positive value from first slot
	mem.delayTime = this.slots[0].getData().getValueWithC(true) * 1000;
	return new ExecutionStatusRunning(); //Still running
};
/* Waits until current time exceeds stored time plus delay. */
B_Wait.prototype.updateAction = function() {
	const mem = this.runMem;
	if (new Date().getTime() >= mem.startTime + mem.delayTime) {
		return new ExecutionStatusDone(); //Done running
	} else {
		return new ExecutionStatusRunning(); //Still running
	}
};



function B_WaitUntil(x, y) {
	CommandBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "wait until"));
	this.addPart(new BoolSlot(this, "BoolS_cond"));
}
B_WaitUntil.prototype = Object.create(CommandBlock.prototype);
B_WaitUntil.prototype.constructor = B_WaitUntil;
/* Checks condition. If true, stops running; if false, resets Block to check again. */
B_WaitUntil.prototype.startAction = function() {
	const stopWaiting = this.slots[0].getData().getValue();
	if (stopWaiting) {
		return new ExecutionStatusDone(); //Done running
	} else {
		this.running = 0; //startAction will be run next time, giving Slots ability to recalculate.
		this.clearMem(); //runMem and previous values of Slots will be removed.
		return new ExecutionStatusRunning(); //Still running
	}
};



function B_Forever(x, y) {
	LoopBlock.call(this, x, y, "control", false); //Bottom is not open.
	this.addPart(new LabelText(this, "repeat forever"));
}
B_Forever.prototype = Object.create(LoopBlock.prototype);
B_Forever.prototype.constructor = B_Forever;
/* Begins executing contents. */
B_Forever.prototype.startAction = function() {
	this.blockSlot1.startRun();
	return new ExecutionStatusRunning(); //Still running
};
/* Continues executing contents. If contents are done, runs them again. */
B_Forever.prototype.updateAction = function() {
	let blockSlotStatus = this.blockSlot1.updateRun();
	if (!blockSlotStatus.isRunning()) {
		if (blockSlotStatus.hasError()) {
			return blockSlotStatus;
		} else {
			this.blockSlot1.startRun();
		}
	}
	return new ExecutionStatusRunning(); //Still running. Never stops.
};



function B_Repeat(x, y) {
	LoopBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "repeat"));
	this.addPart(new NumSlot(this, "NumS_count", 10, true, true)); //Positive integer.
}
B_Repeat.prototype = Object.create(LoopBlock.prototype);
B_Repeat.prototype.constructor = B_Repeat;
/* Prepares counter and begins executing contents. */
B_Repeat.prototype.startAction = function() {
	const mem = this.runMem;
	mem.timesD = this.slots[0].getData();
	mem.times = mem.timesD.getValueWithC(true, true);
	mem.count = 0;
	if (mem.times > 0 && mem.timesD.isValid) {
		this.blockSlot1.startRun();
		return new ExecutionStatusRunning(); //Still running
	} else {
		return new ExecutionStatusDone();
	}
};
/* Update contents. When they finish, increment counter and possibly run them again. */
B_Repeat.prototype.updateAction = function() {
	let blockSlotStatus = this.blockSlot1.updateRun();
	if (!blockSlotStatus.isRunning()) {
		if (blockSlotStatus.hasError()) {
			return blockSlotStatus;
		} else {
			const mem = this.runMem;
			mem.count++;
			if (mem.count >= mem.times) {
				return new ExecutionStatusDone(); //Done running
			} else {
				this.blockSlot1.startRun();
			}
		}
	}
	return new ExecutionStatusRunning(); //Still running
};



function B_RepeatUntil(x, y) {
	LoopBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "repeat until"));
	this.addPart(new BoolSlot(this, "BoolS_cond"));
}
B_RepeatUntil.prototype = Object.create(LoopBlock.prototype);
B_RepeatUntil.prototype.constructor = B_RepeatUntil;
/* Checks condition and either stops running or executes contents. */
B_RepeatUntil.prototype.startAction = function() {
	const stopRepeating = this.slots[0].getData().getValue();
	if (stopRepeating) {
		return new ExecutionStatusDone(); //Done running
	} else {
		this.blockSlot1.startRun();
		return new ExecutionStatusRunning(); //Still running
	}
};
/* Updates contents until completed. Then resets Block to condition can be checked again. */
B_RepeatUntil.prototype.updateAction = function() {
	let blockSlotStatus = this.blockSlot1.updateRun();
	if (!blockSlotStatus.isRunning()) {
		if (blockSlotStatus.hasError()) {
			return blockSlotStatus;
		} else {
			this.running = 0; //startAction will be run next time, giving Slots ability to recalculate.
			this.clearMem(); //runMem and previous values of Slots will be removed.
		}
	}
	return new ExecutionStatusRunning(); //Still running
};



function B_If(x, y) {
	LoopBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "if"));
	this.addPart(new BoolSlot(this, "BoolS_cond"));
}
B_If.prototype = Object.create(LoopBlock.prototype);
B_If.prototype.constructor = B_If;
/* Either stops running or executes contents. */
B_If.prototype.startAction = function() {
	const check = this.slots[0].getData().getValue();
	if (check) {
		this.blockSlot1.startRun();
		return new ExecutionStatusRunning(); //Still running
	} else {
		return new ExecutionStatusDone(); //Done running
	}
};
/* Continues executing contents until completed. */
B_If.prototype.updateAction = function() {
	return this.blockSlot1.updateRun();
};



function B_IfElse(x, y) {
	DoubleLoopBlock.call(this, x, y, "control", "else");
	this.addPart(new LabelText(this, "if"));
	this.addPart(new BoolSlot(this, "BoolS_cond"));
}
B_IfElse.prototype = Object.create(DoubleLoopBlock.prototype);
B_IfElse.prototype.constructor = B_IfElse;
/* Starts executing one of two BlockSlots. */
B_IfElse.prototype.startAction = function() {
	this.runMem.check = this.slots[0].getData().getValue();
	if (this.runMem.check) {
		this.blockSlot1.startRun();
		return new ExecutionStatusRunning(); //Still running
	} else {
		this.blockSlot2.startRun();
		return new ExecutionStatusRunning(); //Still running
	}
};
/* Continues executing one of two BlockSlots until completion. */
B_IfElse.prototype.updateAction = function() {
	if (this.runMem.check) {
		return this.blockSlot1.updateRun();
	} else {
		return this.blockSlot2.updateRun();
	}
};



function B_Broadcast(x, y) {
	CommandBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "broadcast"));
	this.addPart(new BroadcastDropSlot(this, "BDS_msg", false));
}
B_Broadcast.prototype = Object.create(CommandBlock.prototype);
B_Broadcast.prototype.constructor = B_Broadcast;
/* Broadcast the message if one has been selected. */
B_Broadcast.prototype.startAction = function() {
	this.runMem.finished = false;
	const message = this.runMem.message = this.slots[0].getData().asString().getValue();
	if (message === "") {
		return new ExecutionStatusDone();
	}
	// Broadcasts are throttled if too many unanswered commands are present
	if (CodeManager.checkBroadcastDelay()) {
		CodeManager.message = new StringData(message);
		CodeManager.eventBroadcast(message);
		this.runMem.finished = true;
	}
	return new ExecutionStatusRunning();
};
/* Broadcasts if the briadcast hasn't been sent yet */
B_Broadcast.prototype.updateAction = function() {
	if (this.runMem.finished) {
		return new ExecutionStatusDone();
	}
	const message = this.runMem.message;
	if (CodeManager.checkBroadcastDelay()) {
		CodeManager.message = new StringData(message);
		CodeManager.eventBroadcast(message);
		this.runMem.finished = true;
	}
	return new ExecutionStatusRunning();
};



function B_BroadcastAndWait(x, y) {
	CommandBlock.call(this, x, y, "control");
	this.addPart(new LabelText(this, "broadcast"));
	this.addPart(new BroadcastDropSlot(this, "BDS_msg", false));
	this.addPart(new LabelText(this, "and wait"));
}
B_BroadcastAndWait.prototype = Object.create(CommandBlock.prototype);
B_BroadcastAndWait.prototype.constructor = B_BroadcastAndWait;
/* Broadcasts the message */
B_BroadcastAndWait.prototype.startAction = function() {
	const message = this.slots[0].getData().asString().getValue();
	if (message !== "") {
		this.runMem.message = message;
		CodeManager.message = new StringData(message);
		CodeManager.eventBroadcast(message);
	}
	return new ExecutionStatusRunning();
};
/* Checks if the broadcast is still running */
B_BroadcastAndWait.prototype.updateAction = function() {
	if (CodeManager.checkBroadcastRunning(this.runMem.message)) {
		return new ExecutionStatusRunning();
	} else {
		return new ExecutionStatusDone();
	}
};



function B_Message(x, y) {
	ReporterBlock.call(this, x, y, "control", Block.returnTypes.string);
	this.addPart(new LabelText(this, "message"));
}
B_Message.prototype = Object.create(ReporterBlock.prototype);
B_Message.prototype.constructor = B_Message;
/* Returns the last broadcast message */
B_Message.prototype.startAction = function() {
	return new ExecutionStatusResult(CodeManager.message);
};



function B_Stop(x, y) {
	CommandBlock.call(this, x, y, "control", true);
	this.addPart(new LabelText(this, "stop"));
	const dS = new DropSlot(this, "DS_act", null, null, new SelectionData("all", "all"));
	dS.addOption(new SelectionData("all", "all"));
	dS.addOption(new SelectionData("this script", "this_script"));
	//dS.addOption(new SelectionData("this block", "this_block"));
	dS.addOption(new SelectionData("all but this script", "all_but_this_script"));
	//dS.addOption(new SelectionData("other scripts in sprite", "other_scripts_in_sprite"));
	this.addPart(dS);
}
B_Stop.prototype = Object.create(CommandBlock.prototype);
B_Stop.prototype.constructor = B_Stop;
/* Stops whatever is selected */
B_Stop.prototype.startAction = function() {
	const selection = this.slots[0].getData().getValue();
	if (selection === "all") {
		CodeManager.stop();
	} else if (selection === "this_script") {
		this.stack.stop();
	} else if (selection === "all_but_this_script") {
		TabManager.stopAllButStack(this.stack);
	}
	return new ExecutionStatusDone();
};
/* This file contains the implementations for sensing Blocks, which have been moved to the tablet category
 * TODO: merge with tablet
 */



/* TODO: make sure dialogs don't show while a save dialog is up */
function B_Ask(x, y) {
	CommandBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "ask"));
	this.addPart(new StringSlot(this, "StrS_msg", "what's your name?"));
	this.addPart(new LabelText(this, "and wait"));
}
B_Ask.prototype = Object.create(CommandBlock.prototype);
B_Ask.prototype.constructor = B_Ask;
/* Show a dialog with the question unless another dialog is already visible or has been displayed recently. */
B_Ask.prototype.startAction = function() {
	const mem = this.runMem;
	mem.question = this.slots[0].getData().getValue();
	mem.questionDisplayed = false;
	// There is a delay between repeated dialogs to give the user time to stop the program.
	// Check if we can show the dialog or should delay.
	if (DialogManager.checkDialogDelay()) {
		this.showQuestion();
	}
	return new ExecutionStatusRunning();
};
/* Waits until the dialog has been displayed and completed. */
B_Ask.prototype.updateAction = function() {
	const mem = this.runMem;
	if (!mem.questionDisplayed) {   // If the question has not yet been displayed...
		if (DialogManager.checkDialogDelay()) {   // Check if we can show the dialog or should delay.
			this.showQuestion();   // Display the question.
		}
		return new ExecutionStatusRunning();   // Still running.
	} else {
		if (mem.finished === true) {   // Question has been answered.
			return new ExecutionStatusDone();   // Done running
		} else {   // Waiting on answer from user.
			return new ExecutionStatusRunning();   // Still running
		}
	}
};
/* Sends the request to show the dialog */
B_Ask.prototype.showQuestion = function() {
	const mem = this.runMem;
	mem.finished = false;   // Will be changed once answered.
	const callbackFn = function(cancelled, response) {
		if (cancelled) {
			CodeManager.answer = new StringData("", true);   //"" is the default answer.
		} else {
			CodeManager.answer = new StringData(response, true);   // Store the user's answer in the CodeManager.
		}
		mem.finished = true;   // Done waiting.
	};
	const callbackErr = function() {   // If an error occurs...
		CodeManager.answer = new StringData("", true);   //"" is the default answer.
		mem.finished = true;   // Done waiting.
	};
	DialogManager.showPromptDialog("Question", mem.question, "", true, callbackFn, callbackErr);   // Make the request.
	mem.questionDisplayed = true;   // Prevents displaying twice.
};



function B_Answer(x, y) {
	ReporterBlock.call(this, x, y, "tablet", Block.returnTypes.string);
	this.addPart(new LabelText(this, "answer"));
}
B_Answer.prototype = Object.create(ReporterBlock.prototype);
/* Result is whatever is stored in CodeManager. */
B_Answer.prototype.constructor = B_Answer;
B_Answer.prototype.startAction = function() {
	return new ExecutionStatusResult(CodeManager.answer);
};



function B_ResetTimer(x, y) {
	CommandBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "reset timer"));
}
B_ResetTimer.prototype = Object.create(CommandBlock.prototype);
B_ResetTimer.prototype.constructor = B_ResetTimer;
/* Reset the timer in CodeManager */
B_ResetTimer.prototype.startAction = function() {
	CodeManager.timerForSensingBlock = new Date().getTime();
	return new ExecutionStatusDone();
};



function B_Timer(x, y) {
	ReporterBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "timer"));
}
B_Timer.prototype = Object.create(ReporterBlock.prototype);
B_Timer.prototype.constructor = B_Timer;
/* Get the time and convert it to seconds */
B_Timer.prototype.startAction = function() {
	const now = new Date().getTime();
	const start = CodeManager.timerForSensingBlock;
	/* Round to 1 decimal */
	return new ExecutionStatusResult(new NumData((now - start) / 1000));
};
Block.setDisplaySuffix(B_Timer, "s");



function B_CurrentTime(x, y) {
	ReporterBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "current"));
	const dS = new DropSlot(this, "DS_interval", null, null, new SelectionData("date", "date"));
	dS.addOption(new SelectionData("year", "year"));
	dS.addOption(new SelectionData("month", "month"));
	dS.addOption(new SelectionData("date", "date"));
	dS.addOption(new SelectionData("day of the week", "day of the week"));
	dS.addOption(new SelectionData("hour", "hour"));
	dS.addOption(new SelectionData("minute", "minute"));
	dS.addOption(new SelectionData("second", "second"));
	dS.addOption(new SelectionData("time in milliseconds", "time in milliseconds"));
	this.addPart(dS);
}
B_CurrentTime.prototype = Object.create(ReporterBlock.prototype);
B_CurrentTime.prototype.constructor = B_CurrentTime;
/* Returns the current time in the desired units */
B_CurrentTime.prototype.startAction = function() {
	const unitD = this.slots[0].getData();
	if (unitD == null) {
		return new ExecutionStatusResult(new NumData(0, false));
	}
	const unit = unitD.getValue();
	if (unit === "year") {
		return new ExecutionStatusResult(new NumData(new Date().getFullYear()));
	} else if (unit === "month") {
		return new ExecutionStatusResult(new NumData(new Date().getMonth() + 1));
	} else if (unit === "date") {
		return new ExecutionStatusResult(new NumData(new Date().getDate()));
	} else if (unit === "day of the week") {
		return new ExecutionStatusResult(new NumData(new Date().getDay() + 1));
	} else if (unit === "hour") {
		return new ExecutionStatusResult(new NumData(new Date().getHours()));
	} else if (unit === "minute") {
		return new ExecutionStatusResult(new NumData(new Date().getMinutes()));
	} else if (unit === "second") {
		return new ExecutionStatusResult(new NumData(new Date().getSeconds()));
	} else if (unit === "time in milliseconds") {
		return new ExecutionStatusResult(new NumData(new Date().getTime()));
	}
	return new ExecutionStatusResult(new NumData(0, false));
};



function B_Display(x, y) {
	CommandBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "Display"));
	this.addPart(new StringSlot(this, "StrS_msg", "Hello"));
	this.addPart(new LabelText(this, "at"));
	const dS = new DropSlot(this, "DS_pos", null, null, new SelectionData("Position 3", "position3"));
	dS.addOption(new SelectionData("Position 1", "position1"));
	dS.addOption(new SelectionData("Position 2", "position2"));
	dS.addOption(new SelectionData("Position 3", "position3"));
	this.addPart(dS);
}
B_Display.prototype = Object.create(CommandBlock.prototype);
B_Display.prototype.constructor = B_Display;
/* Displays the value on the screen */
B_Display.prototype.startAction = function() {
	const message = this.slots[0].getData().getValue();
	const position = this.slots[1].getData().getValue();
	DisplayBoxManager.displayText(message, position);
	return new ExecutionStatusDone(); // Done running
};
/* This file contains the implementations for Blocks in the operators category. */
function B_Add(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new NumSlot(this, "NumS_1", 0));
	this.addPart(new LabelText(this, "+"));
	this.addPart(new NumSlot(this, "NumS_2", 0));
}
B_Add.prototype = Object.create(ReporterBlock.prototype);
B_Add.prototype.constructor = B_Add;
/* Returns the sum of the Slots. Result is valid only if both inputs are. */
B_Add.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const data2 = this.slots[1].getData();
	const isValid = data1.isValid && data2.isValid;
	const val = data1.getValue() + data2.getValue();
	return new ExecutionStatusResult(new NumData(val, isValid));
};



function B_Subtract(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new NumSlot(this, "NumS_1", 0));
	this.addPart(new LabelText(this, String.fromCharCode(8211)));
	this.addPart(new NumSlot(this, "NumS_2", 0));
}
B_Subtract.prototype = Object.create(ReporterBlock.prototype);
B_Subtract.prototype.constructor = B_Subtract;
/* Sets the result to the difference between the Slots. Result is valid only if both inputs are. */
B_Subtract.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const data2 = this.slots[1].getData();
	const isValid = data1.isValid && data2.isValid;
	const val = data1.getValue() - data2.getValue();
	return new ExecutionStatusResult(new NumData(val, isValid));
};



function B_Multiply(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new NumSlot(this, "NumS_1", 0));
	this.addPart(new LabelText(this, "*"));
	this.addPart(new NumSlot(this, "NumS_2", 0));
}
B_Multiply.prototype = Object.create(ReporterBlock.prototype);
B_Multiply.prototype.constructor = B_Multiply;
/* Sets the result to the product of the Slots. Result is valid only if both inputs are. */
B_Multiply.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const data2 = this.slots[1].getData();
	const isValid = data1.isValid && data2.isValid;
	const val = data1.getValue() * data2.getValue();
	return new ExecutionStatusResult(new NumData(val, isValid));
};



function B_Divide(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new NumSlot(this, "NumS_1", 0));
	this.addPart(new LabelText(this, "/"));
	this.addPart(new NumSlot(this, "NumS_2", 1));
}
B_Divide.prototype = Object.create(ReporterBlock.prototype);
B_Divide.prototype.constructor = B_Divide;
/* Sets the result to the quotient of the Slots. Result is valid only if both inputs are and Slot2 != 0. */
B_Divide.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const data2 = this.slots[1].getData();
	const val1 = data1.getValue();
	const val2 = data2.getValue();
	let isValid = data1.isValid && data2.isValid;
	let val = val1 / val2;
	if (val2 === 0) {
		val = 0; // Return invalid 0 if told to divide by 0.
		isValid = false;
	}
	return new ExecutionStatusResult(new NumData(val, isValid));
};



function B_Mod(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new NumSlot(this, "NumS_1", 17));
	this.addPart(new LabelText(this, "mod"));
	this.addPart(new NumSlot(this, "NumS_2", 10));
}
B_Mod.prototype = Object.create(ReporterBlock.prototype);
B_Mod.prototype.constructor = B_Mod;
/* Sets the result to the first Slot mod the second Slot. Valid if Slots are valid and second isn't 0. */
B_Mod.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const data2 = this.slots[1].getData();
	const val1 = data1.getValue();
	const val2 = data2.getValue();
	let isValid = data1.isValid && data2.isValid;
	let result = ((val1 % val2) + val2) % val2;
	if (val2 === 0) {
		result = 0;
		isValid = false;
	}
	return new ExecutionStatusResult(new NumData(result, isValid));
};



function B_Round(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "round"));
	this.addPart(new NumSlot(this, "NumS_1", 0.5));
}
B_Round.prototype = Object.create(ReporterBlock.prototype);
B_Round.prototype.constructor = B_Round;
/* Sets the result to the rounded value of the Slot. Is valid only if Slot is. */
B_Round.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const isValid = data1.isValid;
	const val = data1.getValueWithC(false, true); // Integer
	return new ExecutionStatusResult(new NumData(val, isValid));
};



function B_PickRandom(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "pick random"));
	this.addPart(new NumSlot(this, "NumS_min", 1));
	this.addPart(new LabelText(this, "to"));
	this.addPart(new NumSlot(this, "NumS_max", 10));
}
/* Picks a random integer if both Slots are integers. Otherwise it selects a random float. Is valid if both are. */
B_PickRandom.prototype = Object.create(ReporterBlock.prototype);
B_PickRandom.prototype.constructor = B_PickRandom;
B_PickRandom.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const data2 = this.slots[1].getData();
	const isValid = data1.isValid && data2.isValid;
	const val1 = data1.getValue();
	const val2 = data2.getValue();
	const integer = Number.isInteger(val1) && Number.isInteger(val2);
	let min = val1;
	let max = val2;
	let rVal;
	if (min > max) {
		min = val2;
		max = val1;
	}
	if (integer) {
		rVal = Math.floor(Math.random() * (max - min + 1)) + min;
	} else {
		rVal = Math.random() * (max - min) + min;
	}
	return new ExecutionStatusResult(new NumData(rVal, isValid));
};



function B_LessThan(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new NumSlot(this, "NumS_1", 0));
	this.addPart(new LabelText(this, "<"));
	this.addPart(new NumSlot(this, "NumS_2", 0));
}
B_LessThan.prototype = Object.create(PredicateBlock.prototype);
B_LessThan.prototype.constructor = B_LessThan;
/* Result is a valid boolean indicating is Slot1 < Slot2. */
B_LessThan.prototype.startAction = function() {
	const val1 = this.slots[0].getData().getValue();
	const val2 = this.slots[1].getData().getValue();
	return new ExecutionStatusResult(new BoolData(val1 < val2));
};



function B_EqualTo(x, y) { // needs to work with strings
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new NumOrStringSlot(this, "RndS_item1", new NumData(0)));
	this.addPart(new LabelText(this, "="));
	this.addPart(new NumOrStringSlot(this, "RndS_item2", new NumData(0)));
}
B_EqualTo.prototype = Object.create(PredicateBlock.prototype);
B_EqualTo.prototype.constructor = B_EqualTo;
/* Compares data of any type to determine equality. Result is always valid. */
B_EqualTo.prototype.startAction = function() {
	const data1 = this.slots[0].getData();
	const data2 = this.slots[1].getData();
	return new ExecutionStatusResult(new BoolData(Data.checkEquality(data1, data2)));
};



function B_GreaterThan(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new NumSlot(this, "NumS_1", 0));
	this.addPart(new LabelText(this, ">"));
	this.addPart(new NumSlot(this, "NumS_2", 0));
}
B_GreaterThan.prototype = Object.create(PredicateBlock.prototype);
B_GreaterThan.prototype.constructor = B_GreaterThan;
/* Result is a valid boolean indicating is Slot1 > Slot2. */
B_GreaterThan.prototype.startAction = function() {
	const val1 = this.slots[0].getData().getValue();
	const val2 = this.slots[1].getData().getValue();
	return new ExecutionStatusResult(new BoolData(val1 > val2));
};



function B_And(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new BoolSlot(this, "BoolS_1"));
	this.addPart(new LabelText(this, "and"));
	this.addPart(new BoolSlot(this, "BoolS_2"));
}
B_And.prototype = Object.create(PredicateBlock.prototype);
B_And.prototype.constructor = B_And;
/* Result is true if both are true. Always valid. */
B_And.prototype.startAction = function() {
	const val1 = this.slots[0].getData().getValue();
	const val2 = this.slots[1].getData().getValue();
	return new ExecutionStatusResult(new BoolData(val1 && val2));
};



function B_Or(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new BoolSlot(this, "BoolS_1"));
	this.addPart(new LabelText(this, "or"));
	this.addPart(new BoolSlot(this, "BoolS_2"));
}
B_Or.prototype = Object.create(PredicateBlock.prototype);
B_Or.prototype.constructor = B_Or;
/* Result is true if either is true. Always valid. */
B_Or.prototype.startAction = function() {
	const val1 = this.slots[0].getData().getValue();
	const val2 = this.slots[1].getData().getValue();
	return new ExecutionStatusResult(new BoolData(val1 || val2));
};



function B_Not(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "not"));
	this.addPart(new BoolSlot(this, "BoolS_1"));
}
B_Not.prototype = Object.create(PredicateBlock.prototype);
B_Not.prototype.constructor = B_Not;
/* Result is true if Slot is false. Always valid. */
B_Not.prototype.startAction = function() {
	const val1 = this.slots[0].getData().getValue();
	return new ExecutionStatusResult(new BoolData(!val1));
};



function B_True(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "true"));
}
B_True.prototype = Object.create(PredicateBlock.prototype);
B_True.prototype.constructor = B_True;
/* Result is true. */
B_True.prototype.startAction = function() {
	return new ExecutionStatusResult(new BoolData(true));
};



function B_False(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "false"));
}
B_False.prototype = Object.create(PredicateBlock.prototype);
B_False.prototype.constructor = B_False;
/* Result is false. */
B_False.prototype.startAction = function() {
	return new ExecutionStatusResult(new BoolData(false));
};



function B_LetterOf(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "letter"));
	const nS = new NumSlot(this, "NumS_idx", 1, true, true);
	nS.addLimits(1);
	this.addPart(nS);
	this.addPart(new LabelText(this, "of"));
	this.addPart(new StringSlot(this, "StrS_text", "world"));
}
B_LetterOf.prototype = Object.create(ReporterBlock.prototype);
B_LetterOf.prototype.constructor = B_LetterOf;
/* Result is nth letter of word. Makes n and integer in range. Always valid. */
B_LetterOf.prototype.startAction = function() {
	const word = this.slots[1].getData().getValue();
	const index = this.slots[0].getData().getValueInR(1, word.length, true, true);
	if (word.length > 0) {
		return new ExecutionStatusResult(new StringData(word.substring(index - 1, index)));
	} else {
		return new ExecutionStatusResult(new StringData("")); // Letter of empty string is empty string.
	}
};



function B_LengthOf(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "length of"));
	this.addPart(new StringSlot(this, "StrS_text", "world"));
}
B_LengthOf.prototype = Object.create(ReporterBlock.prototype);
B_LengthOf.prototype.constructor = B_LengthOf;
/* Result is length of word. Always valid. */
B_LengthOf.prototype.startAction = function() {
	const word = this.slots[0].getData().getValue();
	return new ExecutionStatusResult(new NumData(word.length));
};



function B_join(x, y) {
	ReporterBlock.call(this, x, y, "operators", Block.returnTypes.string);
	this.addPart(new LabelText(this, "join"));
	this.addPart(new StringSlot(this, "StrS_1", "hello "));
	this.addPart(new LabelText(this, "and"));
	this.addPart(new StringSlot(this, "StrS_2", "world"));
}
B_join.prototype = Object.create(ReporterBlock.prototype);
B_join.prototype.constructor = B_join;
/* Result is Slots concatenated. Always valid. */
B_join.prototype.startAction = function() {
	const word1 = this.slots[0].getData().getValue();
	const word2 = this.slots[1].getData().getValue();
	return new ExecutionStatusResult(new StringData(word1 + word2));
};



function B_Split(x, y) {
	ReporterBlock.call(this, x, y, "operators", Block.returnTypes.list);
	this.addPart(new LabelText(this, "split"));
	this.addPart(new StringSlot(this, "StrS_1", "hello world"));
	this.addPart(new LabelText(this, "by"));

	const inputType = EditableSlot.inputTypes.any;
	const snapType = Slot.snapTypes.numStrBool;
	const data = new SelectionData("whitespace", "whitespace");
	const dS = new DropSlot(this, "DS_separator", inputType, snapType, data);
	dS.addEnterText("Edit text");
	dS.addOption(new SelectionData("letter", "letter"));
	dS.addOption(new SelectionData("whitespace", "whitespace"));
	this.addPart(dS);
}
B_Split.prototype = Object.create(ReporterBlock.prototype);
B_Split.prototype.constructor = B_Split;
/* Returns a list made from splitting the string by the provided character. */
B_Split.prototype.startAction = function() {
	const string1 = this.slots[0].getData().getValue();
	const splitD = this.slots[1].getData();
	let resultArray;
	if (splitD.type === Data.types.string) {
		const splitStr = splitD.getValue();
		resultArray = string1.split(splitStr);
	} else if (splitD.type === Data.types.selection) {
		const selection = splitD.getValue();
		if (selection === "letter") {
			resultArray = string1.split("");
		} else if (selection === "whitespace") {
			resultArray = string1.split(/\s+/);
		}
	} else {
		resultArray = [];
	}
	const dataArray = new Array(resultArray.length);
	for (let i = 0; i < resultArray.length; i++) {
		dataArray[i] = new StringData(resultArray[i]);
	}
	return new ExecutionStatusResult(new ListData(dataArray));
};



function B_IsAType(x, y) {
	PredicateBlock.call(this, x, y, "operators");
	this.addPart(new LabelText(this, "is"));
	this.addPart(new RectSlot(this, "RectS_item", Slot.snapTypes.any, Slot.outputTypes.any, new NumData(5)));
	this.addPart(new LabelText(this, "a"));
	const dS = new DropSlot(this, "DS_type", null, null, new SelectionData("number", "number"));
	dS.addOption(new SelectionData("number", "number"));
	dS.addOption(new SelectionData("text", "text"));
	dS.addOption(new SelectionData("boolean", "boolean"));
	dS.addOption(new SelectionData("list", "list"));
	dS.addOption(new SelectionData("invalid number", "invalid_num"));
	this.addPart(dS);
	this.addPart(new LabelText(this, "?"));
}
B_IsAType.prototype = Object.create(PredicateBlock.prototype);
B_IsAType.prototype.constructor = B_IsAType;
/* Returns whether the data is of the selected type */
B_IsAType.prototype.startAction = function() {
	const data = this.slots[0].getData();
	const selectionD = this.slots[1].getData();
	const selection = selectionD.getValue();
	const types = Data.types;
	if (selection === "number") {
		if (data.type === types.num && data.isValid) {
			return new ExecutionStatusResult(new BoolData(true));
		} else if (data.type === types.string && data.isNumber()) {
			return new ExecutionStatusResult(new BoolData(true));
		} else {
			return new ExecutionStatusResult(new BoolData(false));
		}
	} else if (selection === "text") {
		return new ExecutionStatusResult(new BoolData(data.type === types.string && !data.isNumber()));
	} else if (selection === "boolean") {
		return new ExecutionStatusResult(new BoolData(data.type === types.bool));
	} else if (selection === "list") {
		return new ExecutionStatusResult(new BoolData(data.type === types.list));
	} else if (selection === "invalid_num") {
		const invalidNumStr = (new NumData(0 / 0).asString().getValue()); // "not a valid number"
		if (data.type === types.num && !data.isValid) {
			return new ExecutionStatusResult(new BoolData(true));
		} else if (data.type === types.string && data.getValue() === invalidNumStr) {
			return new ExecutionStatusResult(new BoolData(true));
		} else {
			return new ExecutionStatusResult(new BoolData(false));
		}
	} else {
		return new ExecutionStatusResult(new BoolData(false));
	}
};



function B_mathOfNumber(x, y) {
	ReporterBlock.call(this, x, y, "operators");
	const dS = new DropSlot(this, "DS_operation", null, null, new SelectionData("sqrt", "sqrt"));
	dS.addOption(new SelectionData("sin", "sin"));
	dS.addOption(new SelectionData("cos", "cos"));
	dS.addOption(new SelectionData("tan", "tan"));

	dS.addOption(new SelectionData("asin", "asin"));
	dS.addOption(new SelectionData("acos", "acos"));
	dS.addOption(new SelectionData("atan", "atan"));

	dS.addOption(new SelectionData("ln", "ln"));
	dS.addOption(new SelectionData("e^", "e^"));
	dS.addOption(new SelectionData("ceiling", "ceiling"));

	dS.addOption(new SelectionData("log", "log"));
	dS.addOption(new SelectionData("10^", "10^"));
	dS.addOption(new SelectionData("floor", "floor"));

	dS.addOption(new SelectionData("abs", "abs"));
	dS.addOption(new SelectionData("sqrt", "sqrt"));

	this.addPart(dS);
	this.addPart(new LabelText(this, "of"));
	this.addPart(new NumSlot(this, "NumS_val", 10));
}
B_mathOfNumber.prototype = Object.create(ReporterBlock.prototype);
B_mathOfNumber.prototype.constructor = B_mathOfNumber;
/* Applies selected operation to input */
B_mathOfNumber.prototype.startAction = function() {
	const operator = this.slots[0].getData().getValue();
	const data = this.slots[1].getData();
	let value = data.getValue();
	let isValid = data.isValid;
	if (operator === "sin") {
		value = Math.sin(value / 180 * Math.PI);
	} else if (operator === "cos") {
		value = Math.cos(value / 180 * Math.PI);
	} else if (operator === "tan") {
		value = Math.tan(value / 180 * Math.PI);
		if (Math.abs(value) > 1000000000) {
			value = 1 / 0;
		}
	} else if (operator === "asin") {
		value = Math.asin(value) / Math.PI * 180;
	} else if (operator === "acos") {
		value = Math.acos(value) / Math.PI * 180;
	} else if (operator === "atan") {
		value = Math.atan(value) / Math.PI * 180;
	} else if (operator === "ln") {
		value = Math.log(value);
	} else if (operator === "log") {
		try {
			value = Math.log10(value);
		} catch (e) {
			value = Math.log(10) / Math.log(value);
		}
	} else if (operator === "e^") {
		value = Math.exp(value);
	} else if (operator === "10^") {
		value = Math.pow(10, value);
	} else if (operator === "ceiling") {
		value = Math.ceil(value);
	} else if (operator === "floor") {
		value = Math.floor(value);
	} else if (operator === "abs") {
		value = Math.abs(value);
	} else if (operator === "sqrt") {
		value = Math.sqrt(value);
	}
	if (!isFinite(value) || isNaN(value)) {
		value = 0;
		isValid = false;
	}
	return new ExecutionStatusResult(new NumData(value, isValid));
};
/* This file contains the implementations for Blocks in the tablet category. */
/* TODO: remove redundancy by making these blocks subclasses of a single Block */


/*
function B_ThrowError(x, y) {
	ReporterBlock.call(this, x, y, "tablet", Block.returnTypes.string);
	this.addPart(new LabelText(this, "Throw error!"));
}
B_ThrowError.prototype = Object.create(ReporterBlock.prototype);
B_ThrowError.prototype.constructor = B_ThrowError;
B_ThrowError.prototype.startAction = function() {
	DebugOptions.throw("Execution of B_ThrowError");
};
*/


function B_DeviceShaken(x, y) {
	PredicateBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "Device Shaken"));
}
B_DeviceShaken.prototype = Object.create(PredicateBlock.prototype);
B_DeviceShaken.prototype.constructor = B_DeviceShaken;
/* Make the request. */
B_DeviceShaken.prototype.startAction = function() {
	const mem = this.runMem;
	mem.request = "tablet/shake";
	mem.requestStatus = function() {};
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. */
B_DeviceShaken.prototype.updateAction = function() {
	const mem = this.runMem;
	const status = mem.requestStatus;
	if (status.finished === true) {
		if (status.error === false) {
			return new ExecutionStatusResult(new BoolData(status.result === "1", true));
		} else {
			if (status.result.length > 0) {
				this.displayError(status.result);
				return new ExecutionStatusError();
			} else {
				return new ExecutionStatusResult(new BoolData(false, false)); // false is default.
			}
		}
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};
B_DeviceShaken.prototype.checkActive = function() {
	return TabletSensors.sensors.accelerometer;
};



function B_DeviceSSID(x, y) {
	ReporterBlock.call(this, x, y, "tablet", Block.returnTypes.string);
	this.addPart(new LabelText(this, "Device SSID"));
}
B_DeviceSSID.prototype = Object.create(ReporterBlock.prototype);
B_DeviceSSID.prototype.constructor = B_DeviceSSID;
/* Make the request. */
B_DeviceSSID.prototype.startAction = function() {
	const mem = this.runMem;
	mem.request = "tablet/ssid";
	mem.requestStatus = function() {};
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. */
B_DeviceSSID.prototype.updateAction = function() {
	const mem = this.runMem;
	const status = mem.requestStatus;
	if (status.finished === true) {
		if (status.error === false) {
			return new ExecutionStatusResult(new StringData(status.result, true));
		} else {
			if (status.result.length > 0) {
				this.displayError(status.result);
				return new ExecutionStatusError();
			} else {
				return new ExecutionStatusResult(new StringData("", false)); //"" is default.
			}
		}
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};



function B_DevicePressure(x, y) {
	ReporterBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "Device Pressure"));
}
B_DevicePressure.prototype = Object.create(ReporterBlock.prototype);
B_DevicePressure.prototype.constructor = B_DevicePressure;
/* Make the request. */
B_DevicePressure.prototype.startAction = function() {
	const mem = this.runMem;
	mem.request = "tablet/pressure";
	mem.requestStatus = function() {};
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. */
B_DevicePressure.prototype.updateAction = function() {
	const mem = this.runMem;
	const status = mem.requestStatus;
	if (status.finished === true) {
		if (status.error === false) {
			const result = Number(status.result);
			return new ExecutionStatusResult(new NumData(result, true));
		} else {
			if (status.result.length > 0) {
				this.displayError(status.result);
				return new ExecutionStatusError();
			} else {
				return new ExecutionStatusResult(new NumData(0, false)); //0 is default.
			}
		}
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};
B_DevicePressure.prototype.checkActive = function() {
	return TabletSensors.sensors.barometer;
};
Block.setDisplaySuffix(B_DevicePressure, "kPa");



function B_DeviceRelativeAltitude(x, y) {
	ReporterBlock.call(this, x, y, "tablet");
	this.addPart(new LabelText(this, "Device Relative Altitude"));
}
B_DeviceRelativeAltitude.prototype = Object.create(ReporterBlock.prototype);
B_DeviceRelativeAltitude.prototype.constructor = B_DeviceRelativeAltitude;
/* Make the request. */
B_DeviceRelativeAltitude.prototype.startAction = function() {
	const mem = this.runMem;
	mem.request = "tablet/altitude";
	mem.requestStatus = function() {};
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. */
B_DeviceRelativeAltitude.prototype.updateAction = function() {
	const mem = this.runMem;
	const status = mem.requestStatus;
	if (status.finished === true) {
		if (status.error === false) {
			const result = Number(status.result);
			return new ExecutionStatusResult(new NumData(result, true));
		} else {
			if (status.result.length > 0) {
				this.displayError(status.result);
				return new ExecutionStatusError();
			} else {
				return new ExecutionStatusResult(new NumData(0, false)); //0 is default.
			}
		}
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};
B_DeviceRelativeAltitude.prototype.checkActive = function() {
	return TabletSensors.sensors.barometer;
};
Block.setDisplaySuffix(B_DeviceRelativeAltitude, "m");



function B_DeviceOrientation(x, y) {
	ReporterBlock.call(this, x, y, "tablet", Block.returnTypes.string);
	this.addPart(new LabelText(this, "Device Orientation"));
}
B_DeviceOrientation.prototype = Object.create(ReporterBlock.prototype);
B_DeviceOrientation.prototype.constructor = B_DeviceOrientation;
/* Make the request. */
B_DeviceOrientation.prototype.startAction = function() {
	const mem = this.runMem;
	mem.request = "tablet/orientation";
	mem.requestStatus = function() {};
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. */
B_DeviceOrientation.prototype.updateAction = function() {
	const mem = this.runMem;
	const status = mem.requestStatus;
	if (status.finished === true) {
		if (status.error === false) {
			return new ExecutionStatusResult(new StringData(status.result, true));
		} else {
			if (status.result.length > 0) {
				this.displayError(status.result);
				return new ExecutionStatusError();
			} else {
				return new ExecutionStatusResult(new StringData("", false)); //"" is default.
			}
		}
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};
B_DeviceOrientation.prototype.checkActive = function() {
	return TabletSensors.sensors.accelerometer;
};



function B_DeviceAcceleration(x, y) {
	ReporterBlock.call(this, x, y, "tablet", Block.returnTypes.num);
	this.addPart(new LabelText(this, "Device"));
	const dS = new DropSlot(this, "DS_axis", null, null, new SelectionData("X", 0));
	dS.addOption(new SelectionData("X", 0));
	dS.addOption(new SelectionData("Y", 1));
	dS.addOption(new SelectionData("Z", 2));
	dS.addOption(new SelectionData("Total", "total"));
	this.addPart(dS);
	this.addPart(new LabelText(this, "Acceleration"));
}
B_DeviceAcceleration.prototype = Object.create(ReporterBlock.prototype);
B_DeviceAcceleration.prototype.constructor = B_DeviceAcceleration;
/* Make the request. */
B_DeviceAcceleration.prototype.startAction = function() {
	const mem = this.runMem;
	mem.request = "tablet/acceleration";
	mem.requestStatus = function() {};
	mem.axis = this.slots[0].getData().getValue();
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. Then get the correct axis. */
B_DeviceAcceleration.prototype.updateAction = function() {
	const mem = this.runMem;
	const status = mem.requestStatus;
	if (status.finished === true) {
		if (status.error === false) {
			const parts = status.result.split(" ");
			let result;
			if (mem.axis === "total") {
				let x = Number(parts[0]);
				let y = Number(parts[1]);
				let z = Number(parts[2]);
				result = Math.sqrt(x * x + y * y + z * z);
			} else {
				result = Number(parts[mem.axis]);
			}
			return new ExecutionStatusResult(new NumData(result, true));
		} else {
			if (status.result.length > 0) {
				this.displayError(status.result);
				return new ExecutionStatusError();
			} else {
				return new ExecutionStatusResult(new NumData(0, false)); //0 is default.
			}
		}
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};
B_DeviceAcceleration.prototype.checkActive = function() {
	return TabletSensors.sensors.accelerometer;
};
Block.setDisplaySuffix(B_DeviceAcceleration, "m/s" + String.fromCharCode(178));



function B_DeviceLocation(x, y) {
	ReporterBlock.call(this, x, y, "tablet", Block.returnTypes.num);
	this.addPart(new LabelText(this, "Device"));
	const dS = new DropSlot(this, "DS_dir", null, null, new SelectionData("Latitude", 0));
	dS.addOption(new SelectionData("Latitude", 0));
	dS.addOption(new SelectionData("Longitude", 1));
	this.addPart(dS);
}
B_DeviceLocation.prototype = Object.create(ReporterBlock.prototype);
B_DeviceLocation.prototype.constructor = B_DeviceLocation;
/* Make the request. */
B_DeviceLocation.prototype.startAction = function() {
	const mem = this.runMem;
	mem.request = "tablet/location";
	mem.requestStatus = function() {};
	mem.axis = this.slots[0].getData().getValue();
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. Then get the correct axis. */
B_DeviceLocation.prototype.updateAction = function() {
	const mem = this.runMem;
	const status = mem.requestStatus;
	if (status.finished === true) {
		if (status.error === false) {
			const result = status.result.split(" ")[mem.axis];
			return new ExecutionStatusResult(new NumData(Number(result), true));
		} else {
			if (status.result.length > 0) {
				this.displayError(status.result);
				return new ExecutionStatusError();
			} else {
				return new ExecutionStatusResult(new NumData(0, false)); //0 is default.
			}
		}
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};
B_DeviceLocation.prototype.checkActive = function() {
	return TabletSensors.sensors.gps;
};
/* Implementations of sound Blocks */



/**
 * Template used to make 4 sound playing Blocks
 * @param {number} x
 * @param {number} y
 * @param {string} label - The text to display on the Block
 * @param {boolean} isRecording - Whether the Block should display recordings or sounds in the SoundDropSlot
 * @param {boolean} waitUntilDone - Whether the Block should wait until the sound is done playing to advance
 * @constructor
 */
function B_PlaySoundOrRecording(x, y, label, isRecording, waitUntilDone) {
	CommandBlock.call(this, x, y, "sound");
	this.isRecording = isRecording;
	this.waitUntilDone = waitUntilDone;
	this.addPart(new LabelText(this, label));
	let dS = new SoundDropSlot(this, "SDS_1", isRecording);
	this.addPart(dS);
}
B_PlaySoundOrRecording.prototype = Object.create(CommandBlock.prototype);
B_PlaySoundOrRecording.prototype.constructor = B_PlaySoundOrRecording;
/* Makes request using Sound class */
B_PlaySoundOrRecording.prototype.startAction = function() {
	let soundData = this.slots[0].getData();
	if (soundData.isEmpty()) {
		return new ExecutionStatusDone();
	}
	let soundId = soundData.getValue();
	let status = {};
	this.runMem.playStatus = status;
	status.donePlaying = false;
	status.requestSent = false;
	Sound.play(soundId, this.isRecording, status);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for the request to finish. */
B_PlaySoundOrRecording.prototype.updateAction = function() {
	let mem = this.runMem;
	let status = mem.playStatus;
	let done = (status.requestSent && !this.waitUntilDone) || (status.donePlaying && this.waitUntilDone);
	if (done) {
		if (status.error) {
			this.displayError("Sound not found");
			return new ExecutionStatusError();
		}
		return new ExecutionStatusDone(); // Done running
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};



function B_PlaySound(x, y) {
	B_PlaySoundOrRecording.call(this, x, y, "play sound", false, false);
}
B_PlaySound.prototype = Object.create(B_PlaySoundOrRecording.prototype);
B_PlaySound.prototype.constructor = B_PlaySound;



function B_PlaySoundUntilDone(x, y) {
	B_PlaySoundOrRecording.call(this, x, y, "play sound until done", false, true);
}
B_PlaySoundUntilDone.prototype = Object.create(B_PlaySoundOrRecording.prototype);
B_PlaySoundUntilDone.prototype.constructor = B_PlaySoundUntilDone;



function B_PlayRecording(x, y) {
	B_PlaySoundOrRecording.call(this, x, y, "play recording", true, false);
}
B_PlayRecording.prototype = Object.create(B_PlaySoundOrRecording.prototype);
B_PlayRecording.prototype.constructor = B_PlayRecording;



function B_PlayRecordingUntilDone(x, y) {
	B_PlaySoundOrRecording.call(this, x, y, "play recording until done", true, true);
}
B_PlayRecordingUntilDone.prototype = Object.create(B_PlaySoundOrRecording.prototype);
B_PlayRecordingUntilDone.prototype.constructor = B_PlayRecordingUntilDone;



function B_StopAllSounds(x, y) {
	CommandBlock.call(this, x, y, "sound");
	this.addPart(new LabelText(this, "stop all sounds"));
}
B_StopAllSounds.prototype = Object.create(CommandBlock.prototype);
B_StopAllSounds.prototype.constructor = B_StopAllSounds;
/* Send request */
B_StopAllSounds.prototype.startAction = function() {
	const mem = this.runMem;
	mem.requestStatus = {};
	Sound.stopAllSounds(mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait for request to be sent */
B_StopAllSounds.prototype.updateAction = function() {
	if (this.runMem.requestStatus.finished) {
		return new ExecutionStatusDone(); // Done running
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};



function B_RestForBeats(x, y) {
	CommandBlock.call(this, x, y, "sound");
	this.addPart(new LabelText(this, "rest for"));
	this.addPart(new NumSlot(this, "NumS_dur", 0.2, true)); // Positive
	this.addPart(new LabelText(this, "beats"));
}
B_RestForBeats.prototype = Object.create(CommandBlock.prototype);
B_RestForBeats.prototype.constructor = B_RestForBeats;
/* Store the current time */
B_RestForBeats.prototype.startAction = function() {
	const mem = this.runMem;
	mem.startTime = new Date().getTime();
	const beats = this.slots[0].getData().getValueWithC(true); // Positive
	mem.delayTime = CodeManager.beatsToMs(beats);
	return new ExecutionStatusRunning(); // Still running
};
/* Wait until the time is up */
B_RestForBeats.prototype.updateAction = function() {
	const mem = this.runMem;
	if (new Date().getTime() >= mem.startTime + mem.delayTime) {
		return new ExecutionStatusDone(); // Done running
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};



function B_PlayNoteForBeats(x, y) {
	CommandBlock.call(this, x, y, "sound");
	this.addPart(new LabelText(this, "play note"));
	this.addPart(new NumSlot(this, "NumS_note", 60, true, true)); // Positive integer
	this.addPart(new LabelText(this, "for"));
	this.addPart(new NumSlot(this, "NumS_dur", 1, true)); // Positive
	this.addPart(new LabelText(this, "beats"));
}
B_PlayNoteForBeats.prototype = Object.create(CommandBlock.prototype);
B_PlayNoteForBeats.prototype.constructor = B_PlayNoteForBeats;
/* Send request */
B_PlayNoteForBeats.prototype.startAction = function() {
	const mem = this.runMem;
	const note = this.slots[0].getData().getValueWithC(true, true);
	const beats = this.slots[1].getData().getValueWithC(true); // Positive
	mem.soundDuration = CodeManager.beatsToMs(beats);
	mem.request = "sound/note?note=" + note + "&duration=" + mem.soundDuration;
	mem.timerStarted = false;
	mem.requestStatus = function() {};
	HtmlServer.sendRequest(mem.request, mem.requestStatus);
	return new ExecutionStatusRunning(); // Still running
};
/* When the request is sent, start a timer then wait for the timer to expire */
B_PlayNoteForBeats.prototype.updateAction = function() {
	const mem = this.runMem;
	if (!mem.timerStarted) {
		const status = mem.requestStatus;
		if (status.finished === true) {
			mem.startTime = new Date().getTime();
			mem.timerStarted = true;
		} else {
			return new ExecutionStatusRunning(); // Still running
		}
	}
	if (new Date().getTime() >= mem.startTime + mem.soundDuration) {
		return new ExecutionStatusDone(); // Done running
	} else {
		return new ExecutionStatusRunning(); // Still running
	}
};



function B_ChangeTempoBy(x, y) {
	CommandBlock.call(this, x, y, "sound");
	this.addPart(new LabelText(this, "change tempo by"));
	this.addPart(new NumSlot(this, "NumS_amt", 20));
}
B_ChangeTempoBy.prototype = Object.create(CommandBlock.prototype);
B_ChangeTempoBy.prototype.constructor = B_ChangeTempoBy;
/* Changes the tempo stored in CodeManager */
B_ChangeTempoBy.prototype.startAction = function() {
	const slotData = this.slots[0].getData();
	if (slotData.isValid) {
		const newTempo = CodeManager.sound.tempo + slotData.getValue();
		CodeManager.setSoundTempo(newTempo);
	}
	return new ExecutionStatusDone();
};



function B_SetTempoTo(x, y) {
	CommandBlock.call(this, x, y, "sound");
	this.addPart(new LabelText(this, "set tempo to"));
	const nS = new NumSlot(this, "NumS_tempo", 60, true); // Positive
	nS.addLimits(20, 500, null);
	this.addPart(nS);
	this.addPart(new LabelText(this, "bpm"));
}
B_SetTempoTo.prototype = Object.create(CommandBlock.prototype);
B_SetTempoTo.prototype.constructor = B_SetTempoTo;
/* Sets the tempo stored in CodeManager */
B_SetTempoTo.prototype.startAction = function() {
	const slotData = this.slots[0].getData();
	if (slotData.isValid) {
		const newTempo = slotData.getValue();
		CodeManager.setSoundTempo(newTempo);
	}
	return new ExecutionStatusDone();
};



function B_Tempo(x, y) {
	ReporterBlock.call(this, x, y, "sound");
	this.addPart(new LabelText(this, "tempo"));
}
B_Tempo.prototype = Object.create(ReporterBlock.prototype);
B_Tempo.prototype.constructor = B_Tempo;
/* Retrieve the tempo */
B_Tempo.prototype.startAction = function() {
	return new ExecutionStatusResult(new NumData(CodeManager.sound.tempo));
};
/* Implementation of blocks that deal with variables and lists.  Most of these blocks have a DropSlot to select
 * the list to read/modify.  Some of the List Blocks allow this Slot to be given either an existing List
 * or a ListData, such as returned from the Split block.
 */


/**
 * Variable Blocks are special since their constructor takes an extra Variable parameter.
 * @param {number} x
 * @param {number} y
 * @param {Variable} variable - The variable that this Block will return the value of
 * @constructor
 */
function B_Variable(x, y, variable) {
	ReporterBlock.call(this, x, y, "variables", Block.returnTypes.string);
	this.variable = variable;
	this.addPart(new LabelText(this, this.variable.getName()));
}
B_Variable.prototype = Object.create(ReporterBlock.prototype);
B_Variable.prototype.constructor = B_Variable;
/* Return the value of the variable */
B_Variable.prototype.startAction = function() {
	return new ExecutionStatusResult(this.variable.getData());
};
/**
 * @inheritDoc
 * @param {Document} xmlDoc - The document to write to
 * @return {Node} - The node for this Block
 */
B_Variable.prototype.createXml = function(xmlDoc) {
	const block = XmlWriter.createElement(xmlDoc, "block");
	XmlWriter.setAttribute(block, "type", this.blockTypeName);
	XmlWriter.setAttribute(block, "variable", this.variable.getName());
	return block;
};
/**
 * Called from the Block's context menu if it is in a DisplayStack
 */
B_Variable.prototype.renameVar = function() {
	// Shows dialog for new name
	this.variable.rename();
};
/**
 * Called from the Block's context menu if it is in a DisplayStack
 */
B_Variable.prototype.deleteVar = function() {
	// Deletes variable if unused, or shows confirmation dialog
	this.variable.delete();
};
/**
 * @inheritDoc
 * @param {Variable} variable
 */
B_Variable.prototype.renameVariable = function(variable) {
	if (variable === this.variable) {
		// Update the block by changing its label
		this.parts[0].remove();
		this.parts[0] = new LabelText(this, this.variable.getName());
		if (this.stack != null) {
			// The stack may now be a different size
			this.stack.updateDim();
		}
	}
};
/**
 * @inheritDoc
 * @param {Variable} variable
 */
B_Variable.prototype.deleteVariable = function(variable) {
	if (variable === this.variable) {
		// Delete occurrences of this Block
		this.unsnap().remove();
	}
};
/**
 * @inheritDoc
 * @param {Variable} variable
 * @return {boolean}
 */
B_Variable.prototype.checkVariableUsed = function(variable) {
	return variable === this.variable
};
/**
 * Creates a variable Block from XML
 * @param {Node} blockNode - The node to import from
 * @return {Block|null} - The imported Block
 */
B_Variable.importXml = function(blockNode) {
	const variableName = XmlWriter.getAttribute(blockNode, "variable");
	const variable = CodeManager.findVar(variableName);
	if (variable != null) {
		return new B_Variable(0, 0, variable);
	}
	return null;
};



function B_SetTo(x, y) {
	CommandBlock.call(this, x, y, "variables");
	this.addPart(new LabelText(this, "set"));
	this.addPart(new VarDropSlot(this, "VDS_1"));
	this.addPart(new LabelText(this, "to"));
	this.addPart(new NumOrStringSlot(this, "RndS_val", new NumData(0)));
}
B_SetTo.prototype = Object.create(CommandBlock.prototype);
B_SetTo.prototype.constructor = B_SetTo;
/* Sets the variable to the provided value */
B_SetTo.prototype.startAction = function() {
	// Get the selection data that refers to a variable
	const variableD = this.slots[0].getData();
	// Get the data to assign to the variable
	const data = this.slots[1].getData();
	const type = data.type;
	const types = Data.types;
	if (type === types.bool || type === types.num || type === types.string) {
		// If the selection data is not empty
		if (variableD.type === Data.types.selection && !variableD.isEmpty()) {
			// Extract the indicated variable
			const variable = variableD.getValue();
			// And set its value
			variable.setData(data);
		}
	}
	return new ExecutionStatusDone();
};



function B_ChangeBy(x, y) {
	CommandBlock.call(this, x, y, "variables");
	this.addPart(new LabelText(this, "change"));
	this.addPart(new VarDropSlot(this, "VDS_1"));
	this.addPart(new LabelText(this, "by"));
	this.addPart(new NumSlot(this, "NumS_val", 1));
}
B_ChangeBy.prototype = Object.create(CommandBlock.prototype);
B_ChangeBy.prototype.constructor = B_ChangeBy;
/* Adds the value to the indicated variable */
B_ChangeBy.prototype.startAction = function() {
	const variableD = this.slots[0].getData();
	const incrementD = this.slots[1].getData();
	if (variableD.type === Data.types.selection && !variableD.isEmpty()) {
		const variable = variableD.getValue();
		const currentD = variable.getData().asNum();
		const newV = incrementD.getValue() + currentD.getValue();
		const isValid = currentD.isValid && incrementD.isValid;
		const newD = new NumData(newV, isValid);
		variable.setData(newD);
	}
	return new ExecutionStatusDone();
};


/**
 * Variable Blocks are special since their constructor takes an extra List parameter.
 * @param {number} x
 * @param {number} y
 * @param {List} list - The list that this Block should return the value of
 * @constructor
 */
function B_List(x, y, list) {
	ReporterBlock.call(this, x, y, "lists", Block.returnTypes.string);
	this.list = list;
	this.addPart(new LabelText(this, this.list.getName()));
}
B_List.prototype = Object.create(ReporterBlock.prototype);
B_List.prototype.constructor = B_List;
/* Returns a StringData representing the List's contents, comma separated */
B_List.prototype.startAction = function() {
	return new ExecutionStatusResult(this.list.getData().asString());
};
/**
 * Writes the Block to Xml
 * @param {Document} xmlDoc - The document to write to
 * @return {Node} - The Block node
 */
B_List.prototype.createXml = function(xmlDoc) {
	const block = XmlWriter.createElement(xmlDoc, "block");
	XmlWriter.setAttribute(block, "type", this.blockTypeName);
	XmlWriter.setAttribute(block, "list", this.list.getName());
	return block;
};
/**
 * Imports a List Block from the provided XML node
 * @param {Node} blockNode - The node to import from
 * @return {Block|null} - The imported Block
 */
B_List.importXml = function(blockNode) {
	// The list is stored as a string
	const listName = XmlWriter.getAttribute(blockNode, "list");
	const list = CodeManager.findList(listName);
	if (list != null) {
		return new B_List(0, 0, list);
	}
	return null;
};
/**
 * Called from the Block's context menu if it is in a DisplayStack
 */
B_List.prototype.renameLi = function() {
	this.list.rename();
};
/**
 * Called from the Block's context menu if it is in a DisplayStack
 */
B_List.prototype.deleteLi = function() {
	this.list.delete();
};
/**
 * @inheritDoc
 * @param {List} list
 */
B_List.prototype.renameList = function(list) {
	if (list === this.list) {
		this.parts[0].remove();
		this.parts[0] = new LabelText(this, this.list.getName());
		if (this.stack != null) {
			this.stack.updateDim();
		}
	}
};
/**
 * @inheritDoc
 * @param {List} list
 */
B_List.prototype.deleteList = function(list) {
	if (list === this.list) {
		this.unsnap().remove();
	}
};
/**
 * @inheritDoc
 * @param {List} list
 * @return {boolean}
 */
B_List.prototype.checkListUsed = function(list) {
	return list === this.list
};



function B_AddToList(x, y) {
	CommandBlock.call(this, x, y, "lists");
	this.addPart(new LabelText(this, "add"));
	/* Any type can be added to a list */
	const snapType = Slot.snapTypes.numStrBool;
	const inputType = Slot.outputTypes.any;
	this.addPart(new RectSlot(this, "RectS_item", snapType, inputType, new StringData("thing")));
	this.addPart(new LabelText(this, "to"));
	this.addPart(new ListDropSlot(this, "LDS_1"));
}
B_AddToList.prototype = Object.create(CommandBlock.prototype);
B_AddToList.prototype.constructor = B_AddToList;
/* Adds the item to the list */
B_AddToList.prototype.startAction = function() {
	/* Gets the SelectionData referring to the list */
	const listD = this.slots[1].getData();
	if (listD.type === Data.types.selection && !listD.isEmpty()) {
		/* Extracts the List from the SelectionData */
		const list = listD.getValue();
		/* Gets the array value of the ListData stored in the List */
		const array = list.getData().getValue();
		/* Gets the item to add */
		const itemD = this.slots[0].getData();
		/* Adds the item to the array */
		if (itemD.isValid) {
			array.push(itemD);
		} else {
			array.push(itemD.asString());
		}
	}
	return new ExecutionStatusDone();
};



function B_DeleteItemOfList(x, y) {
	CommandBlock.call(this, x, y, "lists");
	this.addPart(new LabelText(this, "delete"));
	this.addPart(new IndexSlot(this, "NumS_idx", true));
	this.addPart(new LabelText(this, "of"));
	this.addPart(new ListDropSlot(this, "LDS_1"));
}
B_DeleteItemOfList.prototype = Object.create(CommandBlock.prototype);
B_DeleteItemOfList.prototype.constructor = B_DeleteItemOfList;
/* Deletes the item from the List if it exists */
B_DeleteItemOfList.prototype.startAction = function() {
	const listD = this.slots[1].getData();
	if (listD.type === Data.types.selection && !listD.isEmpty()) {
		const indexD = this.slots[0].getData();
		const list = listD.getValue();
		const listData = list.getData();
		const array = listData.getValue();
		if (indexD.type === Data.types.selection && indexD.getValue() === "all") {
			// Delete everything from the List
			list.setData(new ListData());
		} else {
			const index = listData.getIndex(indexD);
			if (index != null) {
				// Delete the indicated index
				array.splice(index, 1);
			}
		}
	}
	return new ExecutionStatusDone();
};



function B_InsertItemAtOfList(x, y) {
	CommandBlock.call(this, x, y, "lists");
	this.addPart(new LabelText(this, "insert"));
	this.addPart(new RectSlot(this, "RectS_item", Slot.snapTypes.numStrBool, Slot.outputTypes.any, new StringData("thing")));
	this.addPart(new LabelText(this, "at"));
	this.addPart(new IndexSlot(this, "NumS_idx", false));
	this.addPart(new LabelText(this, "of"));
	this.addPart(new ListDropSlot(this, "LDS_1"));
}
B_InsertItemAtOfList.prototype = Object.create(CommandBlock.prototype);
B_InsertItemAtOfList.prototype.constructor = B_InsertItemAtOfList;
/* Inserts the item at the indicated position */
B_InsertItemAtOfList.prototype.startAction = function() {
	const listD = this.slots[2].getData();
	if (listD.type === Data.types.selection && !listD.isEmpty()) {
		const indexD = this.slots[1].getData();
		const list = listD.getValue();
		const listData = list.getData();
		const array = listData.getValue();
		const itemD = this.slots[0].getData();
		const index = listData.getIndex(indexD);
		// If the value the user provided is too large, insert after the last element
		if (index == null || indexD.getValue() > array.length) {
			let insertAtEnd = indexD.type === Data.types.num && indexD.getValue() > array.length;
			// Or if the user selected "last" (the only SelectionData)
			insertAtEnd = insertAtEnd || (indexD.isSelection());
			if (insertAtEnd) {
				if (itemD.isValid) {
					array.push(itemD);
				} else {
					array.push(itemD.asString());
				}
			}
			return new ExecutionStatusDone();
		}
		// If everything is valid, simply insert the item
		if (itemD.isValid) {
			array.splice(index, 0, itemD);
		} else {
			array.splice(index, 0, itemD.asString());
		}
	}
	return new ExecutionStatusDone();
};



function B_ReplaceItemOfListWith(x, y) {
	CommandBlock.call(this, x, y, "lists");
	this.addPart(new LabelText(this, "replace item"));
	this.addPart(new IndexSlot(this, "NumS_idx", false));
	this.addPart(new LabelText(this, "of"));
	this.addPart(new ListDropSlot(this, "LDS_1"));
	this.addPart(new LabelText(this, "with"));
	this.addPart(new RectSlot(this, "RectS_item", Slot.snapTypes.numStrBool, Slot.outputTypes.any, new StringData("thing")));
}
B_ReplaceItemOfListWith.prototype = Object.create(CommandBlock.prototype);
B_ReplaceItemOfListWith.prototype.constructor = B_ReplaceItemOfListWith;
/* Replaces the item at the specified index with another one */
B_ReplaceItemOfListWith.prototype.startAction = function() {
	const listD = this.slots[1].getData();
	if (listD.type === Data.types.selection && !listD.isEmpty()) {
		const indexD = this.slots[0].getData();
		const list = listD.getValue();
		const listData = list.getData();
		const array = listData.getValue();
		const itemD = this.slots[2].getData();
		const index = listData.getIndex(indexD);
		if (index == null) {
			// Index is out of bounds, do nothing
			return new ExecutionStatusDone();
		}
		// Replace the item
		if (itemD.isValid) {
			array[index] = itemD;
		} else {
			array[index] = itemD.asString();
		}
	}
	return new ExecutionStatusDone();
};



function B_CopyListToList(x, y) {
	CommandBlock.call(this, x, y, "lists");
	this.addPart(new LabelText(this, "copy"));
	/* This Slot also accepts ListData, such as data from the Split block */
	this.addPart(new ListDropSlot(this, "LDS_from", Slot.snapTypes.list));
	this.addPart(new LabelText(this, "to"));
	/* This Slot must have an already existing List, not a ListData */
	this.addPart(new ListDropSlot(this, "LDS_to"));
}
B_CopyListToList.prototype = Object.create(CommandBlock.prototype);
B_CopyListToList.prototype.constructor = B_CopyListToList;
/* Copies one list to another */
B_CopyListToList.prototype.startAction = function() {
	const listD1 = this.slots[0].getData();
	const listD2 = this.slots[1].getData();
	// If the second list is valid
	if (listD2.type === Data.types.selection && !listD2.isEmpty()) {
		let listDataToCopy;
		if (listD1.type === Data.types.selection && !listD1.isEmpty()) {
			// Retrieve the first list's data if it was selected from the DropSlot
			listDataToCopy = listD1.getValue().getData();
		} else if (listD1.type === Data.types.list) {
			// Retrieve the ListData
			listDataToCopy = listD1;
		} else {
			// First list is of wrong type of Data. Exit.
			return new ExecutionStatusDone();
		}
		// Get the List from the SelectionData
		const listToCopyTo = listD2.getValue();
		// Copy the Data to it
		listToCopyTo.setData(listDataToCopy.duplicate());
	}
	return new ExecutionStatusDone();
};



function B_ItemOfList(x, y) {
	ReporterBlock.call(this, x, y, "lists", Block.returnTypes.string);
	this.addPart(new LabelText(this, "item"));
	this.addPart(new IndexSlot(this, "NumS_idx", false));
	this.addPart(new LabelText(this, "of"));
	// Accepts both Lists and ListData
	this.addPart(new ListDropSlot(this, "LDS_1", Slot.snapTypes.list));
}
B_ItemOfList.prototype = Object.create(ReporterBlock.prototype);
B_ItemOfList.prototype.constructor = B_ItemOfList;
/* Gets the item form the list */
B_ItemOfList.prototype.startAction = function() {
	const listD = this.slots[1].getData();
	let indexD;
	if (listD.type === Data.types.selection && !listD.isEmpty()) {
		// If the list was selected, retrieve it
		indexD = this.slots[0].getData();
		const list = listD.getValue();
		const listData = list.getData();
		// Index in and return the value
		return new ExecutionStatusResult(this.getItemOfList(listData, indexD));
	} else if (listD.type === Data.types.list) {
		indexD = this.slots[0].getData();
		// Index in and return the value
		return new ExecutionStatusResult(this.getItemOfList(listD, indexD));
	} else {
		// Bad Data, exit
		return new ExecutionStatusResult(new StringData("", false));
	}
};
/**
 * Gets the item from the ListData at the specified index
 * TODO: move this function into ListData
 * @param {ListData} listData - the Data to read from
 * @param {NumData} indexD - The index to retrieve
 * @return {StringData} - The retrieved data, as a StringData
 */
B_ItemOfList.prototype.getItemOfList = function(listData, indexD) {
	const array = listData.getValue();
	const index = listData.getIndex(indexD);
	if (index == null) {
		return new StringData("", false);
	} else {
		return array[index];
	}
};



function B_LengthOfList(x, y) {
	ReporterBlock.call(this, x, y, "lists", Block.returnTypes.num);
	this.addPart(new LabelText(this, "length of"));
	// Accepts both Lists and ListData
	this.addPart(new ListDropSlot(this, "LDS_1", Slot.snapTypes.list));
}
B_LengthOfList.prototype = Object.create(ReporterBlock.prototype);
B_LengthOfList.prototype.constructor = B_LengthOfList;
/* Returns the number of items in the List or ListData */
B_LengthOfList.prototype.startAction = function() {
	const listD = this.slots[0].getData();
	if (listD.type === Data.types.selection && !listD.isEmpty()) {
		const list = listD.getValue();
		const array = list.getData().getValue();
		return new ExecutionStatusResult(new NumData(array.length));
	} else if (listD.type === Data.types.list) {
		return new ExecutionStatusResult(new NumData(listD.getValue().length));
	} else {
		return new ExecutionStatusResult(new NumData(0, false));
	}
};



function B_ListContainsItem(x, y) {
	PredicateBlock.call(this, x, y, "lists");
	this.addPart(new ListDropSlot(this, "LDS_1", Slot.snapTypes.list));
	this.addPart(new LabelText(this, "contains"));
	const snapType = Slot.snapTypes.numStrBool;
	const inputType = Slot.outputTypes.any;
	this.addPart(new RectSlot(this, "RectS_item", snapType, inputType, new StringData("thing")));
}
B_ListContainsItem.prototype = Object.create(PredicateBlock.prototype);
B_ListContainsItem.prototype.constructor = B_ListContainsItem;
/* Returns BoolData indicating if the item is in the List */
B_ListContainsItem.prototype.startAction = function() {
	const listD = this.slots[0].getData();
	if (listD.type === Data.types.selection && !listD.isEmpty()) {
		const list = listD.getValue();
		const listData = list.getData();
		const itemD = this.slots[1].getData();
		return new ExecutionStatusResult(this.checkListContainsItem(listData, itemD));
	} else if (listD.type === Data.types.list) {
		const itemD = this.slots[1].getData();
		return new ExecutionStatusResult(this.checkListContainsItem(listD, itemD));
	} else {
		return new ExecutionStatusResult(new BoolData(false, true));
	}
};
/**
 * Returns BoolData indicating if the item is in the List
 * @param {ListData} listData - The list to examine
 * @param {Data} itemD - The item to check
 * @return {BoolData} - true iff itemD appears in listData
 */
B_ListContainsItem.prototype.checkListContainsItem = function(listData, itemD) {
	const array = listData.getValue();
	for (let i = 0; i < array.length; i++) {
		if (Data.checkEquality(itemD, array[i])) {
			return new BoolData(true, true);
		}
	}
	return new BoolData(false, true);
};
